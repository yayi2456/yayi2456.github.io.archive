<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">

<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>


  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Be With Me" type="application/atom+xml" />






<meta name="description" content="来如春梦不多时 去似朝云无觅处">
<meta property="og:type" content="website">
<meta property="og:title" content="Be With Me">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Be With Me">
<meta property="og:description" content="来如春梦不多时 去似朝云无觅处">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Be With Me">
<meta name="twitter:description" content="来如春梦不多时 去似朝云无觅处">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Be With Me</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8214766f6334490a524e10cda5fd72cf";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Be With Me</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">最喜欢你啦！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            Über
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Kategorien
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            Schedule
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            Commonweal 404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/09/编译原理——词法分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YaYi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Be With Me">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/09/编译原理——词法分析/" itemprop="url">编译原理——词法分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-09T00:44:47+08:00">
                2017-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编译原理/" itemprop="url" rel="index">
                    <span itemprop="name">编译原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我有罪….我先是用学编译的时间逛了淘宝….然后又用学编译的时间逛了六维…..我有罪….\infty</p>
<blockquote>
<p>时间：1012cp3 3:15开始 词法分析器介绍</p>
<p>编译并不是一件轻松的事情，对于较大的系统，编译的速度并不理想，这也是为什么我们需要优化编译技术。</p>
</blockquote>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>词法单元（单词）</strong>：由一个词法单元名以及一个可选的属性值组成。名即是语法分析器的输入符号token。<br><strong>模式</strong>：一个词法单元的词素可能具有的形式。一个词素不能与两个或多个词法单元进行匹配（二义性）。<br><strong>词素</strong>：源程序中的字符序列，是程序中实际出现的字符串。</p>
<blockquote>
<p>在lex与yacc中，有时会有一个全局变量。他保存了当前词素（词法单元：关于这里，龙书里面的和wg写的不一样呢？）的属性值，这个属性值可以被记录在语法树上。</p>
</blockquote>
<h2 id="词法分析器要干些什么？"><a href="#词法分析器要干些什么？" class="headerlink" title="词法分析器要干些什么？"></a>词法分析器要干些什么？</h2><p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-12/6339247.jpg" alt=""></p>
<ol>
<li>读入源程序字符，生成词素，确定词法单元序列</li>
<li>与符号表进行交互</li>
<li>过滤掉源程序中的<strong>注释</strong>与<strong>空白</strong></li>
<li>将编译器生成的错误信息与位置联系</li>
<li>预处理：扫描阶段完成不需要生成词法单元的简单处理；词法分析阶段处理扫描阶段的输出并生成词法单元</li>
</ol>
<blockquote>
<p>跳过了一些东西</p>
</blockquote>
<h1 id="正则表达式（正规表达式、正规式）"><a href="#正则表达式（正规表达式、正规式）" class="headerlink" title="正则表达式（正规表达式、正规式）"></a>正则表达式（正规表达式、正规式）</h1><p>为什么需要正则表达式来描述字符串序列呢？<br>像在上下文无关文法中所描述的那样，因为字符们所组成的可能的字符串是<strong>无穷</strong>的。</p>
<p>单词是什么？单词的本质就是<strong>符号串的集合</strong>。正则表达式就是代替了自然语言对特定符号串集合的描述。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>符号表</strong>：符号的有穷集合<br><strong>符号串</strong>：字母表中符号构成的有穷序列。也成<strong>句子</strong>，<strong>字</strong>。<strong>|s|</strong>代表<strong>字符串s的长度</strong>，$\epsilon$是空字符串。<br><strong>语言</strong>：是一个给定符号表上的特定的符号串的集合。</p>
<p>比如：给定符号表{1,0}，有符号串01100010，一种语言是{0，1，00，11，000，111….}即串中只含一种字符的字符串集合。</p>
<p>特例：$\varnothing$是<strong>空语言</strong>。{$\epsilon$}是只含空串的语言。</p>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="符号串的运算"><a href="#符号串的运算" class="headerlink" title="符号串的运算"></a>符号串的运算</h3><p><strong>连接</strong>：x=hou y=se xy=house    s$\epsilon$=$\epsilon$s=s  (emmmm说好的不能这样写呢？)<br><strong>幂</strong>：$s^n=s^(n-1) * s^1$</p>
<h3 id="语言的运算"><a href="#语言的运算" class="headerlink" title="语言的运算"></a>语言的运算</h3><p>下表中运算符的优先级由低到高</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算</th>
<th style="text-align:center">定义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">并</td>
<td style="text-align:center">$L\cup M={ s \ s\in L 或 s\in M} $</td>
</tr>
<tr>
<td style="text-align:center">交</td>
<td style="text-align:center">$LM={ st \ s\in L 且 t\in M} $</td>
</tr>
<tr>
<td style="text-align:center">Kleen闭包</td>
<td style="text-align:center">$L^*=\cup_{i=0}^\infty L^i$</td>
</tr>
<tr>
<td style="text-align:center">正则闭包</td>
<td style="text-align:center">$L^*=\cup_{i=1}^\infty L^i$</td>
</tr>
</tbody>
</table>
<p>$$\color{red}{正则表达式&lt;-&gt;语言运算的简洁描述}$$</p>
<h2 id="正则表达式定义"><a href="#正则表达式定义" class="headerlink" title="正则表达式定义"></a>正则表达式定义</h2><p>字母表$\sum$上的正规式r的定义规则，以及r所表示语言L(r)定义：</p>
<ol>
<li>$\epsilon$是正规式，表示语言{$\epsilon$}</li>
<li>若$a\in \sum$则a是正规式，表示语言{a}</li>
<li>r , s是正规式，表示语言L(r)与L(s)，则：<ol>
<li>(r)|(s)是正规式，表示语言L(r)$\cup$L(s)</li>
<li>(r)(s)是正规式，表示语言L(r)L(s)</li>
<li>$(r)^*$是正规式，表示语言$(L(r))^*$</li>
<li>(r)是正规式，表示语言L(r)</li>
</ol>
</li>
</ol>
<p>第三条的四条，优先级从上到下依次升高。</p>
<blockquote>
<p>$(a|b)^*$={所有由a、b组成的符号串}</p>
</blockquote>
<p>正规式<strong>等价</strong>：r=s &lt;-&gt; L(r)=L(s)</p>
<p>正则运算的特性:<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-12/3363060.jpg" alt=""></p>
<p>可以像产生式那样，为正规式指定名字：</p>
<blockquote>
<p>num -&gt; r1<br>其实，上下文无关文法的描述能力包含了正则表达式的描述能力。所有可以被正则表达式描述的都可以被上下文无关文法描述，但是正则表达式并不能描述某些上下文无关文法可以描述的东西。<br>那么为什么需要正则表达式来实现词法分析器？</p>
<ol>
<li>简化编译器的设计：使每一阶段需要做的事情更加简单清晰</li>
<li>提高编译器的效率：使用专门的字符缓冲技术提高编译速度</li>
<li>增强编译器的可移植性：输入设备相关的特殊性被限制在词法阶段</li>
</ol>
</blockquote>
<p>下面举一个例子：</p>
<blockquote>
<p>无符号整数：<br>digit -&gt; 0|1|2|…|9<br>digits -&gt; digit digit*  其实也可以是$digit^+$<br>optional_fraction -&gt; .digits | $\epsilon$<br>optional_exponent -&gt; (E(+|-|$\epsilon$)digits)|$\epsilon<br>num -&gt; digits optional_fraction optional_exponent</p>
</blockquote>
<p><strong>符号简写：</strong></p>
<p><strong>+</strong>:一个或多个实例<br><strong>?</strong>:0或1个实例：$r?=r|\epsilon$$\rightarrow$$L(r)\cup {\epsilon}$<br><strong>[]字符集</strong>:[abc]=&gt;a|b|c、[a-z0-9]=&gt;a|b|..|z|0|1..|9</p>
<h2 id="非正规集"><a href="#非正规集" class="headerlink" title="非正规集"></a>非正规集</h2><p><strong>正规式无法描述的语言</strong>：{wcw|w是a、b组成的字符串}正规式无法描述平衡或嵌套的结构<br><strong>正规式只能表示</strong>：有限的重复、一个给定结构的无限重复</p>
<p>关于正规式的练习，参考<a href="http://blank" target="_blank" rel="external">第三章练习</a></p>
<h1 id="Lex"><a href="#Lex" class="headerlink" title="Lex"></a>Lex</h1><p>使用流程与yacc类似。</p>
<p>$\color{red}{ATTENTION!</p>
<p>在使用project wizard建立lex的时候你写的那个词法分析器的名字就是那个名字，</p>
<p>你最好别自己再修改，否则在VS里面运行不出来！！！}$</p>
<p>给的是字符流，出来的是单词流。</p>
<p>规则段放正则表达式与语义动作。</p>
<p>第四次作业词法分析器设计将会上传。<a href="http://blank" target="_blank" rel="external">click here to get</a></p>
<h1 id="有限自动机"><a href="#有限自动机" class="headerlink" title="有限自动机"></a>有限自动机</h1><p>有限自动机可以直接转换成程序。</p>
<h2 id="NFA"><a href="#NFA" class="headerlink" title="NFA"></a>NFA</h2><h1 id="从正则表达式到自动机"><a href="#从正则表达式到自动机" class="headerlink" title="从正则表达式到自动机"></a>从正则表达式到自动机</h1><p>从这之后，正是lex所做的事情。</p>
<p>在这一节里，将介绍两个过程：一个是正则表达式到NFA，另一个是NFA到DFA。之所以让NFA做一个过渡，是因为正则表达式直接到DFA的算法很复杂。本次更新掠过。</p>
<p>NFA与DFA的性能差别很大：NFA占用空间比较少，但是使用NFA进行词法分析需要在错误态停止，可能需要花费$O(2^n)$的时间复杂度；DFA占用空间很大（最坏情况下$O(2^n)$），但是使用它进行词法分析的时候接近线性时间。</p>
<h2 id="正则-gt-NFA"><a href="#正则-gt-NFA" class="headerlink" title="正则 -&gt; NFA"></a>正则 -&gt; NFA</h2><p>正则表达式构造NFA使用<strong>MacMaughton-Yamada-Thompson算法</strong>。简称<strong>Thompson算法</strong>。这个算法描述如下：</p>
<p><strong>基本规则：</strong></p>
<h2 id="自动机运转"><a href="#自动机运转" class="headerlink" title="自动机运转"></a>自动机运转</h2><blockquote>
<p>s $\leftarrow$ e -closure({s0});<br>c $\leftarrow$ nextchar;<br>while c $\neq$ eof do<br> s $\leftarrow$ e -closure(d(s,c));<br> c $\leftarrow$ nextchar;<br>end;<br>if S$\cap$F$\neq$ $\varnothing$ then return “yes”<br>         else return “no”</p>
</blockquote>
<hr>
<blockquote>
<p>s $\leftarrow$ s0;<br>c $\leftarrow$ nextchar;<br>while c $\neq$ eof do<br> s $\leftarrow$ d(s,c);<br> c $\leftarrow$ nextchar;<br>end;<br>if s is in F then return “yes”<br>            else return “no”</p>
</blockquote>
<p>前面提到了，NFA占空间更少，DFA识别字符串更快，贪心的人类啊希望能糅合这两者的优点。看前面的NFA代码，其实在第四行那句，实际上就是前面提到的构造DFA的过程。人们想到使用Cache。使用NFA，当NFA构造出DFA的一个状态时，就把这个状态构造的条件以及状态本身存到cache里面。当while进一个c的时候，首先看一看现今状态加上c到达的态是不是已经存在cache，如果存在里面，最耗时间的那一部分就不用运行了。cache的管理仍然是程序局限性原则。占用空间不会太大以期望达到折衷的效果。</p>
<p>如果要构造出一个Lax，需要将所有的正则表达式得到的NFA进行一个并操作（保留各自的终态以区分）。然后构造它的DFA。</p>
<p>值得注意的是，这样不能在一个终态停止，而是在错误态终止并退回到最近经过的那个终态（每经过一个终态，记录当前的<strong>输入指针</strong>以及<strong>匹配模式</strong>）。以防止找到前缀，产生错误。这种方法是<strong>最长前缀法</strong>，在前面已经提到过。</p>
<h1 id="DFA优化"><a href="#DFA优化" class="headerlink" title="DFA优化"></a>DFA优化</h1><p>DFA状态数其实不会太多的影响时间复杂度，当状态变少的时候，将会减少存储空间的消耗。</p>
<p><strong>区分：</strong>一个符号串可区分两个状态：这一个串<strong>从这两个状态出发</strong>在DFA上得到的结果一个是accept，一个是reject。在做区分的时候，其实可以看到：最终字符串得到的终态在不同集合，则他们是可区分的。</p>
<blockquote>
<p>Ex<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-9/60487283.jpg" alt=""><br>a不能区分状态A与B。而且还可以看到，以a开头的所有字符串都不可能区分A与B了。再进一步看到，a不可能区分任意两个，因为所有状态在经过a的状态迁移之后都到达了状态B。<br>同理，b不可能区分ACE，以b开头的都不能区分ACE。但是b却可以区分BD。<br>不要忘记，$\epsilon$可是可以区分的。而且他的区分应该被放在最前面，那是因为$\epsilon$区分了终态与其他状态。</p>
</blockquote>
<p>在区分的过程中发现了这样一个规律：如果对于串s，A状态与B状态经过了s都到达同一个状态C，那么以s做前缀的字符串都不可能区分A与B了。当所有字符串都不能区分A与B的时候，可以把A与B合并成同一个状态。但是对于无穷的字符串，怎么确定 “所有都不行” 呢？ 在前面，我们已经提出了一个解决方案——当前缀s不行的时候，所有的sx都不行了。但是，即使是有了这个规律，使用“不行”的这种方法解决问题仍会显得繁琐。</p>
<p>真正在执行的时候，实行的是<strong>分裂</strong>，这样，通过有顺序地枚举字符串，将能被区分开的状态分开。这样对于前面的<strong>不同集合</strong>的说法，也能更好地理解。</p>
<p><strong>算法描述：</strong>首先使用$\epsilon$区分终态与非终态，将它们分为两个集合。随后，像子集构造法那样，有顺序地枚举输入字符串，将那些经过状态迁移能到达终态（不同集合）的状态剔除出去组成一个新的集合（如果两者到达同一个集合，这两者是不能区分的，应该在同一个集合），对于那些含有多个元素的集合，如果经过一系列不同的状态迁移到达不同的集合，仍需要继续分开。直到不再产生新的集合。</p>
<blockquote>
<p>仍然使用上面的例子，进行分裂的过程：</p>
<ol>
<li>$\epsilon$ -&gt; {A,B,C,D}、{E}</li>
<li>a -&gt; {A,B,C,D}  ({B,B,B,B})-&gt;全部一样，以a打头的不用再试</li>
<li>b -&gt; {A,B,C}{D}  ({C,D,C,E})</li>
<li>b -&gt; {A,C}{B}{D}  ({C,C,D})  -&gt; 不同集合</li>
</ol>
<p>最终得到的最小DFA：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/65136532.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/4345780.jpg" alt=""></p>
</blockquote>
<p>最后使用新的状态进行迁移的时候，一定不会出现问题。</p>
<h1 id="补充：从自动机到正则表达式"><a href="#补充：从自动机到正则表达式" class="headerlink" title="补充：从自动机到正则表达式"></a>补充：从自动机到正则表达式</h1><p>可以从一个DFA或NFA得到对应的正则表达式。但是这种方式并不是总是简单的，他只是提供了一个模糊的思路，当一个DFA很复杂的时候，还是需要有聪明才智才行。<br>这里只是简单的给出这个方法，具体可查看<a href="http://note.youdao.com/noteshare?id=9fa52c6fcb1a6637fbdb36f669852abe&amp;sub=9A6AEF1D34C044E68D8BD1AD2057996E" target="_blank" rel="external">这个文件</a>。</p>
<p>为了使讨论更加简单，我们强制一个DFA/NFA应该有下列特性：</p>
<ol>
<li>初态可以到达任意其他状态，没有状态可以通过状态迁移到达初态</li>
<li>只有一个终态，终态不能通过状态迁移到达非终态</li>
<li>初态不能是终态</li>
<li>除了初态与终态，其他状态彼此相连</li>
</ol>
<p>这四个条件看起来很可怕，其实当我们引入了$\varnothing$并根据情况添加初态终态之后，很容易可以把一个DFA/NFA转为一个符合要求的有限自动机。</p>
<p>以一个例子来说明：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/17062978.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/80510309.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/99180281.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/86068172.jpg" alt=""></p>
<p>为了不让自己沾沾自喜，必须指出上面给出的例子很简单，看下面这个：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/70925658.jpg" alt=""></p>
<p>由于生成initstate的一个要求是，不能有进入initstate的箭头，好，像上面一样加一个init，加一个Ac，随即，在删除A的时候就会发现问题。这尼玛转来转去的究竟怎么写边上的正则表达式啊？！</p>
<h1 id="能不能与好不好"><a href="#能不能与好不好" class="headerlink" title="能不能与好不好"></a>能不能与好不好</h1><p>在龙书的第九章。</p>
<ol>
<li><p>流程可否更加简洁？ 正则 -&gt; DFA：本质上还是做子集构造法-吧正则的某些位置对应NFA里面状态，位置集对应NFA的状态集</p>
</li>
<li><p>优化结果？ 最小DFA</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
<div>
  
</div>

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/06/OS-内存管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YaYi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Be With Me">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/06/OS-内存管理/" itemprop="url">OS:内存管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-06T14:13:37+08:00">
                2017-11-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
<div>
  
</div>

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/06/进程与线程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YaYi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Be With Me">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/06/进程与线程/" itemprop="url">进程与线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-06T14:13:37+08:00">
                2017-11-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><p>进程模型的进化：</p>
<ol>
<li>第一代：relay , vacuum tubes and plugboards。没有程序与进程的概念</li>
<li>第二代：批处理系统：一个程序完成所有工作。</li>
<li>带三代：mutiprogramming and timesharing。CPU可以切换运行。</li>
<li>第四代：现代OS：进程模型更加成熟，进程调度与相互交流更加成熟，内存保护与管理更加成熟。</li>
</ol>
<p><strong>进程</strong>：计算机上所有可以运行的软件，通常也包括操作系统，被组织成若干顺序进程，简称进程。它包括输入输出程序与状态。</p>
<p>需要区分进程与程序。</p>
<p>进程创建：系统初始化、运行进程的创建进程系统调用被执行、用户请求、批处理作业初始化。</p>
<p>进程终止：正常退出、出错退出（自愿）、严重错误、被杀死（非自愿）</p>
<p>在unix中，每个进程有自己的父进程，有着明显的层次结构，但是在Windows中，虽然也有“句柄”来标识父进程，拥有句柄即可控制及对应的子进程，但是这个“句柄”可以被转让，就不存在明显的层次关系了。</p>
<h2 id="为什么要并发（Cocurrency）？"><a href="#为什么要并发（Cocurrency）？" class="headerlink" title="为什么要并发（Cocurrency）？"></a>为什么要并发（Cocurrency）？</h2><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><p>进程的基本状态有<strong>运行态（Running）</strong>、<strong>就绪态（Ready）</strong>、<strong>阻塞态（Blocked）</strong>。<br>其他运行态还有<strong>创建（New）</strong>、<strong>挂起（Suspended）</strong>、<strong>退出（Exit）</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">状态</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">运行</td>
<td style="text-align:center">目前获得了CPU使用权</td>
</tr>
<tr>
<td style="text-align:center">准备</td>
<td style="text-align:center">可运行，但由于CPU被其他占用而暂时停止</td>
</tr>
<tr>
<td style="text-align:center">阻塞</td>
<td style="text-align:center">除非某种外部事件发生，否则不可运行</td>
</tr>
<tr>
<td style="text-align:center">–</td>
<td style="text-align:center">–</td>
</tr>
<tr>
<td style="text-align:center">创建</td>
<td style="text-align:center">进程的数据结构已经准备好，但是running image还没准备好</td>
</tr>
<tr>
<td style="text-align:center">退出</td>
<td style="text-align:center">进程已经完成了自己的工作，但是数据结构还没有删除</td>
</tr>
<tr>
<td style="text-align:center">挂起</td>
<td style="text-align:center">running image被交换到了硬盘</td>
</tr>
</tbody>
</table>
<blockquote>
<p>阻塞是由于他自己的原因需要等待输入输出等的操作，逻辑上不能继续运行；<br>而准备是系统把他调度下来了，即使它本身还可以继续运行。</p>
</blockquote>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-23/96592015.jpg" alt=""></p>
<p>观察上面的状态迁移图发现：阻塞态是不能直接进入运行态的，必须经过准备状态。同样，在准备状态的进程根本没有得到CPU资源，也不存在执行到需要外部事件的程度，因此也不可能有向阻塞的转变。</p>
<p>如果加上另外两个状态：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-23/91158063.jpg" alt=""></p>
<p>对于挂起状态：<br>有时需要对进程做分级处理，引入优先级会使某进程等待时间过长而被换至外存，这被称为进程挂起，目的是：提高处理机效率：就绪进程表为空时，要提交新进程，以提高处理机效率；为运行进程提供足够内存：资源紧张时，暂停某些进程，如CPU繁忙（或实时任务执行）时内存会比较紧张；便于调试：在调试时，挂起被调试进程对其地址空间进行读写。</p>
<p>双挂起：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-23/56244337.jpg" alt=""></p>
<p>在这个图中，挂起状态下对应进程的数据都在外存中，而其他状态下对应的数据应该在内存中。从进程一旦被调入外存，必须在所有都准备好之后才可能被从外存调入。等待外部事件发生的进程在外存中等待完之后才可能有机会进入就绪状态准备运行。</p>
<p>相对于内存，外存的速度很慢，什么导致了进程数据被移到外存？一是就绪进程需要更多的内存资源，只能把那些现在还不可能就绪运行的进程移出去，这是进入阻塞挂起状态，二是更高优先级的阻塞（阻塞挂起）进程终于等到了自己的外部事件，要求先运行，所以较低优先级的进程就被移入了外存，这是进入就绪挂起状态。对抢先式分时系统，当有高优先级等待挂起进程因事件出现而进入就绪挂起（运行-&gt;就绪挂起）</p>
<p>什么时候把外存的数据转移到内存呢？一是没有就绪进程或挂起就绪进程优先级高于就绪进程，这时进入就绪状态；二是一个进程释放足够内存，并有高优先级等待挂起进程，这是进入阻塞状态。</p>
<p>在不同的OS中，进程状态差异较大！！</p>
<h3 id="Linux中的进程状态"><a href="#Linux中的进程状态" class="headerlink" title="Linux中的进程状态"></a>Linux中的进程状态</h3><p>windows中的进程状态（XP）与上述双挂起状态迁移类似，下面讨论Linux中的进程状态。</p>
<table>
<thead>
<tr>
<th style="text-align:center">状态</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">TASK_RUNNING</td>
<td style="text-align:center">进程正占用CPU或是等待被执行</td>
</tr>
<tr>
<td style="text-align:center">TASK_INTERRUPTIBLE</td>
<td style="text-align:center">进程被阻塞，直到外部事件发生。发起中断系统资源释放或某种信号都能唤醒进程为RUNNING</td>
</tr>
<tr>
<td style="text-align:center">TASK_UNITERRUPTIBLE</td>
<td style="text-align:center">除了传递一个信号给睡眠进程保持其状态不变</td>
</tr>
<tr>
<td style="text-align:center">TASK_STOPPED</td>
<td style="text-align:center">进程停止运行，在接收到SIGSTOP、SIGTSTP、SIGTTIN、SIGTTOU后</td>
</tr>
<tr>
<td style="text-align:center">TASK_TRACED</td>
</tr>
</tbody>
</table>
<blockquote>
<p>所谓running image</p>
</blockquote>
<h1 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
<div>
  
</div>

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/05/JUnit之一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YaYi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Be With Me">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/05/JUnit之一/" itemprop="url">JUnit之一</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-05T15:27:08+08:00">
                2017-11-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
                  . 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/实验室/" itemprop="url" rel="index">
                    <span itemprop="name">实验室</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://blog.csdn.net/ai92/article/details/302844" target="_blank" rel="external">这是一个简单的JUnit入门介绍</a>。</p>
<p>junit是一个测试框架，把一个java工程按照JUnit运行的时候会启动这些检测，但是这并不影响这个项目作为一个JAVA程序的本质。这个程序仍然可以以Java Application来运行。</p>
<h2 id="在eclipse中使用Junit4进行单元测试"><a href="#在eclipse中使用Junit4进行单元测试" class="headerlink" title="在eclipse中使用Junit4进行单元测试"></a>在eclipse中使用Junit4进行单元测试</h2><p>安装eclipse的时候，应该已经有了junit的jar包，如果没有，可以自己去<strong>maven仓库</strong>搜索下载。</p>
<p><a href="http://tech.sina.com.cn/s/2010-01-18/14081218926.shtml" target="_blank" rel="external">在eclipse中使用Junit4进行单元测试</a></p>
<p>为了方便，我会把上述的方法自己实践并写在下面：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/17569873.jpg" alt=""></p>
<p>不要直接finish。点击next，你将可以选择对哪些方法进行测试，eclipse就会自动帮你命名（which is very essential）</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/14409795.jpg" alt=""><br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/45619270.jpg" alt=""></p>
<p>看！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
<div>
  
</div>

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/04/计算机网络/计算机网络番外3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YaYi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Be With Me">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/04/计算机网络/计算机网络番外3/" itemprop="url">计算机网络番外三</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-04T21:12:40+08:00">
                2017-11-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
                  . 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/大三的课/" itemprop="url" rel="index">
                    <span itemprop="name">大三的课</span>
                  </a>
                </span>

                
                
                  . 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/大三的课/作业/" itemprop="url" rel="index">
                    <span itemprop="name">作业</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第二次书面作业"><a href="#第二次书面作业" class="headerlink" title="第二次书面作业"></a>第二次书面作业</h1><ol>
<li>在目前的报文交换网络中（如Internet），主要采用存贮转发式交换。源主机通常将应用层较长的消息（例如，图像、视频等）分成小的报文段在网络中进行传输，接收端再将报文段组合成原始的消息，提交给应用层。下面我们给出了消息直接传输（不分报文段）和分成报文段传输的示意图，假设消息长度为8×106 bits，每条链路的传输速率为2Mbps，忽略传播延时、排队延时和处理时间。请回答下列问题：</li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-22/59555628.jpg" alt=""></p>
<p>1)    如图a所示，如果消息不进行分段直接进行传输，每台交换设备均采取存储转发式交换，请计算消息从源主机发出到目的主机完全接收所需的时间；</p>
<p>答：$t=3*8Mb/2Mbps=12s$</p>
<p>2)    如图b所示，如果消息被分成800个报文段进行传输（忽略各层的封装），每个报文段长10000 bits，请计算消息从源主机发出到目的主机完全接收所需的时间；</p>
<p>答：$t=3*10000/2M+799*10000/2M=802*0.01M/2M=4.01s$</p>
<p>3)    比较消息交换和报文交换的优缺点，除了传输延时方面的考虑，采用报文交换还有哪些其他方面的考虑？ </p>
<p>答：<br>消息交换省去了对分片数据进行处理合并的时间、减少了首部的数据传输，但是时延长，可能会长时间占用路由器的大量缓存空间。<br>报文交换大大减少了时延，同时由于数据的减少检错也变得更加容易，错误发生率减小，可靠性提升，但是需要额外传送首部数据，并且需要注意报文的顺序合并，还会带来排队时延。<br>采用报文交换除了对时延方面的考虑，还有对发送优先级以及数据可靠性的考虑。另外，过长的消息堵塞路由器可能导致其他消息不能及时送往目的地而带来一系列问题。</p>
<ol>
<li>发送者A和接收者B之间使用TCP协议进行通信（A发送数据，B回送ACK）。假设TCP连接建立之后A立即开始发送数据（第一个数据段随三次握手中的最后一个ACK一同发送，初始序列号为1）。链路带宽（传输速率）为100 Mbps，往返延迟RTT为10ms，MSS为1000字节，最初的拥塞窗口设成1个MSS，假设接收端有足够大的缓存空间，拥塞控制的初始阈值设为64。试回答下列问题：<br>1)    假设A缓冲区中有7000字节数据要向B发送，发送的每个数据段均包含1000字节数据，请画出A、B之间的交互过程，并计算所需的时间（从发起连接开始计算，要求给出计算过程）。</li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-22/23395607.jpg" alt=""></p>
<p>从图中可以看出：一共经过了4次RTT以及3段将数据报送出的时间，加上TCP/IP首部字节数认为是40，因此：<br>时间：$t=4*RTT+3*((40+1000)*8/100M)=40+0.2496ms=40.2496ms$</p>
<p>2)    快速重传机制是对TCP性能的优化，考虑第一问中的传输情况，如果传输过程中有数据段丢失，那么第几个数据段的丢失有可能触发A的快速重传？解释原因。</p>
<p>答：承载数据的第四（seq=3002）个：如果第一个数据包发生丢失，B不会发送ACK，将会因此超时引发慢启动；如果第二个丢失，只会发送一个冗余ACK，然后超时进入慢启动。如果第三个丢失，接下来可以连续发送2个报文段，由于第三个包无法被确认，只能回收两个冗余ACK。如果第四个丢失，5、6、7都正确到达，将会引起3个冗余ACK，会引发快速重传。五、六、七丢失都不能引发快速重传了。</p>
<p>3)    假设发送端发送一系列数据段（1、2、3……n），但A一直未收到任何确认（ACK），正常情况下，第一个数据段的重传定时器会首先超时，A将TCP的拥塞窗口设置成1个MSS，并重传第一个数据段。如果我们现在修改TCP协议，在上述情况下不重传第一个数据段，而改为发送第n+1个数据段，请你分析在什么情况下这种做法有利，在什么情况下不利。</p>
<p>答：如果接收方其实全部收到了包，只是发送方的定时器时间设置太短或是突然拥挤的网络导致包传输减缓，这时发送第n+1个数据段是有利的。因为这时前面数据段的ACK会相继到达，n+1包是最终一定会发送出去的包，因此所有工作都不是无用功；如果重传1包，那么在1包原本的ACK到达之后，这个被重传的包就是冗余包，将会被丢弃还会浪费资源。<br>在其他情况下，比如有部分包甚至全部包没有收到，这种机制似乎并不能有效地解决问题：比如有一个包x（0&lt;=x&lt;=n）未收到，这时无论重传多少次n+1包，最终可能收到的都是ACK=x，陷入无尽的循环。</p>
<h1 id="第三次书面作业"><a href="#第三次书面作业" class="headerlink" title="第三次书面作业"></a>第三次书面作业</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
<div>
  
</div>

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/04/计算机网络应用层番外二/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YaYi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Be With Me">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/04/计算机网络应用层番外二/" itemprop="url">计算机网络应用层之番外二</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-04T21:12:40+08:00">
                2017-11-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
                  . 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/大三的课/" itemprop="url" rel="index">
                    <span itemprop="name">大三的课</span>
                  </a>
                </span>

                
                
                  . 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/大三的课/作业/" itemprop="url" rel="index">
                    <span itemprop="name">作业</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>其实这里该是运输层番外….但是这是应用层作业啦。</p>
<p>多用户并发访问与可靠文件传输，不能有下载大小的限制。</p>
<p>为了用UDP实现多用户并发访问，一定是需要使用多个socket。仿照FTP的协议设计：使用一个UDP的socket在master进行监听，这个socket绑定一个确定的端口号，用户客户机连接服务器发请求使用。</p>
<p>考虑的请求比较小，可以使用一个包传送完成：</p>
<p>Server在端口号X进行监听。</p>
<p>将有一个N。<br>一个client要求连接，发送请求之后立即fork一个子进程，仍然使用这个socket，立即进入准备接收的状态。Server收到了，立即fork一个子线程，master继续监听，确保其他client的请求能被接收到。子线程新建一个UDP的socket，准备进行接收。由于UDP的不可靠，希望在传输数据的时候，Server应该首先，在fork出子线程之后立即对命令请求进行分析，告诉client一共要穿多少个包。（因为在n结束之后，client的子线程就会结束。如果不采用n结束子线程就结束，肯定需要有一个例如，里最后一个包recv之后多久end。这样应该是不太可靠的…对于server，需要有超时重传。emmmm</p>
<p>其实这样也行：</p>
<p>client子线程立即等待server传回的数据。同时启动一个定时器，如果超过了一定时间，反正也是同一个socket，就再重传，然后去等。</p>
<p>server呢，在子线程fork出之后就去分析命令，然后开始传包。每一个包有一个序列号。采用选择重传的机制进行文件信息的传输。当发送端的所有发出的包已经发送完毕并且所有的一发送包都得到回执确认之后，向接收端发送最终的发送完毕包。这个包在发送完之后，client接受到之后必须给ACK。server收到ACK之后才能关闭。</p>
<p>有状况：<br>如果client没接到信息或者信息错了，按照选择重传，不会有动作，server重传没毛病；如果client给的ACK丢了，server不能确定client已经收到，也会重传，所以client不可能在发送完ACK就关闭，而是影该等待server的回执，让server知道我已经知道我拿到完整的包了。一旦等到，立即关闭。<br>所以client这边对于最后一个包的动作是：recv-&gt;收到错报，不动，等重传/收到对的包，回复ACK同时启动一个超时重传机制，开始接收server的回执，不管接受到了什么，关闭。（因为这个时候server只要收到了client的东西就证明client肯定已经知道包已经传完了）<br>因为server最终只发送一次，如果client连着很多次超时重传都没有收到回应，很大可能已经server关闭了，为了不陷入无休止的重传，client关闭。</p>
<p>server的动作是-&gt;发送最后一个结束包-&gt;超时重传/接收到client的信息-&gt;发送一个ACK，关闭。</p>
<p>server也知道client这时server也已经关闭</p>
<h1 id="最终交付"><a href="#最终交付" class="headerlink" title="最终交付"></a>最终交付</h1><h2 id="计算机网络书面作业：网络协议设计"><a href="#计算机网络书面作业：网络协议设计" class="headerlink" title="  计算机网络书面作业：网络协议设计 "></a><center>  计算机网络书面作业：网络协议设计 </center></h2><center>yayi2456</center>

<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;本协议仿照了FTP协议以允许多客户机的并行操作，使用选择重传的方法在UDP的基础上进行一定程度的可靠性的保证与效率的保证，加入其他机制保证大文件的可靠传输。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;server端的主socket绑定一个端口号，进行对客户请求的监听。一旦监听到客户机的请求，立即fork一个子线程，在子线程中重新绑定一个socket，由这个socket与客户机进行通信。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;client端根据程序并行度可选择是否需要在子线程发出请求，这取决于不同的应用程序的动作，不做讨论。提到client的动作时，并不指定是在哪个进程。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>将该协议描述如下：</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;server监听端口A，一旦监听到client的请求，立即fork子线程。在子线程中对该请求进行分析，并决定需要发送给client的数据。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;client向server发送请求，并启动一个定时器，当超过一定时间仍未收到server传回的第一个包，client重新发送请求信息。使recvbase为0，收到第一个数据包之后，<code>recv=(recv+1)%(2*N)</code>，该定时器关闭。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>注</strong>：在server收到请求之后，并没有立即发送ACK通知client自己已经收到了请求。原因在于server最终一定会发送数据给client，只需要把第一个数据包作为server收到的确认信息即可，同时也减少了可靠性保证所花费的额外的时间。但是由于server对准备发送的数据需要做一定的处理，这个时延可能会稍长。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;server开始向client发送包。采用选择重传机制，server为每一个包附上一个<strong>序号</strong>，同时利用UDP头本身具有的checksum字段进行一定程度的检错判断。server每次最多传送N个报文段，协议中具有2*N个序号。初始时，发送缓冲区中的sendbase是0，server每传送一个报文段就会启动一个对应于该报文段的定时器，当某个报文段的定时器超时之后，server对该报文段进行重传；当server收到了某个序号的报文段的ACK之后，将该序号置为“已确认”，如果该序号是sendbase，那么将<code>sendbase=(sendbase+1)%(2*N)</code>，如果sendbase是“已确认”，再将<code>sendbase=(sendbase+1)%(2*N)</code>，直到sendbase是“已发送但未确认”或是“可用”。同时，当sendbase改变时，如果包尚未发送完，则可以使用新的“可用”来发送新的报文段。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;client接受到第一个数据包之后关闭第一个定时器，并向服务器发送对第一个数据包对应的序号的ACK，随后开始接收其他数据包，每接收到一个检验和没有错的数据包，返回一个对应该数据包序号的ACK包。无论是不是server端没有接收到上一个对应该序号的ACK，返回一个ACK，对于最大为2*N的空间来说，是没有问题的。对于在[recvbase,recvbase+N-1]空间中的序号对应的包加以解析送给应用层使用或者是缓存之后将对应的序号标为“接收已确认”，而另外的序号对应的数据包只返回ACK，对数据包直接丢弃。每次接收到一个被“接收已确认”的数据包，如果该数据包的序号是recvbase，<code>recv=(recv+1)%(2*N)</code>，如果这时recvbase对应序号仍是“接收已确认”，<code>recv=(recv+1)%(2*N)</code>，直到recvbase对应序号是“期待但未收到”或是“可用”。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在所有的有用数据包传送完成之后，server需要告知client，有用的数据已经传送完了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;场景分析如下：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;当server的所有发出的包已经发送完毕并且所有的已发送包都得到回执ACK之后，向client发送最终的发送完毕包。这个包在发送完之后，client接收到之后必须给ACK。server收到ACK之后才能关闭，否则可能导致client不知道自己已经拿到完整的数据而陷入空转。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;如果client没接到最终包信息或者信息错了，按照选择重传，client不会有动作，server等待超时之后重传；如果client回复的ACK丢了，server不能确定client已经收到，必须重传来确认client已经知道自己可以关闭连接了，所以client不可能在发送完ACK就关闭，而是该等待server的回执，让server知道client已经知道client拿到完整的包了，否则可能会使server陷入无尽的重传。一旦等到server的回执，client立即关闭。若许久都未等到回执，关闭。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;下面对最后的动作进行描述：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;server的动作是：发送最后一个结束包，启动定时器，若超时则进行重传；直到接收到client的信息之后，关闭定时器，server发送一个ACK，立即关闭。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;client最终的动作是：等待接收数据，如果收到错误的包，等重传；如果收到对的包，回复ACK同时启动一个定时器，启动超时重传机制，并开始接收server的回执，不管接受到了什么，关闭。若超时一定次数之后仍未接收到server的回执，因为server最终只发送一次，如果client连着很多次超时重传都没有收到回应，很大可能已经server关闭了，为了不陷入无休止的重传，client关闭。</p>
<p>从宏观的角度来看，客户机与服务器的交互是：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-5/15535425.jpg" alt=""></p>
<p><strong>扩展FSM：</strong></p>
<p><strong>server：</strong></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-5/73814791.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-5/41957911.jpg" alt=""></p>
<p><strong>client：</strong></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-5/90929804.jpg" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
<div>
  
</div>

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/03/覆千秋1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YaYi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Be With Me">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/03/覆千秋1/" itemprop="url">覆千秋1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-03T21:46:15+08:00">
                2017-11-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/我的故事/" itemprop="url" rel="index">
                    <span itemprop="name">我的故事</span>
                  </a>
                </span>

                
                
                  . 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/我的故事/枯骨流沙/" itemprop="url" rel="index">
                    <span itemprop="name">枯骨流沙</span>
                  </a>
                </span>

                
                
                  . 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/我的故事/枯骨流沙/覆千秋/" itemprop="url" rel="index">
                    <span itemprop="name">覆千秋</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="夜色凉"><a href="#夜色凉" class="headerlink" title="夜色凉"></a>夜色凉</h1><p>将军府的海棠开了。</p>
<p>粉粉嫩嫩，一簇一簇的，细风吹来，花朵轻轻落在地上，把这个小园衬出几分诗意。</p>
<p>只是府上光景却不如这海棠繁盛。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/11/03/覆千秋1/#more" rel="contents">
              Weiterlesen &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
<div>
  
</div>

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/02/计算机网络/计算机网络网络层/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YaYi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Be With Me">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/02/计算机网络/计算机网络网络层/" itemprop="url">计算机网络网络层</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-02T22:12:40+08:00">
                2017-11-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
                  . 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/大三的课/" itemprop="url" rel="index">
                    <span itemprop="name">大三的课</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p># </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
<div>
  
</div>

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/02/计算机网络/计算机网络运输层/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YaYi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Be With Me">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/02/计算机网络/计算机网络运输层/" itemprop="url">计算机网络运输层</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-02T22:12:40+08:00">
                2017-11-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
                  . 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/大三的课/" itemprop="url" rel="index">
                    <span itemprop="name">大三的课</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>这些东西是很简单，可是想来想去还是决定记录一下，以免以后遇到像C++语法不知道一样的尴尬。</p>
</blockquote>
<h1 id="概述与运输层服务"><a href="#概述与运输层服务" class="headerlink" title="概述与运输层服务"></a>概述与运输层服务</h1><p>运输层的协议提供的是<strong>逻辑通信</strong>，并不是直接相连的。</p>
<p>现在我们聊的是<strong>对等层通信</strong>，本机的运输层发数据给其他机器的运输层。运输层协议在端系统里面，并不是在路由器里。</p>
<p>实际上，当应用程序希望能与其他设备进行通信，调用运输层，给运输层一堆信息。运输层可能会把这些信息分段，然后加上头部信息成为<strong>报文段</strong>。报文段交给网络层，网络层再封装成<strong>数据报</strong>再向目的地发送。到了目的地之后做一个相反的动作，送给应用层使用。需要区分清楚的是，制定目的地、决定报文段怎么产生、决定报文段如何合并都是运输层的工作，网络层相当于送信的邮差，只负责传输。但是话又说回来了，网络层更加底层，网络层提供了怎样的服务、有多大的带宽都限制了运输层的服务。</p>
<p>现在<strong>因特网</strong>的运输层主要有两个协议：UDP、TCP。UDP是不可靠的、多目的地的、无序的传输；TCP是面向连接的可靠的传输。具体特性将在后面讲到。</p>
<p>因特网的网络层协议是IP协议（网际协议）。IP非常不可靠，他是<strong>尽力而为交付服务</strong>，一不确保报文段的交付，二不保证报文段交付的按序，三不保证报文段交付的完整性，被称为<strong>不可靠服务</strong>。</p>
<p>TCP与UDP的基本职责是将两个端系统之间的IP交付服务扩展为运行在两个端系统之上的两个进程之间的信息交付服务。将主机之间的交付扩展为进程之间的交付就是<strong>运输层的多路复用与多路分解</strong>。</p>
<h1 id="运输层的多路复用与多路分解"><a href="#运输层的多路复用与多路分解" class="headerlink" title="运输层的多路复用与多路分解"></a>运输层的多路复用与多路分解</h1><p>多路复用与多路分解服务是所有计算机网络都需要的。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/43018259.jpg" alt="复用与分解机制"></p>
<p>我们知道，实现运输层的服务需要借助于socket，一个进程可以对应一个或几个socket（？）。在send端，运输层在报文段中加了首部信息之后，把各进程产生的数据无差别的交给网络层；在rev端，运输层从网络层那里拿出数据，解析报文段的首部信息从而==定位socket==，把<strong>分解后的</strong>报文段信息给对应的socket。</p>
<p>为了实现这种服务，在首部信息里面一定封装有<strong>端口号</strong>。<br>端口号是一个16bit的数，在0-65535之间，其中0-1023的端口号是周知端口号，他们被保留给周知应用层协议来使用。一般来说，服务器端都是一个固定的端口号，而客户端则是随机分配。<br>关于端口号的更多信息，可以访问<a href="http://www.iana.org" target="_blank" rel="external">RFC 3232</a>获得。</p>
<h2 id="1-无连接的"><a href="#1-无连接的" class="headerlink" title="1. 无连接的"></a>1. 无连接的</h2><p>首先了解UDP的套接字标志方法：UDP的socket以一个二元组(dstaddr,dstport)来标识，与源信息无关。也就是说，虽与一个机器无论是从什么地方发送过来的数据，只要给的是同一个port，都将被同一个socket处理。这样，容易理解，在UDP中，每一个port会对应一个自己的缓冲区。</p>
<p>关于这个缓冲区，<del>UDP不可靠也会体现在这里</del>，在发送UDP包的时候不能过大，也是出于对缓冲区大小的考虑。如果新到来的包太大了、不能塞进缓冲区了，这个包会被直接抛弃。app层不会知道，只有通过发送端的超时重传机制对包进行重传。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/79842537.jpg" alt="UDP复用与分解机制"></p>
<h2 id="2-面向连接的"><a href="#2-面向连接的" class="headerlink" title="2. 面向连接的"></a>2. 面向连接的</h2><p>TCP的套接字标志方法与UDP不同，TCO使用(srcaddr,srcport,dstaddr,dstport)，这样，只有四个值都相同才会被定向到同一个socket，放到同一个缓冲区。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/6848958.jpg" alt="TCP复用与分解机制"></p>
<blockquote>
<p>这里只是简单一提：关于安全性的问题。攻击者可以利用在某个端口监听的有缺陷的应用程序攻陷目的主机。我不了解安全，这里只是复述了《自顶向下方法》中的解释。</p>
<p>使用<a href="http://nmap.org" target="_blank" rel="external">nmap</a>既可以扫描到<strong>因特网</strong>中任一台主机，顺序的扫描主机的各个端口，对TCP/UDP，寻找能接收TCP连接/能对UDP报文段进行处理的端口号，并返回打开的、关闭的、不可达的端口号列表。</p>
</blockquote>
<h2 id="3-Web-Server与TCP"><a href="#3-Web-Server与TCP" class="headerlink" title="3. Web Server与TCP"></a>3. Web Server与TCP</h2><p>其实没什么新东西，列举：</p>
<ol>
<li><p>连接套接字与进程之间并非一一对应的关系。先进的高性能Web server只有一个进程，但是为每一个连接的<strong>新客户</strong>（不是客户机喔）创建一个新的线程。</p>
</li>
<li><p>非持续HTTP会严重影响web server的性能。（在应用层中涉及），有些OS技巧可以减轻这个问题的影响。（参见[Nielsen 1997,Nahum 2002]）</p>
</li>
</ol>
<p>他的复用与分解是这样的：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/41975538.jpg" alt="Web"></p>
<h1 id="UDP概述"><a href="#UDP概述" class="headerlink" title="UDP概述"></a>UDP概述</h1><p>UDP很弱，除了上一节提到的复用分解机制以及少量的差错检验之外，基本没有功能了，如果程序员选择了UDP，那基本上就是在与IP打交道了。</p>
<blockquote>
<p>以一个DNS查询为例：应用层给出了一个查询报文交给运输层，UDP加了首部段，交给网络层，网络层将他封装进一个IP数据报，发送给一个名字服务器。DNS如果没有收到对方的回应，要么向另一个服务器发送请求，要么告知调用它的应用程序没有响应。</p>
</blockquote>
<h2 id="1-UDP特点"><a href="#1-UDP特点" class="headerlink" title="1. UDP特点"></a>1. UDP特点</h2><ul>
<li><p>无连接：</p>
<ol>
<li>两个UDP之间没有握手；</li>
<li>UDP报文段彼此独立</li>
</ol>
</li>
<li><p>不可靠：</p>
<ol>
<li>没有确认接收；</li>
<li>没有重传；</li>
<li>没有检查包丢失与包失序</li>
<li>检验和只覆盖部分信息</li>
<li>没有拥塞控制</li>
</ol>
</li>
</ul>
<p>UDP很弱，为什么不使用更加可靠的TCP呢？</p>
<ol>
<li><p>关于何时发送什么样的数据的控制更为精细。UDP是只要应用层交付，UDP就立即给网络层，而TCP有一个拥塞控制机制，可能会遏制发送方，是数据传输变得缓慢。</p>
</li>
<li><p>无需建立连接，减少时延。</p>
</li>
<li><p>无连接状态，不需要维护连接状态。连接状态包括接收和发送数据缓存、拥塞控制参数、序号以及确认号的参数等。某些应用程序运行在UDP之上可以支持更多的活跃用户。</p>
</li>
<li><p>分组首部开销小</p>
</li>
</ol>
<p>UDP的这些特点使得：</p>
<ol>
<li>DNS简单查询；</li>
<li>流媒体应用；</li>
<li>P2P应用</li>
<li>网络管理应用：通产工作在高压状态之下；</li>
<li>路由转换协议</li>
</ol>
<p>等将有更佳的适用度。</p>
<blockquote>
<p>现今，由于出于安全考虑，某些机构阻塞UDP流量，而且当丢包率低时，TCP将更多的用于流媒体应用。</p>
<p>然而，由于UDP没有拥塞控制机制，当网络繁忙时，路由器会有大量的分组溢出，几乎没有UDP分组能够成功通过路由器到达目的地。而且，具有拥塞控制机制的TCP发送方会减慢自己的速率。UDP没有拥塞控制机制不仅造成了UDP会话之间的高丢包率，也挤垮了TCP会话。很多研究人员已经提出了新的机制，使所有数据源执行自适应的拥塞控制。</p>
<p>希望使用UDP实现可靠传输的话需要在应用层协议上加上可靠性保证。这种方法既可以保证可靠传输，又可以拒绝拥塞控制的影响。</p>
</blockquote>
<p>表1：流行的因特网应用及其下协议</p>
<table>
<thead>
<tr>
<th>应用</th>
<th>应用层协议</th>
<th>下层运输协议</th>
</tr>
</thead>
<tbody>
<tr>
<td>电子邮件</td>
<td>SMTP</td>
<td>TCP</td>
</tr>
<tr>
<td>远程终端访问</td>
<td>Talnet</td>
<td>TCP</td>
</tr>
<tr>
<td>Web</td>
<td>HTTP</td>
<td>TCP</td>
</tr>
<tr>
<td>文件传输</td>
<td>FTP</td>
<td>TCP</td>
</tr>
<tr>
<td>远程文件服务器</td>
<td>NFS</td>
<td>通常UDP</td>
</tr>
<tr>
<td>流式多媒体</td>
<td>通常专用</td>
<td>UDP或TCP</td>
</tr>
<tr>
<td>因特网电话</td>
<td>通常专用</td>
<td>UDP或TCP</td>
</tr>
<tr>
<td>网络管理</td>
<td>SNMP</td>
<td>通常UDP</td>
</tr>
<tr>
<td>路由选择协议</td>
<td>RIP</td>
<td>通常UDP</td>
</tr>
<tr>
<td>名字转换</td>
<td>DNS</td>
<td>通常UDP</td>
</tr>
</tbody>
</table>
<h2 id="2-UDP报文"><a href="#2-UDP报文" class="headerlink" title="2. UDP报文"></a>2. UDP报文</h2><p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/9685377.jpg" alt="UDP头信息"></p>
<p>长度：指明了包括首部信息在内的UDP报文段长度（单位：字节：Byte）；</p>
<p>下面重点说<strong>检验和</strong>：</p>
<p>在计组里面就学了几个检错方法，对于一个检错机制：数据=冗余位  实际数据。决定检错能力的是冗余位数与算法。对于UDP，他提供的是一个很简单的检错机制，而且只能检错，不能修改错误。</p>
<h3 id="Persudo-Header"><a href="#Persudo-Header" class="headerlink" title="Persudo Header"></a>Persudo Header</h3><p>persudo header结构是这样的：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/92376358.jpg" alt=""></p>
<p>在发送端，首先会将报文段中的checksum清零，然后把报文段与persudo header的数据当作16bit的很多数据，对他们进行求和运算，将得出的16bit结果求反给checksum字段。</p>
<p>在接收端，产生新的伪首部，然后只需要将这些数据全部求和，最终如果是16个1，说明<strong>可能</strong>是没错的，但是也可能<strong>发生的错误已经超出了检错能力</strong>，如果不是16个1，那说明一定是错了。</p>
<p>checksum有什么用呢？对于明确错误的信息，UDP会要么丢弃；要么把数据给应用层，但是给应用层警告说数据是错的。</p>
<blockquote>
<p>其实伪首部破坏了分层结构，在运输层产生了网络层的信息。</p>
<p>UDP校验和覆盖的范围超出了UDP数据报本身，使用伪首部的目的是检验UDP数据报是否真正到达目的地，正确的目的地包括了特定的主机和该主机上特定的端口</p>
<p>checksum机制在ipv4下是可选的，但是在ipv6下是必须的。</p>
</blockquote>
<p>在checksum中看到了<strong>端对端原则</strong>。端对端原则是一个被受赞扬的原则，该原则表述为某种功能必须基于端对端实现：”与在较高级别提供这些功能的代价相比，在较低级别上设置的功能可能是冗余或几乎没有价值的。“<br>在这里，由于不能保证从网络到物理到链路都有有效的检错机制，甚至在某些路由器的内存中也可能引入比特差错，实现端对端的错误检测机制是有必要的。</p>
<h1 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h1><p>在这一节里，将所有的底层数据传输视为不可靠的，可能会发生数据的丢失、差错、失序等。</p>
<p>这里讨论的是普遍的计算机网络使用的理论，将以<strong>分组</strong>代替<strong>报文段</strong>被使用。同时，只考虑<strong>单向数据传输</strong>，其实<strong>双向数据传输</strong>并不会更难。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/10707246.jpg" alt=""></p>
<h2 id="构造可靠数据传输协议"><a href="#构造可靠数据传输协议" class="headerlink" title="构造可靠数据传输协议"></a>构造可靠数据传输协议</h2><h3 id="rdt1-0：信道完全可靠"><a href="#rdt1-0：信道完全可靠" class="headerlink" title="rdt1.0：信道完全可靠"></a>rdt1.0：信道完全可靠</h3><p>假如信道完全可靠，UDP完全可靠。发送方只要接收到rdt_send就做处理并调用udp_send，接收方只要接收到rdt_rcv就处理。有限状态机（FSM）图如下：</p>
<p>发送端：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/67644025.jpg" alt=""></p>
<p>接收端：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/29594625.jpg" alt=""></p>
<h3 id="rdt2-0：信道具有比特差错"><a href="#rdt2-0：信道具有比特差错" class="headerlink" title="rdt2.0：信道具有比特差错"></a>rdt2.0：信道具有比特差错</h3><p><strong>自动重传请求</strong>（Automatic Repeat reQuest）：在接收方确认接收到正确的报文之后给出<strong>肯定确认</strong>，接受到不正确的报文之后给出<strong>否定确认</strong>。</p>
<p>实际上，这种机制需要其他的支持：</p>
<ol>
<li>差错检测</li>
<li>接收方反馈：如果正确，返回ACK，不正确返回NAK。</li>
<li>重传：发送方在接收到NAK时重传。</li>
</ol>
<p>FSM：</p>
<p>发送方：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/62528979.jpg" alt=""></p>
<p>接收方：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/18789362.jpg" alt=""></p>
<p>但是，如果ACK或者NCK的包错误了怎么办呢？<br>一般有三种解决方法：</p>
<ol>
<li>发送请求，询问上一个差错包的内容。这样很容易陷入询问的死循环。</li>
<li>增加足够的检错纠错能力。导致冗余数据过多。</li>
<li>直接重传。可能会引入冗余分组，使得接收方不知道这个包是新包还是重传包。</li>
</ol>
<p>对于第三种方法，可以引入<strong>序列号</strong>的概念来解决问题。对于我们现在讨论的停等协议，只需要两个序号即1bit即可。</p>
<p>这个版本是<strong>rdt2.1</strong>，新的FSM是这样的：</p>
<p>发送方：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/35627137.jpg" alt=""></p>
<p>接收方：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/21016547.jpg" alt=""></p>
<p>其实，如果不使用NAK，而是对上次的接收再发送一个ACK，也能起到同样的效果，这样，有了<strong>rdt2.2</strong>版本：</p>
<p>发送方：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/79622017.jpg" alt=""></p>
<p>接收方：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/43136886.jpg" alt=""></p>
<h3 id="比特交替协议——rdt3-0：信道可能丢包、产生比特差错"><a href="#比特交替协议——rdt3-0：信道可能丢包、产生比特差错" class="headerlink" title="比特交替协议——rdt3.0：信道可能丢包、产生比特差错"></a>比特交替协议——rdt3.0：信道可能丢包、产生比特差错</h3><p>如果产生了丢包，接收端是不会知道的，只能在发送端处理这个问题。一个是发送端主动发送的数据丢失，和接收端没有关系，一个是接收端已经收到了包，但是发送的确认信息丢失。</p>
<p>发送方需要<strong>重传</strong>，应该做到：</p>
<ol>
<li>每次发送数据之后启动一个定时器</li>
<li>响应定时器中断</li>
<li>停止定时器</li>
</ol>
<p>在重传中，延时时间的设置是很重要的。过长的延迟时间将影响应用层的体验，果断的延迟时间将会引入<strong>冗余数据分组</strong>。rdt2.2已经有能力处理冗余数据分组：当在等待1的时候又传来了0，接收端会直接丢弃这些数据。而对于停等协议，不会有在等1的时候正好发送了1的冗余包的情况。</p>
<p>发送方：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/29153183.jpg" alt=""></p>
<h2 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h2><p>rdt3.0对于错误处理已经比较完善了，但是他的问题在于他是一个停等协议。停等协议对链路的利用率低到令人发指！</p>
<blockquote>
<p>对于一个速度是1Gbps的链路，发送一个大小1000Byte的包：</p>
<p>进入所需时间：$$t=\frac{L}{R}=\frac{8000bit/pkt}{10^9bit/s}=8us/pkt$$</p>
<p>假设传输所需时间是15ms，那么信道的利用率是：</p>
<p>$$U_sender=\frac{\frac{L}{R}}{RTT+\frac{L}{R}}=\frac{0.008}{30.008}=0.00027$$</p>
</blockquote>
<p>为了提高传输效率，停等协议需要被摒弃。现在使用的技术被称为<strong>流水线</strong>。<br>使用流水线技术，1个bit的序号是不够用的，在后面我们将讲到对于n个同时发出的包，需要2*n个序列号。而且，在发送端和接收端都需要有缓存机制来暂时存储：发送端需要存储已经发送但是没有确认接收的数据，接收端需要存储已经正确接收的数据。</p>
<p>这一节并没有完整的讨论流水线机制下的协议，从下一小节开始，对缓存的处理、序列号的处理进行讨论。</p>
<h2 id="回退N步：GBN"><a href="#回退N步：GBN" class="headerlink" title="回退N步：GBN"></a>回退N步：GBN</h2><p>允许发送方连续发送N个数据包，接收方按序接收数据包，失序的包会被丢弃。（这时由于没有考虑双向传输，而且接收端的机制，在接收端的结构暂且不提）</p>
<p>在发送方将会有一个缓冲区，把结构抽象成这样：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/82326531.jpg" alt=""></p>
<p>在这次传输的过程中只能使用[send_base,sendbase+N-1]之间的序号。扩展FSM如图：</p>
<p>发送端：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/56361901.jpg" alt=""></p>
<p>接收端：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/32672336.jpg" alt=""></p>
<p>在这个FSM中存在变量，初始化是需要的。<br>在发送端，当上层请求发送数据时，有一个判断：如果还可以继续发送（nextseqnum&lt; base+N），就继续发送，如果在发送这个之前所有的包都已经被确认过了，就需要开一个定时器，<strong>从这里可以看出：计时器以最左边界启动</strong>。如果不能再发送了，拒绝发送数据。这时可能有三种处理方式：将该数据返回给上层，隐含地表示已经不能再传了；缓存这些数据；使用同步机制只允许上层在窗口不满的时候才能调用rdt_send。<br>数据发送出去之后，如果按时接收到了一个ACK，比如说是ACK(i)，那么说明从base到i都已经被确认了。假如这时已经没有未确认包了，计时器停止，否则，重新为新的最左包启动一个定时器。<br>如果ACK损坏了，什么也不做。因为有定时装置，只需等待重传。这与rdt3.0的机制是相同的。<br>好了，timeout了，将现在所有的未确认全部重传，然后重启定时器。</p>
<p>在接收端，同样初始化。<br>接收端只会等待需要等待的按序的包，如果不是按序的，不予接收，并将上一个确认信息给发送方。类似于rdt2.0的处理方式。发送方收到的这个包并不会对发送方有什么影响，只是由于timer不能被停止或重启，一定时间之后便会触发重传。但是对于那些ACK丢失的包有重大意义：推动sendbase向前。<br>如果接受端收到了一个按序的、在检错能力之内没有错误的包，才对他进行处理，更新自己的期望包序号，并向发送方发出自己的确认信息。</p>
<p>这种方式的弊端在于失序数据的丢弃。</p>
<p>假如发送方一口气发送了N个包，恰巧第一个包坏了，其他都好的，由于接收端拒绝接受第一个坏的包，其他包也被丢弃了，只能重传所有的N个包。<br><del>或者，其实这N个包都好好的到了接收端，接收端返回了N个确认包。</del> emmm其实这里做的比较好，因为反回了N就代表N以及以前的都已经收到了。</p>
<p><a href="https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/go-back-n-protocol/index.html" target="_blank" rel="external">Go-Back-N动画</a></p>
<h2 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h2><p>对上一小节最后提出的回退N步的弊端，在选择重传之中得到了解决。但是应该知道，功能的增强需要结构的复杂作为代价。</p>
<p>允许失序，接收方会对一些失序的包进行缓存。这样，确认接收的机制也需要进行修改、接收方也需要拥有一个缓存区来实现。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/94806677.jpg" alt=""></p>
<p>在这种方式中，其实在上一节最后说的那点优点是不可能存在了，因为需要选择重传，必然是选择确认。而且，每个分组都必须有自己的定时器，而不能像上面一样按最左来做定时器。</p>
<p>在发送端，base只能移动到没有已发送但未确认的最右。对于上图，发送端的绿色必定对应接收端的粉色或者无色，接收端的灰色必定对应发送端的黄色，在sendbase右边不可能有对应接收端灰色的色块。</p>
<p>发送方的动作与前面类似，只是需要将确认机制修改成单独确认，接收方的动作如下：</p>
<ol>
<li>如果收到了[recvbase,recvbase+N-1]内的包，是正常的，把收到的包的对应序号ACK，如果在这之内的某个包出了问题不用管，丢掉。如果等于recvbase了，就更新recvbase。（这也使得2.是必要的）</li>
<li>收到了[recvbase-N,recvbase-1]之内的包，可能是这之内的包已经被接收端ACK了，但是没有被发送端ACK，一定需要传一个ACK包给发送端，否则会使得sendbase无法前进。</li>
<li>其他情况忽略即可。</li>
</ol>
<p>情况2.也说明了为什么需要2*N个序号：</p>
<p>尴尬的情况：究竟是重复包还是新包？<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/59249922.jpg" alt=""></p>
<blockquote>
<p>在书中提到了<strong>分组重排</strong>，我不是十分理解：</p>
<p>分组重拍的一个表现是具有确认号x的旧副本可能会在网络中出现，即使现在发送端与接收端的窗口中可能都包含x。对于分组重排，信道可被基本看成是在缓存分组，并在将来的任意时刻自然地释放这些分组。因为序列号要被重用，所以这种情况要十分小心。<br>实际采用的一个方法是直到发送方确认网络中不会在存在x分组。这通过设置一个分组在网络中的最大存活时间来限定。<br>在高速网络的TCP扩展中，一般是3min。<br>[sunshine 1978]描述了一种使用序号的方法，可以使重新排序问题完全被避免。</p>
</blockquote>
<p><a href="https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html" target="_blank" rel="external">Selective Repeat动画</a></p>
<p>这些都搞清楚了之后，<strong>TCP</strong>隆重登场~</p>
<h1 id="TCP：Transport-Control-Protocol"><a href="#TCP：Transport-Control-Protocol" class="headerlink" title="TCP：Transport Control Protocol"></a>TCP：Transport Control Protocol</h1><p>TCP是面向连接的协议，这是因为TCP在传输数据之前需要进行三次“握手”，它传输的是<strong>字节流</strong>，也就是收TCP并不管传输内容的有意义的分割，只是够了可以出发的字节数（或者不够，这是其他的机制）就会将这个报文段发出，这就要求了接受的数据必须能够按序排列好。</p>
<p>TCP的传输有以下特点：</p>
<ol>
<li>流量控制</li>
<li>拥塞控制</li>
<li>点对点</li>
<li>全双工服务</li>
<li>流水线机制</li>
</ol>
<p>TCP称得上是最复杂的协议之一，由于TCP的底层是IP协议，而上面已经提到IP协议是“尽力而为”服务，几乎没有可靠性的保证，我们只能假设底层是完全不可靠的服务，由此构建出了TCP协议。</p>
<h2 id="基本概念介绍"><a href="#基本概念介绍" class="headerlink" title="基本概念介绍"></a>基本概念介绍</h2><p>TCP连接并不是一条实际的连接或是一条虚电路，所谓的TCP连接只是存储在端到端系统中的连接状态，而路由器、链路层交换机对TCP连接完全视而不见，他们看到的只是数据报。</p>
<p><strong>全双工服务</strong>（full-dumplex service）：指的是只能AB之间互相传输，是<strong>点对点</strong>，不可能有第三者加入的情况出现。与<strong>多播</strong>有明显不同。</p>
<p><strong>客户进程</strong>：发起连接的进程；<strong>服务器进程</strong>：接收连接的进程</p>
<p><strong>三次握手</strong>：客户首先发一条特殊报文，服务器用另一个特殊报文来响应，最后客户用第三个特殊报文响应。$\color{red}{前两个报文不承载有效载荷，而最后一个可以有}$</p>
<p>当app层给运输层TCP一些数据，会被放入<strong>发送缓存</strong>里，<strong>在TCP方便的时候</strong>，就会从缓存中拿出一些数据发送。</p>
<p><strong>最大报文段长度MSS</strong>（Max Segment Size）常根据<strong>最大传输单元</strong>设置，典型值是1460<strong>字节</strong>。注意不包括各种首部，只包括应用层数据大小。TCP/IP首部一般是40bytes。</p>
<p><strong>最大传输单元MTU</strong>（Max Transmission Unit）：本地主机发送的最大链路层帧长度</p>
<p><strong>TCP报文段</strong>：TCP将这次要发送的数据用一个TCP首部进行封装。</p>
<p>就像前面说到的，MSS限制了TCP报文段的最大长度。当一个大文件被发送的时候，它将被分为许多长度为MSS的报文段发出。<br>另一方面，对于那些不需要传递大量数据的交互应用，也可以发送较小的数据段。<br>那么什么叫<strong>TCP方便的时候</strong>呢？一般来说，TCP会在三种情况下发送数据：</p>
<ol>
<li>segment full</li>
<li>超时</li>
<li>app层的push</li>
</ol>
<p><a href="https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/flow-control/index.html" target="_blank" rel="external">发送与接收动画</a></p>
<p>个人觉得（未经过资料查证，只是陈述想法），TCP连接就只是一种连接状态：recv与send都知道对方时刻准备着接受自己的数据，自己发出的数据可以说送到正确的地方，这就够了。<br>TCP连接组成包括：这对主机各自的：缓存、变量、进程连接的套接字。</p>
<h2 id="TCP报文段"><a href="#TCP报文段" class="headerlink" title="TCP报文段"></a>TCP报文段</h2><p>与UDP的报文段对比起来，TCP报文段可以说是非常复杂了。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-20/76751662.jpg" alt=""></p>
<p><strong>源端口号、目的端口号</strong>：TCP使用四元组确定一个连接，该信息用于复用分解。<br><strong>序号、确认号</strong>：像前面讨论到的保证可靠性的机制一样，TCP使用序号来确定每一个<strong>字节</strong>，注意TCP为每一个字节分配一个序列号，而不是像rdt一样为每一个包分配一个序号。这个机制将在后面提到。确认号：TCP确认已按序收到的下一个字节。<br><strong>接收窗口</strong>：用于流量控制，接收方告知发送方醉倒还能给我发送多少字节。<br><strong>首部长度</strong>：一般是20字节，比UDP多12字节（Byte）。<strong>选项</strong>可令TCP首部长度发生改变，首部长度按照32bit的字为单位。<br><strong>因特网检验和</strong>：同UDP。checksum<br><strong>紧急数据指针</strong>：指向app层标识的紧急数据的尾字节。当紧急数据存在并存在紧急数据指针的时候，TCP必须通知上层。该字段一般不用。<br><strong>选项</strong>：用于双方协商MSS的大小、时间戳等。可参考RFC 854与RFC 1323了解细节。<br><strong>URG</strong>：urgent，紧急。指示存在紧急数据。<br><strong>ACK</strong>：指示该报文段包括一个对已经被成功接收的报文段的确认。<br><strong>PSH</strong>：要求将数据立即给APP层。<br><strong>RST</strong>：在连接出现问题时重置。<br><strong>SYN</strong>：连接建立请求。<br><strong>FIN</strong>：终止连接请求。</p>
<p>需要注意的是：TCP的确认是<strong>累积确认</strong>，也就是只会确认到有序的字节流的下一个。对于那些失序的包，选择权交给了实现TCP的编程人员：</p>
<ol>
<li>立即丢弃</li>
<li>缓存：这是实际中做的。</li>
</ol>
<p>$\color{green}{关于究竟缓存是怎么实现的，需要再查阅资料。}$</p>
<p><strong>稍带确认</strong>：一方向另一方发送信息时顺带确认另一方向自己发送的信息。每一次发送的TCP报文段都必须有SEQ与ACK字段。当没有新数据到达时，SEQ就为下一个期待的字节的序号。<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-21/13245774.jpg" alt=""></p>
<h2 id="往返时间估计与超时"><a href="#往返时间估计与超时" class="headerlink" title="往返时间估计与超时"></a>往返时间估计与超时</h2><p><strong>往返时间</strong>（RTT）的估计是为了能够设置一个良好的超时重传的时间，以避免时间太短带来的不必要的重传以及时间太长而影响应用层的体验。</p>
<p><strong>SampleRTT</strong>指的是某TCP报文段从被发出到收到确认之间的时间间隔。</p>
<p>TCP在任意一个时刻，只为当前已经发送但仍未确认的一个TCP报文段计算SampleRTT，得到一个新的SampleRTT值。<br>TCP不会为重传的报文段计算RTT，它只会对第一次上传输的报文段计算，这是为什么？</p>
<p><strong>由于路由器的阻塞以及系统负载的变化，SampleRTT将会随之波动</strong>，因此采取了一种对SRTT取平均的方法，委会一个EstimatedRTT。<br>$$ERTT=(1-\alpha)*ERTT+\alpha*SRTT$$</p>
<p>$\alpha$通常取0.125，故：<br>$$ERTT=0.875*ERTT+0.125*SRTT$$</p>
<p>这种<strong>指数加权平均移动</strong>将使得之前的SRTT的权值快速减小。</p>
<p><strong>DevRTT</strong>是RTT的偏差，用于估算SRTT偏离ERTT的程度：</p>
<p>$$DRTT=(1-\beta)*DRTT+\beta* | SRTT-ERTT|$$</p>
<p>$\beta$通常取值0.25，故：</p>
<p>$$DRTT=0.75*DRTT+0.25*|SRTT-ERTT|$$</p>
<p>$$\color{red}{千万不要忘记给公式里面的markdown符号加转义谢谢}$$</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-21/72463943.jpg" alt=""></p>
<p>最终的超时时延应该设置为：$$TimeoutInterval=ERTT+4*DRTT$$</p>
<p>推荐的初始TI是1s。</p>
<blockquote>
<p>快速重传：当发送方连续三次收到对同一个字节的确认消息，默认为是对下一个字节的NAK，将会忽略定时器，立即对下一个报文段进行重传。<br>对于有问题的报文段，TCP并不管是丢失、数据错误、ACK损坏，都以重传报文段来解决问题。<br>TCP使用流水线，可以显著的增加吞吐量。<br>一个发送方可以具有的未被确认的报文段数量由流量控制与拥塞控制机制决定。</p>
</blockquote>
<h2 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h2><p>TCP的可靠数据传输服务保证另一个进程从其接收缓冲中读出的数据无损坏无间隔非冗余的按序字节流。</p>
<p>提出问题：对于那些被接收方缓存但是由于无序不能确认的包，有什么机制呢？（这个不同于回退N步，亦不同于选择重传（选择重传N个定时器））</p>
<h3 id="简化的TCP发送方动作"><a href="#简化的TCP发送方动作" class="headerlink" title="简化的TCP发送方动作"></a>简化的TCP发送方动作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">sendbase = initial_sequence number </div><div class="line">nextseqnum = initial_sequence number </div><div class="line"></div><div class="line">loop (forever) &#123; </div><div class="line">    <span class="keyword">switch</span>(event) </div><div class="line">   <span class="comment">/* event: data received from application above </span></div><div class="line"><span class="comment">    create TCP segment with sequence number nextseqnum </span></div><div class="line"><span class="comment">    compute timeout interval for segment nextseqnum</span></div><div class="line"><span class="comment">    start timer for segment nextseqnum </span></div><div class="line"><span class="comment">    TCP只会为第一个设置一个定时器</span></div><div class="line"><span class="comment">    pass segment to IP */</span></div><div class="line">     ;</div><div class="line">    nextseqnum = nextseqnum + length(data) ;</div><div class="line">    <span class="comment">/*event: timer timeout for segment with sequence number y </span></div><div class="line"><span class="comment">    retransmit segment with sequence number y </span></div><div class="line"><span class="comment">    compute new timeout interval for segment y </span></div><div class="line"><span class="comment">    restart timer for sequence number y */</span> </div><div class="line">    <span class="comment">//event: ACK received, with ACK field value of y ;</span></div><div class="line">    <span class="keyword">if</span> (y &gt; sendbase) &#123; <span class="comment">/* cumulative ACK of all data up to y */</span> </div><div class="line">        cancel all timers <span class="keyword">for</span> segments with sequence numbers &lt; y ;</div><div class="line">        sendbase = y ;</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">else</span> &#123; <span class="comment">/* a duplicate ACK for already ACKed segment 快速重传机制*/</span> </div><div class="line">        increment number of duplicate ACKs received <span class="keyword">for</span> y ;</div><div class="line">        <span class="keyword">if</span> (number of duplicate ACKS received <span class="keyword">for</span> y == <span class="number">3</span>) &#123; </div><div class="line">        <span class="comment">/* TCP fast retransmit */</span> </div><div class="line">            resend segment with sequence number y ;</div><div class="line">            restart timer <span class="keyword">for</span> segment y ;</div><div class="line">        &#125; </div><div class="line">    &#125;  <span class="comment">/* end of loop forever */</span> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="超时间隔加倍"><a href="#超时间隔加倍" class="headerlink" title="超时间隔加倍"></a>超时间隔加倍</h3><p>前面讲到TimeoutInterval根据ERTT与DRTT推导出，其实这只是在首次发出报文段的时间间隔。之后每超时一次，这个时间间隔都会被设置为原来的2倍。这也算是拥塞控制的一部分，因为当数据报丢失时，很可能是因为网络的拥堵。在后面将会更加详细的介绍TCP拥塞控制机制。</p>
<h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p>就像前面已经提到的，3个对同一数据的冗余ACK激发快速重传。</p>
<h3 id="GoBackN-or-Selective-Repeat？"><a href="#GoBackN-or-Selective-Repeat？" class="headerlink" title="GoBackN or Selective Repeat？"></a>GoBackN or Selective Repeat？</h3><p>TCP看起来更像是Go Back N，因为只有一个定时器，但是TCP又会在接收方提供缓存机制，而且<strong>每次重传都只会重传一个报文段</strong>。</p>
<p>对TCP提出的一种修改意见是<strong>选择确认</strong>，也就是允许TCP对失序报文段有选择的确认。这种机制我们不讨论。</p>
<p><strong>云巽</strong>：yunxun，意外发现了一个很好听的词！</p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>emmm这里是想直接嵌入js的，没想到失败了。就先这么放着，在文章最后可以看到。</p>

<div id="map-wrap" style="height: 500px;width:800px;"></div>
 <script type="text/javascript" src="/js/echarts.min.js"></script>
    <script src="/js/flow-control.js"></script>

<p>需要注意的一点是，流量控制与拥塞控制并不是同一个概念。流量控制是为了使接收方的缓存区不会溢出，拥塞控制则是为了降低网络的负担。</p>
<p>TCP的发送端维护<strong>接收窗口</strong>rwnd，接收窗口将指示给发送方接收方还能最多收到多少字节的数据。<br>定义：<br><strong>LastByteRead</strong>：接收方的应用进程从缓存中读出的最后一个字节的编号。<br><strong>LastByteRcvd</strong>：从网络到达接收方并放入接收缓存的最后一个字节的编号。<br><strong>接收缓存RecvBuffer</strong>。<br>由于TCP不允许溢出：LastByteRcvd-LastByteRead&lt;=RecvBuffer<br>接收窗口的大小：rwnd=RecvBuffer-(LastByteRcvd-LastByteRead)</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-21/83120235.jpg" alt=""></p>
<p><strong>LastByteSent</strong>：发送方维护的已经发送的最后一个字节的编号。<br><strong>LastByteACKed</strong>：被确认的最后一个字节的编号。</p>
<p>根据接收方的动作，由于被Read的一定是已经接收方被ACKed的（但是发送方可能会因为其他问题还没有被ACK），因此，只需要保证LastByteSent-LastByteACKed&lt;=rwnd，这样就可以保证接收方的缓冲区不会溢出。</p>
<p>动作：接收方每次ACK，都告诉发送方自己的rwnd，发送方将最多发送rwnd字节的数据。</p>
<blockquote>
<p>仔细想一想，其实这个真的是有用的吗？如果一个包ACK了N字节，但是ACK损坏掉了，这时可以看到rwnd指示有额外的空间，但是在发送方却没有额外的空间了（sent-acked=rwnd），这时应不应该继续发送呢？</p>
</blockquote>
<p>这种方法其实有一个问题：接收方ACK的时候，告诉发送方自己的rwnd=0，过了一会儿，APP层拿走了一些数据，这时rwnd有空间了，但是发送方却不知道有空间了，不会发送数据。这就会形成死锁。<br>有两种可能的解决方法，但是TCP要求接收方尽可能简单，于是这个任务落在了发送方。<br>发送放在被告知对方的rwnd=0之后一段过时间将开始向接收方发送只含有一个字节的<strong>探测报文</strong>，这些报文段将会被接收方确认，直到发送方接收到了一个rwnd!=0的报文段ACK。</p>
<p>UDP不提供流量控制。</p>
<h2 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h2><h3 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h3><p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-21/34029198.jpg" alt=""></p>
<p>三次握手如上：</p>
<ol>
<li>客户端发送一个<strong>不承载数据</strong>的SYN被置为1的报文段<strong>SYN报文段</strong>。client_isn是随机生成，为了消除分组重传带来的错误（取决于网络时延）。有一些在如何选取client_isn方面的有趣研究。</li>
<li>服务器端发送<strong>SYNACK</strong>报文段：一旦服务器端接收到了上一个报文，就开始准备为这条连接分配缓存与变量，并发送一个允许连接的报文段：SYN被置为1表示请求连接。（TCP连接互不干扰，实际上存在两条连接，在关闭连接时更能体现出），seq指明了自己的初始序号，ACK是对前面一个请求连接报文段的确认。此后，客户端就可以向服务器端发送信息了。</li>
<li>客户机为这条连接分配变量与缓存，并发送确认报文：是客户端确认服务器端连接的普通报文段，这个报文段可以承载数据（因为client-&gt;server的连接已经建立）。此后，服务器端就可以向客户端发送信息了。</li>
</ol>
<p>client_isn以及server_isn一般有自己对应的counter产生，从而确保相近时间创立的连接的seq不同。</p>
<blockquote>
<p>可以想象，如果在A到B的使用到了seq=N的连接刚刚关闭，新开的A到B的相同端口号的连接又使用了序号N，而由于网络时延的关系，上一个连接的N还存在于网络之中，就有可能出现上一个N被误当作这次的N被接收ACK，导致应用层获取数据错误的情况发生。</p>
</blockquote>
<p>上面的是一个标准的打开过程，实际上，打开过程可能会出现各种幺蛾子，比如：</p>
<p>Simultaneous Open ：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-21/40260134.jpg" alt=""><br>实际上，这种打开是成功的。两端都有各自的连接，实际上所起的效果是一样的。这里的第二个报文之所以没有seq，是因为seq是给对方ACK使用的，由于这里的每一条连接是单向的，就不需要给出一个新的seq。</p>
<p>半打开：<br>半打开是失败的打开，是因为一方的连接建立起来之后另一方没有再回消息，也就是第三条报文不见了。比如机器非正常关机等都可能会导致半打开。数量较大的版打开将会影响效率与空间。怎么消除半打开的连接呢？<br>可以定时检查，向对方发送报文，如果不如回应，就把己方的连接关闭。</p>
<h3 id="连接关闭"><a href="#连接关闭" class="headerlink" title="连接关闭"></a>连接关闭</h3><p>参与TCP连接的任意一方都能随时终止连接，连接结束之后，为连接维护而存储的变量与缓存都将被释放。<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-21/38371351.jpg" alt=""><br>红色部分之后，client不再发送报文段，但是还可以接收；绿色之后，server不再发送报文段，连接正式关闭。</p>
<p>半关闭：<br>半关闭是正常现象，指的就是A-&gt;B的连接关闭之后，A不会再发送但是还能接收，B到A的也关闭了之后才都消停下来。</p>
<h3 id="TCP连接状态序列"><a href="#TCP连接状态序列" class="headerlink" title="TCP连接状态序列"></a>TCP连接状态序列</h3><p>客户机的TCP状态序列：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-21/8044207.jpg" alt=""></p>
<p>为什么直到等待一个IP数据报在Internet上可能存活的最大时间长的两倍（即120秒）后，一个连接才能从TIME_WAIT状态转移到CLOSED状态？<br>当连接的本地一方已经发出一个ACK数据段响应对方的FIN数据段时，它并不知道这个ACK数据段是否成功地被传递。结果是，另一方可能有重传一个FIN数据段，而这个第2个FIN数据段可能在网中被延迟。如果允许连接直接转移到CLOSED状态那么可以会有另一对应用进程会打开同一个连接（即使用同一对端口号），而前面连接实例中被延迟的FIN数据段这时会立即使后来的连接实例终止。同时也避免了分组重传带来的错误信息。</p>
<p>服务器的TCP状态序列：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-21/25538433.jpg" alt=""></p>
<h3 id="TCP定时器总结"><a href="#TCP定时器总结" class="headerlink" title="TCP定时器总结"></a>TCP定时器总结</h3><p><strong>Connection Establishment Timer</strong>：<br>当SYN包发出时，连接建立定时器就开始计时，如果在75秒内未收到响应，则连接建立失败。<br><strong>The Retransmission Timer</strong>：<br>重发定时器是TCP发送数据时设置的，如果数据在重发定时器超时时还没有返回确认，TCP就重发数据。定时器的设置是动态的，它基于TCP对往返时间（round-trip time）的测试，重发时间设在1到64秒<br><strong>Delayed ACK Timer</strong>：<br>当TCP实体收到数据时它必须返回确认，但并不需要立即回复，它可以在500ms内发送ACK报文，如果在这段时间内它恰好有数据要发送，它就可以在数据内包含确认信息，因此需要ACK延时定时器。<br><strong>The Persistence Timer</strong>：<br>管理一种较为少见的事件，即死锁情况。为了让发送方暂停发送数据，接收方发送一个接收窗口为0的确认。后来，接收方又发送了一个更新了窗口大小的分组，但该分组丢失，于是，双方都处于等待<br>为了防止上述事情发生，发送方在收到接收方发来一个窗口为0的数据时，就启动持续定时器，等该定时器超时还没有收到对方修改窗口大小的数据的话，发送方就发一个探测数据，对该探测数据的响应应包含了窗口大小，若仍为0，则定时器清0，重复以上步骤，否则则可以发送数据。<br><strong>The Keep-Alive Timer</strong>：<br>当一个连接长时间闲置时，保持存活定时器会超时而使一方去检测另一方是否仍然存在，如果它未得到响应，便终止该连接<br><strong>The Quiet Timer</strong>：<br>当TCP连接断开后，为防止该连接上的数据还在网络上，并被后续打开的相同的连接接收，要设置闲置定时器以防止刚刚断开连接的端口号被立即重新使用</p>
<blockquote>
<p>SYN洪泛攻击<br>在上面提到了：半Open。其实这种情况大都在一分钟之后被服务器端发现并断开连接，回收资源了。但是这一分多钟的时间的资源浪费将为经典的Dos攻击即SYN洪泛攻击创造了环境。<br>在这种攻击模式中，攻击者发送大量的SYN报文段而不发送最终的ACK，导致大量的半连接占用服务器的资源。<br>现在有一种有效的解决方式：SYN cookie<br>SYN cookie的工作方式是：当server接收到一个SYN，他并不立即为这个连接分配缓存与变量，而是使用这个TCP报文段携带的源ip与源port信息，运行一个仅有server知道的一个散列函数得到一个初始序列号，这种精心制作的初始序列号被称为cookie。server仅仅是发送一个具有该序号的SYNACK。该序号也不会被保存。<br>如果一段时间之后接收到了同一个源ip与源port的ACK报文段，server发现二者并没有连接，于是再次运行散列函数，得到的序号如果加一就是本ACK携带的序号，server就认为这是一个正常的client，为之分配资源，建立连接，否则，server不会分配资源，之前的攻击没有任何影响。<br>（哎呀其实也稍稍影响了处理效率了吧）</p>
</blockquote>
<h3 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h3><p>前面考虑的都是特别理想的情况，如果client向server一个并不接受TCP连接的port发送了一条报文将会怎样？</p>
<p>server将发送一个<strong>特殊重置报文段</strong>给client，这个报文段将RST标志位置为1，告诉client自己没有那个port接收TCP，请他不要再发送了。</p>
<p>如果发送的是一个UDP报文段，如果不匹配，server发送一个ICMP数据报。这在<strong>网络层</strong>进行讨论。</p>
<blockquote>
<p>nmap工作原理：<br>nmap向某一台主机的一个port发送一个SYN，接下来有三种情况：收到一个SYNACK，则会标明那个端口上有一个已经打开的TCP应用程序，返回“打开”，如果收到RST，说明这个端口没有一个TCP应用程序，如果什么都没有收到，说很可能是被防火墙给墙了。<br><a href="http://www.nmap.org" target="_blank" rel="external">nmap下载</a></p>
</blockquote>
<h3 id="TCP-option"><a href="#TCP-option" class="headerlink" title="TCP option"></a>TCP option</h3><p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-21/50610071.jpg" alt=""></p>
<p>先只放一个图。</p>
<h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><p>在讨论TCP的拥塞控制之前，首先来讨论更加普遍的拥塞控制原理。</p>
<p>我们把<strong>分组重传</strong>作为网络拥塞的信号。实际上，分组重传不全是因为网络拥塞。</p>
<p><strong>ATM</strong>：异步传输网络<br><strong>ABR</strong>：可用比特率</p>
<h3 id="1-两个发送方与一个无限缓存的路由器"><a href="#1-两个发送方与一个无限缓存的路由器" class="headerlink" title="1. 两个发送方与一个无限缓存的路由器"></a>1. 两个发送方与一个无限缓存的路由器</h3><p>不考虑分组重传、流量控制、拥塞控制，忽略首部信息的额外开销。<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-21/15483986.jpg" alt=""></p>
<p>这种情况下，发送方完全不节制，每连接的吞吐量如下：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-21/89389045.jpg" alt=""><br>吞吐量不可能有超过R/2的稳定状态，这是因为二者共享一个吞吐量R的链路。当发送速率在[0,R/2]时，接收方的吞吐率等于发送方的发送速率，也就是<strong>发送方的所有数据经过有限时间传输之后到达接收方</strong>。</p>
<p>但是，再看速度与平均时延的关系：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-21/46450452.jpg" alt=""><br>看起来吞吐量接近R/2是件好事，但是从时延的角度来看，接近R/2的时候，平均时延就会越来越大。</p>
<p><strong>代价1</strong>：巨大的时延。</p>
<p><strong>（为什么？？？到R/2的时候不是正好利用完所有链路吗？又没有重传，时延为什么会这么大？？？</strong></p>
<h3 id="2-两个发送方以及一个具有有限缓存的路由器"><a href="#2-两个发送方以及一个具有有限缓存的路由器" class="headerlink" title="2. 两个发送方以及一个具有有限缓存的路由器"></a>2. 两个发送方以及一个具有有限缓存的路由器</h3><p>假设：路由器缓存已经满了的话，新来的数据包就会被丢弃。</p>
<p><strong>供给载荷</strong>：运输层向网络中发送报文段的速率。</p>
<p>仍然使用上面的图。</p>
<ol>
<li>如果控制得非常好，yin=yout</li>
<li>如果只对丢失的包进行重传，yin`&gt;yout</li>
<li>对迟到的包重传，yin`远大于yout</li>
</ol>
<p>以上三种情况下的吞吐量随着供给载荷变化：（所谓吞吐量，就是☞yout吧）<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-21/98233117.jpg" alt=""></p>
<p>第二图的R/3-R/2是部分重传丢失占用的带宽，第三图的R/4-R/2是部分重传丢失+延时重传带来的丢失。</p>
<p><strong>代价2</strong>：不必要的重传占用带宽</p>
<h3 id="3-四个发送方以及有有限缓存的多台路由器及多跳路径"><a href="#3-四个发送方以及有有限缓存的多台路由器及多跳路径" class="headerlink" title="3. 四个发送方以及有有限缓存的多台路由器及多跳路径"></a>3. 四个发送方以及有有限缓存的多台路由器及多跳路径</h3><p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-21/85465498.jpg" alt=""></p>
<p>从虚线开始，吞吐量就开始下降，一直到最后几乎为0.这时路由器几乎一直在丢失重传丢失重传。</p>
<h3 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h3><ol>
<li>端到端的拥塞控制：IP协议并不提供对拥塞控制的支持，如果要在运输层做拥塞控制，也只能通过行为来判断。例如3次同一数据的ACK，被认为是丢失报文段，进而以为网络有些繁忙。</li>
<li>网络辅助的拥塞控制：路由器向发送方提供显式的拥塞信息。这个信息只需要一个比特。有两种方式：一种是直接反馈，路由器直接告诉发送方拥塞；另一种是间接反馈，路由器标记数据，当接收方收到被标记的数据之后在ACK的时候告诉发送方。</li>
</ol>
<h3 id="网络辅助的拥塞控制：ATM-ABR"><a href="#网络辅助的拥塞控制：ATM-ABR" class="headerlink" title="网络辅助的拥塞控制：ATM ABR"></a>网络辅助的拥塞控制：ATM ABR</h3><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>TCP的拥塞控制的基础是认为所有数据包的丢失都是路由器因为阻塞给我丢掉了。<br>实际上，有线网络传丢的可能性很小，所以这个基础是没什么问题的。但是在无线网络中，TCP的拥塞控制则需要有一定的改进。</p>
<h3 id="TCP拥塞控制概述"><a href="#TCP拥塞控制概述" class="headerlink" title="TCP拥塞控制概述"></a>TCP拥塞控制概述</h3><p><strong>拥塞窗口cwnd</strong>：发送方维护一个变量，他对一个TCP发送方能对网络中发送数据的速率进行了限制。特别的：$$LastByteRcved-LastByteACKed&lt;=min{rwnd,cwnd}$$</p>
<p>cwnd限制了发送方每次向接收方发送的字节数量，考虑一个丢包与发送时延皆忽略不计的连接，粗略的讲，发送方发送的速率大概是（cwnd/RTT)字节/秒。因此，调整cwnd可以调整发送速率。</p>
<p>那么发送方要怎么知道有了拥塞？第一就是像前面所说的丢包或是连续三个ACK。<br>有没有可能丢包不是因为网络拥塞呢？当然是可能的！</p>
<p>对于不丢包的理想情况下，TCP的发送方将会收到对以前未确认报文的确认，它们使用这些确认来增加cwnd。到达的速率将会影响cwnd增长的速率，因为TCP使用触发（或计时）来增大它的拥塞窗口长度，TCP是<strong>自计时</strong>的。</p>
<p>TCP有一些处理方法：</p>
<ol>
<li>一个丢失的报文段意味着阻塞</li>
<li>一个确认报文段指示网络正在向接收方交付发送方的报文段，因此当对先前未确认的报文段到达时，增加发送速率</li>
<li>宽带探测。</li>
</ol>
<h3 id="TCP拥塞控制算法"><a href="#TCP拥塞控制算法" class="headerlink" title="TCP拥塞控制算法"></a>TCP拥塞控制算法</h3><p><strong>慢启动</strong>：</p>
<p>一条TCP连接开始时，首先cwnd会被设置为1个MSS。1个MSS真的很小，因此TCP此后每当一个报文段首次被确认（注意不是收到ACK哦，是被确认哦）就把MSS增加1.这样1变2，2变4，4变8…<strong>指数增长</strong>。</p>
<p>什么时候停止这种爆炸增长？</p>
<ol>
<li>存在丢包事件，将ssthresh置为cwnd/2，将cwnd重新置1，重新慢启动，。</li>
<li>存在丢包事件，将cwnd的值置为ssthresh，结束慢启动，进入拥塞避免阶段。</li>
<li>检测到3个冗余ACK，执行快速重传，进入快速恢复。</li>
</ol>
<p><strong>拥塞避免</strong>：</p>
<p>进入拥塞避免之后，离拥塞可能并不遥远。每个RTT将增加一个MSS。例如一个RTT发了10个包，那么这十个包只将cwnd增加1个MSS。</p>
<p>什么时候结束这种线性增长？</p>
<ol>
<li>丢包，将cwnd设置为1个MSS，sstresh设置为cwnd/2。</li>
<li>三个冗余ACK，将cwnd减半（三个已经收到的ACK要加上3个MSS），将ssthresh更新为cwnd/2，进入快速恢复</li>
</ol>
<p><strong>快速恢复</strong>：</p>
<p>对于引起TCP进入快速恢复的报文段，对每收到的一个冗余ACK都加一个MSS。这个阶段时说明网络其实并不是特别堵，只是传丢了一个，不用太过限制。直到最终丢失的报文段ACK到达，TCP在降低cwnd之后进入拥塞避免阶段。<br>如果出现超时事件，将将cwnd设置为1个MSS，sstresh设置为cwnd/2，进入慢启动。<br>如果出现冗余丢包事件，将cwnd设置为1个MSS，sstresh设置为cwnd/2。</p>
<h3 id="TCP-Tahoe与TCP-Reno"><a href="#TCP-Tahoe与TCP-Reno" class="headerlink" title="TCP Tahoe与TCP Reno"></a>TCP Tahoe与TCP Reno</h3><p>Tahoe不管发生什么事件，都会无条件的将cwnd变为1，然后重新慢启动。<br>Reno综合了快速恢复。</p>
<p>Tahoe的过程：在4时达到初始阈值，在8时有三个冗余ACK，在10.5时达到阈值。<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-22/38232100.jpg" alt=""><br>Tahoe不能容忍丢包，一旦丢包，就会进入慢启动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* slowstart is over        */</span> </div><div class="line"><span class="comment">/* cwnd &gt; threshold */</span></div><div class="line">Until (loss event) &#123;</div><div class="line">  every w segments ACKed:</div><div class="line">        cwnd ++;</div><div class="line">  &#125;<span class="comment">//拥塞控制阶段;</span></div><div class="line">threshold = cwnd /<span class="number">2</span>;</div><div class="line">cwnd = <span class="number">1</span>;</div><div class="line">perform slowstart<span class="comment">//重新慢启动;</span></div></pre></td></tr></table></figure>
<p>Reno过程：在4时达到初始阈值，在8时有三个冗余ACK，之后减小cwnd，进入快速恢复。<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-22/74575292.jpg" alt=""><br>Reno分超时丢包与冗余丢包，冗余丢包进入快速恢复，超时慢启动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* slowstart is over        */</span> </div><div class="line"><span class="comment">/* cwnd &gt; threshold */</span></div><div class="line">Until (loss event) &#123;</div><div class="line">  every w segments ACKed:</div><div class="line">      cwnd ++</div><div class="line">  &#125;<span class="comment">//拥塞控制;</span></div><div class="line">threshold = cwnd /<span class="number">2</span></div><div class="line">If (loss detected by timeout) &#123;<span class="comment">//进入慢启动;</span></div><div class="line">    cwnd = <span class="number">1</span></div><div class="line">    perform slowstart &#125;</div><div class="line">If (loss detected by triple duplicate ACK)<span class="comment">//进入快速恢复</span></div><div class="line">    cwnd = cwnd /<span class="number">2</span></div></pre></td></tr></table></figure>
<p>于是发现：什么对超时都是没有容忍度的，直接会慢启动。但是对于3个冗余ACK的表现个不一样，一般进入快速恢复。</p>
<h2 id="公平性：TCP与UDP"><a href="#公平性：TCP与UDP" class="headerlink" title="公平性：TCP与UDP"></a>公平性：TCP与UDP</h2><p>TCP是自律的，如果UDP不自律，可能会挤跨TCP。因此在使用UDP的APP层应该做类似的”平滑、缓慢变化“的拥塞机制，保证公平。</p>
<h1 id="端口与进程"><a href="#端口与进程" class="headerlink" title="端口与进程"></a>端口与进程</h1><p>最后，我需要补充一下端口号与进程之间的关系：</p>
<p>首先：缓冲区对应的是谁？在上一篇中就应该明确，是socket。</p>
<p><strong>端口号是什么？</strong></p>
<p>在网络技术中，端口大致有两种意思：一是物理意义上的端口，比如，ADSL Modem、集线器、交换机、路由器用 于连接其他网络设备的接口，如RJ-45端口、SC端口等等。二是逻辑意义上的端口，一般是指TCP/IP协议中的端口，端口号的范围从0到65535，比如用于浏览网页服务的80端口，用于FTP服务的21端口等等。我们这里将要介绍的就是逻辑意义上的端口。</p>
<p>服务器一般通过知名端口号来识别。例如，对于每个TCP/IP实现来说，FTP服务器的TCP端口号都是21，每个Telnet服务器的TCP端口号都是23，每个TFTP(简单文件传送协议)服务器的UDP端口号都是69。任何TCP/IP实现所提供的服务都用知名的1～1023之间的端口号。这些知名端口号由Internet号分配机构（InternetAssignedNumbersAuthority,IANA）来管理。</p>
<p>端口号的作用正是为了区分不同的网络服务。</p>
<p>上面的比较官方，下面将由我自己写的程序来——</p>
<p>TCP里面，一个端口号可以被多个socket绑定。而UDP不行，我的理解是数据不知道要给谁。</p>
<p>已经被绑定之后，再次要求绑定：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/88853868.jpg" alt=""></p>
<p>这是再次运行，也就是说，其实这个并不是一个进程不能绑定同一个端口号，而是两个UDP的socket不能绑定同一个端口。跟进程没有什么关系。fork子线程的时候，也可以使用其他的socket绑定其他的端口号。</p>
<p>端口这个概念就是计算机网络领域的概念，有网友直言说进程与端口号没有什么关系，其实是对的。</p>
<p>thanks for ur help!</p>
<p>[1] <a href="http://www.cnblogs.com/BoyXiao/archive/2012/02/20/2359273.html" target="_blank" rel="external">进程与端口映射</a></p>
<p>[2] <a href="https://baike.1688.com/doc/view-d2361261.html" target="_blank" rel="external">端口号是什么？</a></p>
<p>[3]<a href="https://www.ibm.com/support/knowledgecenter/zh/SSGMGV_3.2.0/com.ibm.cics.ts.internet.doc/topics/dfhtl2d.html" target="_blank" rel="external">IBM Knowledge Center</a>  这个有很多东西，不止端口号</p>
<p>[4]<a href="http://wiki.xiaohansong.com/network/tcp.html" target="_blank" rel="external">TCP</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
<div>
  
</div>

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/01/the One使用记录1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YaYi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Be With Me">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/01/the One使用记录1/" itemprop="url">the One使用记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-01T17:10:19+08:00">
                2017-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
                  . 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/实验室/" itemprop="url" rel="index">
                    <span itemprop="name">实验室</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>一个小tip：使用linux命令行进入带空格的文件，如果直接cd filename进入的话是不行的，那应该怎么进入呢？</p>
<p><strong>cd “filename”就好啦</strong>！</p>
<p>又一个小tip：不下心关掉了eclipse的项目工程目录怎么办？</p>
<p><strong>Window-&gt;Show View-&gt;Others-&gt;General-&gt;Project Explorer</strong></p>
<p>emmm，markdown行内代码形式：``包起来就行</p>
</blockquote>
<h1 id="从github下载the-one"><a href="#从github下载the-one" class="headerlink" title="从github下载the-one"></a>从github下载the-one</h1><p>犹记我初学git的时候也是傻傻的，这里就放出来具体操作方法了！</p>
<p>首先需要一个GitBash。在gitbash里使用cd命令进入想存放the one的文件夹，然后输入命令：<code>git clone https://github.com/akeranen/the-one.wiki.git</code>，前面两个是命令，最后一个是参数，代表的是这个仓库的地址。这个下载下来的是master….应该是不行的….下载v1.6吧。</p>
<p>等到完成之后就会发现在这个文件夹下面多了好多东西呀！</p>
<p>done！</p>
<h1 id="将项目import进Eclipse并运行"><a href="#将项目import进Eclipse并运行" class="headerlink" title="将项目import进Eclipse并运行"></a>将项目import进Eclipse并运行</h1><p>eclipse，使用java的孩子应该没有不知道的吧。哦对，the one是java代码编写。</p>
<p>到了这一步就出了一点小问题…一直是使用eclipse的File-&gt;import功能向workspace导入外部的项目的，导入the one的时候竟然告诉我未找到项目文件！<br>我尝试使用File-&gt;Open Project From FileSystem来，这次可以了。the one 成功出现在了project explorer里面！但是！有错误！</p>
<p>这个应该在说明文档里面说了，1.1以后版本的java要编译theone需要添加一些liabrary到项目的build path，但是我看了我的build path，已经添加了呀？怎么还有错？</p>
<p><a href="https://stackoverflow.com/questions/1089904/access-restriction-on-class-due-to-restriction-on-required-library" target="_blank" rel="external">click here</a></p>
<p>在上述网站，第二个回答解决了这个问题。由于JUnit3.0与4.0都在，我就都删除了，然后重新添加了JUnit4.0.done！</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-5/63641143.jpg" alt=""></p>
<p>如图，现在整个项目都已经没有错误了！</p>
<p>选择整个项目，右击Run As-&gt;JUnit Test成功！</p>
<p>the one涉及到了JUnit，如果不了解JUnit，需要先了解一下~</p>
<p><a href="">click here~ JUnit之一</a></p>
<p>在我以JUnit Test来运行时，theone出现了两个fail。这表明….可能是有bug的啊….<strong>mark</strong></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-5/23371918.jpg" alt=""></p>
<p><del>好吧，我先忽略了，</del> 然后 run了下（主类是core.DNTSim），发现其实可以出来东西。由于可能需要命令行参数，我又使用cmd来编译运行，结果…<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-5/5185150.jpg" alt=""></p>
<p>但是eclipse成功了呀？我找到了一个在eclipse设置命令行参数的方法，企图先跳过jdk版本带来的（？）编译问题。</p>
<p><a href="https://www.netlab.tkk.fi/tutkimus/dtn/theone/javadoc_v11/core/DTNSim.html" target="_blank" rel="external">DTNSim的API</a></p>
<p>Run-&gt;Run Configurations-&gt;DTNSim-&gt;Argumets:加上你想要的参数。即可：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-5/68381775.jpg" alt=""></p>
<p>好了，至此，程序初步可以运行使用了。</p>
<h1 id="解决问题时间"><a href="#解决问题时间" class="headerlink" title="解决问题时间"></a>解决问题时间</h1><hr>
<p>好的，现在是解决问题时间啊。</p>
<p>询问了老师，老师说这个可能是JUnit包加载不正确。但是我重新写了一个工程，使用一样的方法，那个是没错的。</p>
<p>所以我想是不是版本问题。</p>
<p>于是我下载了v1.6。使用同样的方法import进来，这次错误更多！<br>但是我发现这次最初是没有添加README里面说要自己添加的2个jar包的，所有感觉有希望！</p>
<p>添加jar包：</p>
<blockquote>
<p>Project右键-&gt; build path -&gt; configure build path-&gt;libraries-&gt;add jars-&gt;the-one-1.6.0-&gt;lib</p>
<p>好了，把这两个jar都添进来。</p>
<p>JUnit的添加方法还与上面一样，记得要添加的是4.0</p>
</blockquote>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/51953772.jpg" alt=""></p>
<p>没错了。</p>
<p>然后来测试一下。<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/45497488.jpg" alt=""></p>
<p>还有错:-)。</p>
<p>既然是有错的，那就只能一点一点分析是怎么回事了。</p>
<ol>
<li>首先，我又运行了1.6的compile，还是不行，这次我决定把电脑里面的jdk换成8。</li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/36756939.jpg" alt=""></p>
<p>如图，配置好的环境变量在cmd竟然没有更换！<br>这也是导致javac不能用的一个原因。<br>如果你确认自己配的环境变量肯定是对的，关掉cmd重新打开，就可以了。</p>
<p>环境变量配置应如下：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/16489027.jpg" alt=""><br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/44100075.jpg" alt=""><br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/61239558.jpg" alt=""><br>这次compile的结果。（jdk9不支持那个选项了？<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/64651101.jpg" alt=""><br>好了，这次使用one.bat也可以运行了。（jdk9：exm？？？</p>
<p>but….eclipse测试还是没过….<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/11070078.jpg" alt=""></p>
<hr>
<p>C:\ProgramData\Oracle\Java\javapath</p>
<h1 id="了解运行方法与配置信息"><a href="#了解运行方法与配置信息" class="headerlink" title="了解运行方法与配置信息"></a>了解运行方法与配置信息</h1><p>将参数设置为：[-b times] [ur conf_files]</p>
<p>-b后必须跟一个数字，这个数字表示simulation将会在batch mode（批处理）下运行，不会出现可视化界面，而是打印信息。后面的数字代表运行次数或者是num1:num2的形式来确定一个范围。</p>
<p>conf_files是一系列你自己写的conf file的文件名，数量任意。如果没有这个参数，会使用default_setting.txt。需要注意的是，如果多个conf设计同一个属性，那么在后面的设定将会覆盖前面的设定。</p>
<h2 id="Conf文件"><a href="#Conf文件" class="headerlink" title="Conf文件"></a>Conf文件</h2><blockquote>
<p>以下译自<a href="https://github.com/akeranen/the-one/wiki/README" target="_blank" rel="external">README</a></p>
</blockquote>
<p>所有的模拟参数都是通过cond文件给出的。conf文件就是普通的txt文件，在文件里有一些ket-value对。大多数变量的语法都是：<code>Namespace.key = value</code><br>例如：key的前缀是namespace命名空间，然后加一个.点，然后是key的名字。key和value被等于号=隔开。命名空间需要以<strong>大写字母</strong>开头，而且namespace和key都以CamelCase方式命名，大小写敏感。namespace宽松地定义了设置影响的某部分模拟环境simulation environment。许多（并非所有）namespace的名字与正在读的class的名字一样。特别是动作模块(movement models)，报告模块(report modules)以及路由模块(routing modules)遵照了这个习惯。有时namespace被用户定义，eg：使用网络接口，用户可以选择任何标识符，在该名称空间中定义特定于接口的设置，并在配置每个组应使用的接口时给出名称空间的名称。</p>
<p>数字可以使用.作为小数点，可以使用kilo(k)，mega(m)，giga(G)作为后缀。bool接受”true”,”false”,”0”,”1”。</p>
<p>许多设置确定了寻找外部文件的路径。路径可以是绝对路径也可以是相对路径，但是路径的分隔符必须是”/“。Unix与Windows都是。</p>
<p>有些变量包含以逗号隔开的值，对他们来说，语法是：<code>Namespace.key = value1,value2,etc.</code></p>
<p>对于运行索引（run-indexed）值，语法是：<code>Namespace.key=[runvalue;run2value;run3value;etc]</code>。每一个runvalue可以是一个被逗号分隔的值。</p>
<p>设置文件可以有注释，以#开头。</p>
<p>一些值（scenario and report names at the moment）支持”value filling”。有这个特性做支撑，可以从设置的值动态地构造，例如，scenario name。这在使用run-indexing的时候非常有用。Just put setting key names in the value part prefixed and suffixed by two percent (%) signs. These placeholders are replaces by the current setting value from the configuration file. See the included snw_comparison_settings.txt for an example. 这个机制像是：<br>比如，完善java的环境变量的时候：<br>JAVA_HOME=C:/Program Files/Java/<br>path=%JAVA_HOME%jre/…”</p>
<p>default_settings.txt这个文件，如果它存在，在运行的时候一定会被read。此后给的文件可以在此基础上设置更多的东西，也可以覆盖掉默认设置的一些定西。</p>
<h2 id="Run-indexing"><a href="#Run-indexing" class="headerlink" title="Run indexing"></a>Run indexing</h2><p>run index可以让你只使用一个conf文件就能运行很多个不同的配置configuration，方法是，你提供一个setting的数组，为在不同的conf文件之间需要改变的变量。例如：如果想用5个不一样的随机数生成器种子来生成movment models来运行模拟器，那么你可以这样define设置文件：<br><code>MovementModel.rngSeed = [1;2;3;4;5]</code><br>现在，你使用参数-b 5 my_config.txt运行。</p>
<p>warp-around：类似于OS里面的。也就是说：used values is the value at index (runIndex%arrayLength)。这样，就可以很轻易的运行很多排列。</p>
<h1 id="模块们"><a href="#模块们" class="headerlink" title="模块们"></a>模块们</h1><h2 id="Movement-models"><a href="#Movement-models" class="headerlink" title="Movement models"></a>Movement models</h2><p>在模拟中，运动模型控制着节点的运动。运动模型提供了coordinates坐标、速度、停顿时间。基本的安装包括：random waypoint,map based movement,shorest path map based movement,map route movement,external movement。除了external的所有这些运动模型，都有可控的速度以及停顿时间分布。可以给出最大值以及最小值，运动模型使得值在给定返回之间uniformly distributed均匀分布。在external里面，速度以及停顿时间都由文件中的给定值解释执行（interpreted）。</p>
<p>如果一个节点使用了随机航点运行模型（random waypoint:RandomWaypoint），这个节点在模拟区中被给予一个随机的坐标。节点直接以恒定的速度到达给定的目的地，然后停顿一段时间，然后获得新的目的地。这个过程在整个模拟的过程中持续进行，节点在这些zig-zag（蜿蜒的）路径上走</p>
<p>基于地图的运动模型将节点的运动限制在预先定义好的路径上。可以定义不一样的路径，可以定义对全体节点都有效的路径。这样的话，比如说，汽车才不会直接开进门里或者是开到人行道上。</p>
<p>基本的基于地图的运动模型（map-based:MapBasedMovement）初始时把节点们分布在两个相邻的地图节点之间，然后节点们开始运动，从一个adjacent map node到另一个。当节点到达下一个地图节点的时候，他随机选择下一个节点。但是只有当这是唯一的选项（即，避免回到它来自的地方）时才选择它来自的地图节点。一旦节点移动了10-100个地图节点，它暂停一段时间，然后再次开始移动。 </p>
<p>更加复杂的版本的基于地图的运动(ShortestPathMapBasedMovement)使用了Dijkstra的最短路径算法来寻找他在整个地图范围内的路径。一旦一个节点到达了他的目的地，他等一段时间，选择下一个随机的地图节点，用最短路径走过去。<br>（这个算法只对valid map nodes起作用）</p>
<p>对于基于最短路径的运动模型，地图的数据信息还包括POIs（point of interests）。instead of为下一个目的地选择任意随机地图节点，移动模型可以被配置为以可配置的概率给出属于某个POI组的POI。可以有无限数量的POI组，并且所有组可以包含任何数量的POI。所有节点组对于所有POI组可能具有不同的概率。<br>POI可以用来模拟例如商店，餐馆和旅游景点。</p>
<p>基于路线的运动模型（MapRouteMovement）可以用于对遵循特定路线的节点建模。（例如，公共汽车或电车线路。）只需要定义路线上的停靠点，然后使用该路线的节点就会经由最短路径，从一个站点到另一个站点，并在每一个stop停留设置好的时间。</p>
<p>所有的运动模型都可以决定什么时候节点是活跃的（他运动，可以被连接），什么时候不活跃。所有模型，除了external，可以给出多个时间间隔（time interval），在那个组的节点只会在那些时候比较活跃。</p>
<p>所有基于地图的运动模型都通过（WKT）格式的一个子集所规范的文件中获取输入信息。映射路径数据的解析器支持WKT文件的LINESTRING和MULTILINESTRING指令。对于点数据（例如POI），也支持POINT指令。 （MULTI）LINESTRING中的相邻节点被认为形成一个路径，并且如果某些行包含一些具有完全相同坐标的顶点，<br>路径从这些地方加入（这是如何创建交叉点）。 WKT文件可以使用任何合适的地理信息系统（GIS）程序从现实世界的地图数据进行编辑和生成。包含在模拟器发行版中的地图数据使用免费的基于Java的OpenJUMP GIS程序进行转换和编辑。</p>
<p>不一样的地图可以通过在不同的文件中存储属于不同类型的路径来定义。POIs简单的用WTK POINT定义，而POI组通过将所有的属于同一个组的POIs存储在同一个文件中来定义。所有的POI也必须是地图数据的一部分，所以他们可以使用路径进行访问。用LINESTRING定义路线的停靠点，停靠点按照它们在LINESTRING中出现的顺序进行遍历。一个WKT文件可以包含多个路由，并按照它们在文件中出现的顺序将它们提供给节点。</p>
<p>使用外部移动数据（ExternalMovement）的实验移动模型从文件读取时间戳节点位置，并相应地移动模拟中的节点。有关格式的详细信息，请参阅输入包中的ExternalMovementReader类的javadocs。一个合适的实验转换器脚本（transimsParser。<br>pl）的TRANSIMS数据包含在toolkit文件夹中。</p>
<p>要使用的运动模型是使用“movementModel”设置为每个节点组定义的。设置的值必须是movement包中的有效运动模型类别名称。<br>在MovementModel类中读取所有运动模型通用的设置，并在相应的类中读取运动模型特定的设置。有关详细信息，请参阅javadoc文档和示例配置文件。</p>
<h2 id="路由模块以及消息的创建"><a href="#路由模块以及消息的创建" class="headerlink" title="路由模块以及消息的创建"></a>路由模块以及消息的创建</h2><p>路由模块定义了在模拟中消息如何被处理。6个基本主动路由模块（First Contact,Spray and Wait,Direct delivery, PRoPHET and MaxProp），一个被动路由用于外部路由的模拟。主动路由模块是用于DTN路由的众所周知的路由算法的实现。也有这些模型的变体和包含在最新版本中的几个不同的模型。有关详细信息，请参阅路由程序包中的类。</p>
<p>被动路由器专门用于与其他（DTN）路由仿真器交互或运行仿真，而不需要任何路由功能。路由器除非由外部事件命令，否则不执行任何操作。这些外部事件由实现EventQueue接口的类提供给模拟器。</p>
<p>有两个基本的类可以用作消息事件的来源：ExternalEventsQueue和MessageEventGenerator。前者可以用一个合适的脚本（例如，toolkit文件夹中的createCreates.pl脚本）或通过将例如dtnsim2的输出转换成合适的形式来从手动创建的文件中读取事件。<br>有关格式的详细信息，请参阅输入包中的StandardEventsReader类。 MessageEventGenerator是一个简单的消息生成器类，它创建具有可配置消息创建间隔，消息大小和源/目标主机范围的均匀分布的消息创建模式。<br>可以使用MessageBurstGenerator和One {From，To} EachMessageGenerator类创建更具体的消息传递场景。有关详细信息，请参阅javadocs。</p>
<p>该toolkit文件夹包含一个用于dtnsim2输出的实验解析器脚本（dtnsim2parser.pl）（曾经是一个更强大的基于Java的解析器，但是由于这个更容易扩展的脚本而被丢弃）。该脚本需要dtnsim2的代码的一些补丁，可以从toolkit / dtnsim2patches文件夹中找到。<br>要使用的路由模块是按设置“路由器”的每个节点组定义的。所有路由器都不能正常交互（例如，PRoPHET路由器只能与其他PRoPHET路由器一起工作），所以通常对所有组使用相同（或兼容）路由器是有意义的。</p>
<h1 id="报告"><a href="#报告" class="headerlink" title="报告"></a>报告</h1><p>可以使用<strong>报告</strong>创建模拟运行的摘要数据，连接和消息的详细数据，适合使用例如Graphviz进行后处理的文件（创建图表）以及与其他程序接口。有关详细信息，请参阅报告包类的javadocs。</p>
<p>对于任何模拟运行可以有任意数量的报告，并且使用“Report.nrofReports”设置来定义要加载的报告的数量。报告类别名称使用“Report.reportN”设置定义，其中N是从1开始的整数值。设置的值必须是来自报告包的有效报告类别名称。<br>所有报告的输出目录（可以使用“输出”设置对每个报告类别重写）必须使用Report.reportDir -setting进行定义。如果报告类别未提供“输出”设置，则生成的报告文件名称为“ReportClassName_ScenarioName.txt”。</p>
<p>所有报告都有许多可配置的设置，可以使用ReportClassName.settingKey -syntax来定义。有关详细信息，请参阅Report类的javadocs和特定报告类（查找“设置id”定义）。</p>
<h1 id="主机组"><a href="#主机组" class="headerlink" title="主机组"></a>主机组</h1><p>一个host group是一组分享同样的运动和路由设置的主机。不同的组的设置值不一样，这样的话，它们可以表示不同类型的节点。可以在“组”（Group）命名空间中定义基本设置，不同的节点组可以覆盖这些设置或在其特定的命名空间（组1，组2等）中定义新的设置。</p>
<h1 id="the-settings"><a href="#the-settings" class="headerlink" title="the settings"></a>the settings</h1><p>有很多设置可以被设置。非常多，这里不提了。有关详细信息，请参阅类，尤其是report，routing和movement class的javadoc。另请参阅包含设置文件的示例。也许最重要的设置如下。</p>
<h2 id="脚本设置（Scenario-setting）"><a href="#脚本设置（Scenario-setting）" class="headerlink" title="脚本设置（Scenario setting）"></a>脚本设置（Scenario setting）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Scenario.name</div><div class="line"></div><div class="line"> <span class="comment">//脚本的名字，所有报告默认以此为前缀</span></div><div class="line"></div><div class="line">Scenario.simulateConnections </div><div class="line"></div><div class="line"><span class="comment">//connection是否应该被模拟。如果只对运动模型感兴趣，这个可以被disable，以获得更快的模拟速度。通常情况下，是enable的。</span></div><div class="line"></div><div class="line">Scenario.updateInterval </div><div class="line"></div><div class="line"><span class="comment">//每次更新时需要几秒。增加数值使模拟更快，但是可能以精度损失为代价。0.1-2 are good</span></div><div class="line"></div><div class="line">Scenario.endTime </div><div class="line"></div><div class="line"><span class="comment">//How many simulated seconds to simulate.</span></div><div class="line"></div><div class="line">Scenario.nrofHostGroups </div><div class="line"></div><div class="line"><span class="comment">//现在在模拟中有几个hosts group</span></div><div class="line"></div></pre></td></tr></table></figure>
<h2 id="接口设置（用来定义node可能会使用到的接口）"><a href="#接口设置（用来定义node可能会使用到的接口）" class="headerlink" title="接口设置（用来定义node可能会使用到的接口）"></a>接口设置（用来定义node可能会使用到的接口）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">type <span class="comment">//这个接口使用了什么类（来自接口目录）</span></div><div class="line"></div><div class="line"><span class="comment">//其余设置是特定于类的。可以是例如：</span></div><div class="line"></div><div class="line">transmitRange <span class="comment">//接口范围（meters）</span></div><div class="line"></div><div class="line">transmitSpeed <span class="comment">//接口的传输速度（bytes per second）</span></div></pre></td></tr></table></figure>
<h2 id="主机组设置（在Group或GroupN的命名空间使用）"><a href="#主机组设置（在Group或GroupN的命名空间使用）" class="headerlink" title="主机组设置（在Group或GroupN的命名空间使用）"></a>主机组设置（在Group或GroupN的命名空间使用）</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
<div>
  
</div>

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.gif"
                alt="YaYi" />
            
              <p class="site-author-name" itemprop="name">YaYi</p>
              <p class="site-description motion-element" itemprop="description">来如春梦不多时 去似朝云无觅处</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">Artikel</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">Kategorien</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">Tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/yayi2456" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:yourname@gmail.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://stackoverflow.com/yourname" target="_blank" title="StackOverflow">
                    
                      <i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://weibo.com/2723381840/" target="_blank" title="Weibo">
                    
                      <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YaYi</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>





  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>


	<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
本站总访问量 <span id="busuanzi_value_site_pv"></span> &nbsp&nbsp&nbsp
您是第<span id="busuanzi_value_site_uv"></span>个来到的小伙伴



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共47.1k字</span>
</div>



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  








  





  

  

  

  

  

  

  
  
<div id="hexo-helper-live2d">
  <canvas id="live2dcanvas" width="150" height="300"></canvas>
</div>
<style>
  #live2dcanvas{
    position: fixed;
    width: 150px;
    height: 300px;
    opacity:0.7;
    right: 0px;
    z-index: 999;
    pointer-events: none;
    bottom: -20px;
  }
</style>
<script type="text/javascript" src="/live2d/device.min.js"></script>
<script type="text/javascript">
const loadScript = function loadScript(c,b){var a=document.createElement("script");a.type="text/javascript";"undefined"!=typeof b&&(a.readyState?a.onreadystatechange=function(){if("loaded"==a.readyState||"complete"==a.readyState)a.onreadystatechange=null,b()}:a.onload=function(){b()});a.src=c;document.body.appendChild(a)};
(function(){
  if((typeof(device) != 'undefined') && (device.mobile())){
    document.getElementById("live2dcanvas").style.width = '75px';
    document.getElementById("live2dcanvas").style.height = '150px';
  }else
    if (typeof(device) === 'undefined') console.error('Cannot find current-device script.');
  loadScript("/live2d/script.js", function(){loadlive2d("live2dcanvas", "/live2d/assets/nico.model.json", 0.5);});
})();
</script>

</body>
</html>
