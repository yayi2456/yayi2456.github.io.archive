<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">

<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>


  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">




  
  
  <link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3">




<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Be With Me" type="application/atom+xml" />






<meta name="description" content="来如春梦不多时 去似朝云无觅处">
<meta property="og:type" content="website">
<meta property="og:title" content="Be With Me">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Be With Me">
<meta property="og:description" content="来如春梦不多时 去似朝云无觅处">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Be With Me">
<meta name="twitter:description" content="来如春梦不多时 去似朝云无觅处">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '61a4cd7c1bed364065c7fe56474ba5df',
      indexName: 'yayiblogsearch',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Be With Me</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8214766f6334490a524e10cda5fd72cf";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Be With Me</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">最喜欢你啦！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            日程表
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
			
			<!--增加的代码 start-->

          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/29/编译原理/语法分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YaYi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Be With Me">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/29/编译原理/语法分析/" itemprop="url">编译原理——语法分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-29T17:05:47+08:00">
                2017-11-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编译原理/" itemprop="url" rel="index">
                    <span itemprop="name">编译原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h1><p>终于开始语法分析的复习了！</p>
<p>上下文无关文法：1. 便于扩充语言特性 2. 语法容易被理解 3. 检错机制加入（其他就不行？）</p>
<p>语法分析器的位置（等待加图）</p>
<p>通用的语法分析器几乎是不可能保证效率的（目前有通用的语法分析器，Cocke-Younger-Kasami），目前有两种算法，<strong>自底向上</strong>（对应最左推导LL），<strong>自顶向下</strong>（对应最右推导LR）。</p>
<h2 id="语法错误处理"><a href="#语法错误处理" class="headerlink" title="语法错误处理"></a>语法错误处理</h2><p>在编程中可能会发生不同的错误，在词法（拼写错误）、语法（单词漏写、顺序错误）、语义、逻辑上都可能会发生错误，其中，语法错误相对较多，成为检查重点。</p>
<p>对语法错误的分析相对简单：它具有<strong>可行前缀/活前缀</strong>特性，在使用给定词法串前缀加上一些字符不能构成该语法的正确语言串时，就会发生错误。</p>
<p>处理错误有三个目标：清楚报告出现的错误、快速从错误中恢复、不能对正确程序的编译处理造成太大的影响。</p>
<blockquote>
<p>给出一个报告错误的方法：打印出有问题的那行 -&gt; 给出一个错误所在地的指针</p>
</blockquote>
<p>错误处理一般在于自圆其说。很难清晰的预测程序员原本的意图，只需要报告最一般的错误可能。</p>
<h3 id="错误恢复策略"><a href="#错误恢复策略" class="headerlink" title="错误恢复策略"></a>错误恢复策略</h3><p><strong>Panic模式</strong>：遇到错误之后，不断丢弃输入中的符号。直到发现$\color{red}{同步词法单元}$集合中的符号。</p>
<p>$\color{red}{同步词法单元}$：通常是界限符，比如分号、右大括号。他们的意图清晰，没有二义性。编译器的设计这必须为自己的编译器定义合适的同步词法单元。</p>
<p>panic模式可能会丢掉很多正常输入（这些失去的分析有可能会影响接下来的分析），但是这种模式很简单，能够保证不会进入无限循环。接下来的几个方法都不能保证。</p>
<p><strong>短语级</strong>：局部修正，继续分析。比如，可能会做一些逗号换分号，加减分号的操作。已经在一些修复型编译器中使用。</p>
<p>需要避免进入无限循环。比如设定是”在有错误的串前面加一个分号“，就可能会一直循环下去。</p>
<p>可以与panic结合，避免丢弃太多单词。</p>
<p><strong>错误产生式</strong>：描述错误模式。</p>
<p>可以更好的进行修正，检测错误信息。</p>
<p><strong>全局修正</strong>：x</p>
<h2 id="上下文无关文法"><a href="#上下文无关文法" class="headerlink" title="上下文无关文法"></a>上下文无关文法</h2><h3 id="正式定义"><a href="#正式定义" class="headerlink" title="正式定义"></a>正式定义</h3><p>一个上下文无关文法由<strong>终结符</strong>、<strong>非终结符</strong>、<strong>一个开始符号</strong>、<strong>一组产生式</strong>组成。使用符号描述是：$(V<em>{T} , V</em>{N} , S , p)$</p>
<p>在文法中有一些约定的命名方式（待补充）</p>
<h3 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h3><p>实际上是语法等价的一个替换过程。使用右部替换左部。</p>
<p><strong>形式化定义</strong>：<br>$$\alphaA\beta \Rightarrow \alpha\gama\beta 当且仅当存在 A \rightarrow \gama$$</p>
<p>$$  $$</p>
<h3 id="推导与语言"><a href="#推导与语言" class="headerlink" title="推导与语言"></a>推导与语言</h3><p><strong>最左推导</strong>：总是替换最左边的非终结符</p>
<p><strong>最右推导</strong>：总是替换最右边的非终结符</p>
<p><strong>形式化定义</strong>：</p>
<h3 id="推导与语法分析树"><a href="#推导与语法分析树" class="headerlink" title="推导与语法分析树"></a>推导与语法分析树</h3><p>一颗语法树可能会对应多个推导过程。如果限制了最左或者最右，那么一个语法树就只能对应一个推导。</p>
<h3 id="CFG设计"><a href="#CFG设计" class="headerlink" title="CFG设计"></a>CFG设计</h3><p>正则表达式可描述符号串$\in$GFG可描述字符串</p>
<h4 id="NFA-gt-CFG"><a href="#NFA-gt-CFG" class="headerlink" title="NFA-&gt;CFG"></a>NFA-&gt;CFG</h4><p>在CFG，与正则不同的是：CFG的开始符号是所有，正则的终态是空串；CFG的终态是空串，正则的终态是所有。</p>
<p>因此：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-29/75004681.jpg" alt=""></p>
<p>终态：$A_i \rightarrow \epsilon$</p>
<blockquote>
<p>形如xy(x!=y)的01串：（不能用正则）</p>
<ol>
<li>奇数串：S-&gt;B|BSB B-&gt;0|1</li>
<li>偶数串：拆成两个穿拼接形式。只要两个奇数串中心位置不同，拼出的偶数串就符合上述描述。<br>给出证明：</li>
</ol>
</blockquote>
<p>证明：</p>
<h4 id="CFG验证"><a href="#CFG验证" class="headerlink" title="CFG验证"></a>CFG验证</h4><p>证明CFG G生成语言L：互相包含。</p>
<blockquote>
<p>一个例子（略）</p>
</blockquote>
<h4 id="CFG修改"><a href="#CFG修改" class="headerlink" title="CFG修改"></a>CFG修改</h4><ol>
<li>去错</li>
<li>重写：满足特殊要求</li>
</ol>
<p>$$不合要求的问题<br>\begin{cases}<br>二义性 \<br>\epsilon-moves \<br>回路 \<br>左递归 \<br>提取左公因子<br>\end{cases}<br>$$</p>
<h4 id="消除二义性"><a href="#消除二义性" class="headerlink" title="消除二义性"></a>消除二义性</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
<div>
  
</div>

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/27/OS/Lab3_Document/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YaYi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Be With Me">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/27/OS/Lab3_Document/" itemprop="url">Lab3_Document</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-27T19:00:00+08:00">
                2017-11-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/MIT-Lab/" itemprop="url" rel="index">
                    <span itemprop="name">MIT Lab</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Lab3-Document"><a href="#Lab3-Document" class="headerlink" title="Lab3 Document"></a>Lab3 Document</h1><h2 id="Part-A：User-Enviornments-and-Exception-Handling"><a href="#Part-A：User-Enviornments-and-Exception-Handling" class="headerlink" title="Part A：User Enviornments and Exception Handling"></a>Part A：User Enviornments and Exception Handling</h2><p>在这一部分，首先需要了解关于在本实验中env（进程）的相关定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//in inc/env.h</span></div><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">    ENV_FREE = <span class="number">0</span>,</div><div class="line">    ENV_DYING,</div><div class="line">    ENV_RUNNABLE,</div><div class="line">    ENV_RUNNING,</div><div class="line">    ENV_NOT_RUNNABLE</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这是在本实验中定义的进程状态，在实验中，仅用到了ENV_FREE、ENV_RUNNABLE、以及ENV_RUNNING。</p>
<p>类似于课上讲的pcb，在本实验中对一个进程的描述定义如下：</p>
<p><code>//in inc/env.c</code></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/83894027.jpg" alt=""></p>
<p>第一个变量env_tf是当中断或异常或系统调用发生的时候，该进程需要保存的寄存器的值；最后一个变量指明了该进程的地址空间。</p>
<p>在kern/env.c中可以看到，关于进程，有三个全局的变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">envs</span> = <span class="title">NULL</span>;</span><span class="comment">// All environments</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">curenv</span> = <span class="title">NULL</span>;</span><span class="comment">// The current env</span></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_free_list</span>;</span><span class="comment">// Free environment list</span></div></pre></td></tr></table></figure>
<p>在马上进行的初始化之后，在envs所标识的物理地址开始，一直到<code>NENV\*(struct Env)</code>结束，是所有可以被使用的进程描述结构占用的空间，每一个(struct Env)大小都是一个可用的Env描述。curenv被指示为是当前正在运行的进程。env_free_list指向第一个可以使用的进程描述结构，这样的设计使得进程描述结构的申请与销毁都变得很容易，而且由于该链表中存储的是处于ENV_FREE状态的进程，很少需要有添加删除的过程。</p>
<h3 id="Allocating-the-Environments-Array"><a href="#Allocating-the-Environments-Array" class="headerlink" title="Allocating the Environments Array"></a>Allocating the Environments Array</h3><p>就像在实验二中那样，在这里需要修改<code>pmap.c</code>中的代码，为envs映射空间。仿照在lab2中的写法，修改程序如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//in kern/pmap.c the first LAB3: Your code here</span></div><div class="line">envs=(struct Env\*)(boot\_alloc(NENV\*<span class="keyword">sizeof</span>(struct Env)));<span class="comment">//为Env结构申请空间</span></div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//in kern/pmap.c the second LAB3: Your code here</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ROUNDUP(NENV\*<span class="keyword">sizeof</span>(struct Env),PGSIZE);i+=PGSIZE)&#123;</div><div class="line">        page_insert(kern_pgdir,(struct PageInfo\*)pa2page(PADDR(envs)+i),(<span class="keyword">void</span>\*)(UENVS+i),PTE_U);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>像在lab2中做过的那样，<code>boot\_map\_region</code>使得从PADDR(envs)开始，连续PTSIZE的物理空间映射到从UENVS开始的虚拟地址空间上。</p>
<p>做到这里尝试<code>make qemu</code>的时候，发现失败了。</p>
<p><strong>注意</strong>：回想在lab2中所做的工作，在<code>page_init</code>函数中曾经为没有用的页面加入freelist。查看当时的代码发现，那时计算剩余空间的时候，是从为npages分配空间呢的后一页开始计算的。在<code>mem_init</code>中修改了之后的映射之后，这时的freelist应该从envs占用所有空间之后的第一页进行添加，于是修改代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> begin=(<span class="keyword">int</span>)ROUNDUP(((<span class="keyword">char</span>*)envs) + (<span class="keyword">sizeof</span>(struct Env) * NENV) - <span class="number">0xf0000000</span>, PGSIZE);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (i=begin/PGSIZE;i&lt;npages;i++)&#123;</div><div class="line">    pages[i].pp_ref=<span class="number">0</span>;</div><div class="line">    pages[i].pp_link=page_free_list;</div><div class="line">    page_free_list=&amp;pages[i];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再次<code>make qemu</code>，得到结果如下：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/91108119.jpg" alt=""></p>
<h3 id="Creating-and-Running-Environments"><a href="#Creating-and-Running-Environments" class="headerlink" title="Creating and Running Environments"></a>Creating and Running Environments</h3><p>在这一部分，将会完善<code>kern/env.c</code>中的内容，来建立起一个进程操作的雏形。</p>
<p>由于还没有文件系统，这时我们用一个技巧来骗过boot loader，使得bootloader加载kernel的时候也把我们需要的用户程序加载进来。这些用户程序在<code>user</code>文件夹下。</p>
<p>首先， -b binary option告诉编译器只需要将程序编译成二进制文件，而不需要生成.o文件，随后把这个文件作为一个较大的数组放在最后，同时在真正应该被搬进内存的文件中声明extern变量，告诉编译器在链接之前先不要管这个。随后，在链接阶段，大数组已经被load进来，与其他代码一同进行地址映射。最终这里的代码可以被执行。</p>
<p>查看<code>kern/init.c</code>文件，发现在所有初始化之后有这样的语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(TEST)</span></div><div class="line">    <span class="comment">// Don't touch -- used by grading script!</span></div><div class="line">    ENV_CREATE(TEST, ENV_TYPE_USER);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="comment">// Touch all you want.</span></div><div class="line">    ENV_CREATE(user_testbss, ENV_TYPE_USER);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>这是告诉编译器：如果用户采用<code>make qemu</code>的方式运行，那么就创建一个user_testbss这样的用户进程，实际上就是执行testbss.c文件生成的那个binary。</p>
<p>在env完成之后对这里进行更深一步的讨论。</p>
<p>接下来需要写出下面几个函数的代码：</p>
<ol>
<li>env_init</li>
<li>env_setup_vm</li>
<li>region_alloc</li>
<li>load_icode</li>
<li>env_create</li>
<li>env_run</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Mark all environments in 'envs' as free, set their env_ids to 0,</span></div><div class="line"><span class="comment">// and insert them into the env_free_list.</span></div><div class="line"><span class="comment">//把所有的envs设置成free的，他们的id都是0，然后插入freelist</span></div><div class="line"><span class="comment">// Make sure the environments are in the free list in the same order</span></div><div class="line"><span class="comment">// they are in the envs array (i.e., so that the first call to</span></div><div class="line"><span class="comment">// env_alloc() returns envs[0]).</span></div><div class="line"><span class="comment">//需要保证所有在freelist里面的env的顺序与在数组中的env相同？？？</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//本函数：初始化所有在env数组中的的env结构，把它们加到freelist里面，要求如上。</span></div><div class="line"><span class="comment">//在meminit之后执行。</span></div><div class="line"><span class="comment">//env数组：*envs，当前：*curenv，freelist：*env_free_list</span></div><div class="line"><span class="keyword">void</span></div><div class="line">env_init(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">    struct Env*current=NULL;</div><div class="line">    <span class="keyword">int</span> i=NENV-<span class="number">1</span>;</div><div class="line">    <span class="comment">//一共NENV个env</span></div><div class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</div><div class="line">    <span class="comment">//NENV is defined in inc/env.h</span></div><div class="line">    <span class="comment">//current-&gt;env_tf=3;</span></div><div class="line">    envs[i].env_id=<span class="number">0</span>;</div><div class="line">    envs[i].env_runs=<span class="number">0</span>;</div><div class="line"><span class="comment">//  current-&gt;env_pgdir=NULL;</span></div><div class="line">    envs[i].env_link=env_free_list;</div><div class="line">    env_free_list=&amp;envs[i];</div><div class="line">    i--;</div><div class="line">&#125;</div><div class="line">    <span class="comment">// Per-CPU part of the initialization</span></div><div class="line">    env_init_percpu();</div><div class="line">    cprintf(<span class="string">"envinit done!\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数比较简单，需要注意的一点是要求倒着添加到链表里面。其他只是按照要求写的代码。</p>
<p>这个函数在最后执行了一个已经完成的函数：<code>env_init_percpu</code>，如下图：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/83957122.jpg" alt=""></p>
<p>该函数完成对各个段寄存器的设置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//为进程e初始化内核虚拟空间</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span></div><div class="line">env_setup_vm(struct Env *e)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	struct PageInfo *p = NULL;</div><div class="line">	<span class="comment">// Allocate a page for the page directory</span></div><div class="line">	<span class="keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))</div><div class="line">		<span class="keyword">return</span> -E_NO_MEM;</div><div class="line">	<span class="comment">// Now, set e-&gt;env_pgdir and initialize the page directory.</span></div><div class="line">	<span class="comment">//初始化pagedir？</span></div><div class="line">	<span class="comment">// Hint:</span></div><div class="line">	<span class="comment">//    - The VA space of all envs is identical above UTOP</span></div><div class="line">	<span class="comment">//	(except at UVPT, which we've set below).</span></div><div class="line">	<span class="comment">//	See inc/memlayout.h for permissions and layout.</span></div><div class="line">	<span class="comment">//	Can you use kern_pgdir as a template?  Hint: Yes.</span></div><div class="line">	<span class="comment">//	(Make sure you got the permissions right in Lab 2.)</span></div><div class="line">	<span class="comment">//所有envs的虚拟地址空间都在UTOP之上</span></div><div class="line">	<span class="comment">//查看inc/memlayout.h看许可以及布局</span></div><div class="line">	<span class="comment">//可以使用kern_pgdir作为一个模板</span></div><div class="line">    <span class="comment">//    - The initial VA below UTOP is empty.</span></div><div class="line">	<span class="comment">//    - You do not need to make any more calls to page_alloc.</span></div><div class="line">	<span class="comment">//    - Note: In general, pp_ref is not maintained for</span></div><div class="line">	<span class="comment">//	physical pages mapped only above UTOP, but env_pgdir</span></div><div class="line">	<span class="comment">//	is an exception -- you need to increment env_pgdir's</span></div><div class="line">	<span class="comment">//	pp_ref for env_free to work correctly.</span></div><div class="line">	<span class="comment">//    - The functions in kern/pmap.h are handy.</span></div><div class="line">	<span class="comment">// LAB 3: Your code here.</span></div><div class="line">	e-&gt;env_pgdir=(pde_t*)page2kva(p);<span class="comment">//page2kva in pmap.c</span></div><div class="line">	p-&gt;pp_ref++;</div><div class="line">	memcpy(e-&gt;env_pgdir,kern_pgdir,PGSIZE);<span class="comment">//kernel's e is the kernel's e</span></div><div class="line">	<span class="comment">//permission:RR</span></div><div class="line">	<span class="comment">//p[PDX(UTOP)] = PADDR(p) | PTE_U | PTE_P;</span></div><div class="line">	<span class="comment">// UVPT maps the env's own page table read-only.</span></div><div class="line">	<span class="comment">// Permissions: kernel R, user R</span></div><div class="line">	e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//为进程申请len字节的物理地址空间，然后把它map到va</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span></div><div class="line">region_alloc(struct Env *e, <span class="keyword">void</span> *va, size_t len)</div><div class="line">&#123;</div><div class="line">	<span class="comment">// LAB 3: Your code here.</span></div><div class="line">	<span class="comment">// (But only if you need it for load_icode.)</span></div><div class="line">	<span class="comment">//</span></div><div class="line">	<span class="comment">// Hint: It is easier to use region_alloc if the caller can pass</span></div><div class="line">	<span class="comment">//   'va' and 'len' values that are not page-aligned.</span></div><div class="line">	<span class="comment">//如果允许传入不是页对齐的va（虚拟地址）和len（长度）的话会更好一些</span></div><div class="line">	<span class="comment">//   You should round va down, and round (va + len) up.</span></div><div class="line">	<span class="comment">//   (Watch out for corner-cases!)</span></div><div class="line">	<span class="comment">//什么叫corner-cases</span></div><div class="line">	<span class="comment">//获取首地址</span></div><div class="line">	<span class="comment">//只是申请了页面，其实没有真正的物理空间</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=(uint32_t)ROUNDDOWN(va,PGSIZE);i&lt;(uint32_t)ROUNDUP(va+len,PGSIZE);i+=PGSIZE)&#123;</div><div class="line">		struct PageInfo*pa=page_alloc(<span class="number">0</span>);</div><div class="line">		<span class="keyword">if</span>(pa==NULL)panic(<span class="string">"fail to alloc !in region_alloc!"</span>);</div><div class="line">		page_insert(e-&gt;env_pgdir,pa,(<span class="keyword">void</span>*)i,PTE_U|PTE_W);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数指定进程申请从指定虚拟地址开始的len字节空间。由于vs与va+len可能不是页面对齐的，因此真正在分配页面的时候，需要做操作ROUNDOWN与ROUNDUP来进行页面的对齐。当申请页面失败时，panic，否则就将页面插入到当前进程的pgdir中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span></div><div class="line">load_icode(struct Env *e, uint8_t *binary)<span class="comment">//binary：ELF</span></div><div class="line">&#123;<span class="comment">//注意，对应的用户数据已经在内存中了</span></div><div class="line">	struct Elf*elf=(struct Elf*)binary;<span class="comment">//给定的ELF文件头结构（更详细的，查看inc/elf.h）</span></div><div class="line">	struct Proghdr *ph, *eph;<span class="comment">//ELF文件指定程序段的程序头</span></div><div class="line">		<span class="comment">// is this a valid ELF?</span></div><div class="line">	<span class="keyword">if</span> (elf-&gt;e_magic != ELF_MAGIC)</div><div class="line">		panic(<span class="string">"not a elf!"</span>);</div><div class="line">	ph = (struct Proghdr *) ((uint8_t *) elf + elf-&gt;e_phoff);<span class="comment">//第一个程序头开始</span></div><div class="line">	eph = ph + elf-&gt;e_phnum;<span class="comment">//最后一个不是程序头结构开始的位置</span></div><div class="line">	lcr3(PADDR(e-&gt;env_pgdir));<span class="comment">//将CR3中装载进去这次的页目录</span></div><div class="line">	<span class="keyword">for</span> (; ph &lt; eph; ph++)&#123;</div><div class="line">		<span class="keyword">if</span>(ph-&gt;p_type==ELF_PROG_LOAD)&#123;</div><div class="line">		region_alloc(e,(<span class="keyword">void</span>*)ph-&gt;p_va,ph-&gt;p_memsz);</div><div class="line">        <span class="comment">//申请从ph-&gt;p_va程序假设自己所在的虚拟地址开始，到va+memsz结束的空间</span></div><div class="line">		memmove((<span class="keyword">void</span>*)ph-&gt;p_va,binary+ph-&gt;p_offset,ph-&gt;p_filesz);</div><div class="line">    <span class="comment">//  The ph-&gt;p_filesz bytes from the ELF binary, starting at</span></div><div class="line">	<span class="comment">//  'binary + ph-&gt;p_offset', should be copied to virtual address</span></div><div class="line">	<span class="comment">//  ph-&gt;p_va.  Any remaining memory bytes should be cleared to zero.</span></div><div class="line">	<span class="comment">//  (The ELF header should have ph-&gt;p_filesz &lt;= ph-&gt;p_memsz.)</span></div><div class="line">	<span class="comment">//  Use functions from the previous lab to allocate and map pages.</span></div><div class="line">	<span class="comment">//在ELF中的ph-&gt;p_filesz字节的，从binary+ph-&gt;p_offset都应该被copy到虚拟地址空间ph-&gt;p_va</span></div><div class="line">	<span class="comment">//任何剩余的空间被清零</span></div><div class="line">		memset((<span class="keyword">void</span>*)(ph-&gt;p_va+ph-&gt;p_filesz),<span class="number">0</span>,ph-&gt;p_memsz-ph-&gt;p_filesz);<span class="comment">//eme2file</span></div><div class="line">		<span class="comment">//memcpy((void*)ph-&gt;p_va,binary+ph-&gt;p_offset,ph-&gt;p_filesz);</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"><span class="comment">//after modification , everything is OK!</span></div><div class="line">	<span class="comment">// call the entry point from the ELF header</span></div><div class="line">	<span class="comment">// note: does not return!</span></div><div class="line">	<span class="comment">//((void (*)(void)) (ELFHDR-&gt;e_entry))();</span></div><div class="line">	e-&gt;env_tf.tf_eip=elf-&gt;e_entry;</div><div class="line">	<span class="comment">// Now map one page for the program's initial stack</span></div><div class="line">	<span class="comment">// at virtual address USTACKTOP - PGSIZE.</span></div><div class="line">	<span class="comment">// LAB 3: Your code here.</span></div><div class="line">	region_alloc(e,(<span class="keyword">void</span>*)(USTACKTOP-PGSIZE),PGSIZE);</div><div class="line">	lcr3(PADDR(kern_pgdir));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数负责把已经装入内存的binary文件重新装载到ELF文件头中指定的位置，并为用户进程创建一个栈。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span></div><div class="line">env_create(uint8_t *binary, <span class="keyword">enum</span> EnvType type)</div><div class="line">&#123;</div><div class="line">	<span class="comment">// LAB 3: Your code here.</span></div><div class="line">	struct Env *newenv_store;</div><div class="line">	<span class="keyword">int</span> result=env_alloc(&amp;newenv_store,<span class="number">0</span>);</div><div class="line">	<span class="keyword">if</span>(result&lt;<span class="number">0</span>)panic(<span class="string">"env_alloc: %e"</span>, result); ;</div><div class="line">	<span class="keyword">if</span>(result==<span class="number">0</span>)&#123;</div><div class="line">		newenv_store-&gt;env_type=type;</div><div class="line">		load_icode(newenv_store,binary);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用到了已经定义好的函数：<code>env_alloc</code>。<code>env_create</code>本身比较简单，我们来看一下<code>env_alloc</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span></div><div class="line">env_alloc(struct Env **newenv_store, envid_t parent_id)</div><div class="line">&#123;</div><div class="line">	int32_t generation;</div><div class="line">	<span class="keyword">int</span> r;</div><div class="line">	struct Env *e;</div><div class="line">	<span class="comment">//没有新的可以用了</span></div><div class="line">	<span class="keyword">if</span> (!(e = env_free_list))</div><div class="line">		<span class="keyword">return</span> -E_NO_FREE_ENV;</div><div class="line">	<span class="comment">// Allocate and set up the page directory for this environment.</span></div><div class="line">	<span class="keyword">if</span> ((r = env_setup_vm(e)) &lt; <span class="number">0</span>)</div><div class="line">		<span class="keyword">return</span> r;</div><div class="line">	<span class="comment">// Generate an env_id for this environment.</span></div><div class="line">	generation = (e-&gt;env_id + (<span class="number">1</span> &lt;&lt; ENVGENSHIFT)) &amp; ~(NENV - <span class="number">1</span>);</div><div class="line">	<span class="keyword">if</span> (generation &lt;= <span class="number">0</span>)	<span class="comment">// Don't create a negative env_id.</span></div><div class="line">		generation = <span class="number">1</span> &lt;&lt; ENVGENSHIFT;</div><div class="line">	e-&gt;env_id = generation | (e - envs);</div><div class="line">	<span class="comment">// Set the basic status variables.</span></div><div class="line">	e-&gt;env_parent_id = parent_id;</div><div class="line">	e-&gt;env_type = ENV_TYPE_USER;</div><div class="line">	e-&gt;env_status = ENV_RUNNABLE;</div><div class="line">	e-&gt;env_runs = <span class="number">0</span>;</div><div class="line">	<span class="comment">// Clear out all the saved register state,</span></div><div class="line">	<span class="comment">// to prevent the register values</span></div><div class="line">	<span class="comment">// of a prior environment inhabiting this Env structure</span></div><div class="line">	<span class="comment">// from "leaking" into our new environment.</span></div><div class="line">	memset(&amp;e-&gt;env_tf, <span class="number">0</span>, sizeof(e-&gt;env_tf));</div><div class="line">	<span class="comment">// Set up appropriate initial values for the segment registers.</span></div><div class="line">	<span class="comment">// GD_UD is the user data segment selector in the GDT, and</span></div><div class="line">	<span class="comment">// GD_UT is the user text segment selector (see inc/memlayout.h).</span></div><div class="line">	<span class="comment">// The low 2 bits of each segment register contains the</span></div><div class="line">	<span class="comment">// Requestor Privilege Level (RPL); 3 means user mode.  When</span></div><div class="line">	<span class="comment">// we switch privilege levels, the hardware does various</span></div><div class="line">	<span class="comment">// checks involving the RPL and the Descriptor Privilege Level</span></div><div class="line">	<span class="comment">// (DPL) stored in the descriptors themselves.</span></div><div class="line">	e-&gt;env_tf.tf_ds = GD_UD | <span class="number">3</span>;</div><div class="line">	e-&gt;env_tf.tf_es = GD_UD | <span class="number">3</span>;</div><div class="line">	e-&gt;env_tf.tf_ss = GD_UD | <span class="number">3</span>;</div><div class="line">	e-&gt;env_tf.tf_esp = USTACKTOP;</div><div class="line">	e-&gt;env_tf.tf_cs = GD_UT | <span class="number">3</span>;</div><div class="line">	<span class="comment">// You will set e-&gt;env_tf.tf_eip later.</span></div><div class="line">	<span class="comment">// commit the allocation</span></div><div class="line">	env_free_list = e-&gt;env_link;</div><div class="line">	*newenv_store = e;</div><div class="line">	cprintf(<span class="string">"[%08x] new env %08x\n"</span>, curenv ? curenv-&gt;env_id : <span class="number">0</span>, e-&gt;env_id);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数完成一系列的初始化操作，申请新进程，地址空间申请，一些属性的设置（这也是在env_init中不是做设置的原因），寄存器值的清理与设置等等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span></div><div class="line">env_run(struct Env *e)</div><div class="line">&#123;</div><div class="line">		<span class="keyword">if</span> (curenv != e) &#123;</div><div class="line">		<span class="comment">// if (curenv-&gt;env_status == ENV_RUNNING)</span></div><div class="line">		<span class="comment">// 	curenv-&gt;env_status = ENV_RUNNABLE;</span></div><div class="line">		curenv = e;</div><div class="line">		e-&gt;env_status = ENV_RUNNING;</div><div class="line">		e-&gt;env_runs++;</div><div class="line">		lcr3(PADDR(e-&gt;env_pgdir));<span class="comment">//将当前的地址空间设置为当前进程的地址空间</span></div><div class="line">	&#125;</div><div class="line">	env_pop_tf(&amp;e-&gt;env_tf);</div><div class="line"></div><div class="line">	<span class="comment">//panic("env_run not yet implemented");</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数只需要根据提示即可写出，看一下<code>env_pop_tf</code>的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span></div><div class="line">env_pop_tf(struct Trapframe *tf)</div><div class="line">&#123;</div><div class="line">	<span class="function">__asm <span class="title">__volatile</span><span class="params">(<span class="string">"movl %0,%%esp\n"</span></span></span></div><div class="line"><span class="function"><span class="params">		<span class="string">"\tpopal\n"</span></span></span></div><div class="line"><span class="function"><span class="params">		<span class="string">"\tpopl %%es\n"</span></span></span></div><div class="line"><span class="function"><span class="params">		<span class="string">"\tpopl %%ds\n"</span></span></span></div><div class="line"><span class="function"><span class="params">		<span class="string">"\taddl $0x8,%%esp\n"</span> <span class="comment">/* skip tf_trapno and tf_errcode */</span></span></span></div><div class="line"><span class="function"><span class="params">		<span class="string">"\tiret"</span></span></span></div><div class="line"><span class="function"><span class="params">		: : <span class="string">"g"</span> (tf)</span> : "memory")</span>;</div><div class="line">	<span class="comment">//对应的汇编代码：</span></div><div class="line">	<span class="comment">/*</span></div><div class="line"><span class="comment">	mov tf,eax</span></div><div class="line"><span class="comment">	movl eax,esp</span></div><div class="line"><span class="comment">	popal</span></div><div class="line"><span class="comment">	popl es</span></div><div class="line"><span class="comment">	popl ds</span></div><div class="line"><span class="comment">	addl $0x8,esp</span></div><div class="line"><span class="comment">	iret</span></div><div class="line"><span class="comment">	*/</span></div><div class="line">	<span class="comment">//从这里开始，真正退出了内核态，进入用户态</span></div><div class="line">	panic(<span class="string">"iret failed"</span>);  <span class="comment">/* mostly to placate the compiler */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>真正开始运行时，是需要trap伪装栈内容之后才能调用该函数，进入用户态的。trap的内容将在PartB讨论。届时还会需要用到该函数的内容。</p>
<p>按照文档的说明，使用<code>b env_pop_tf</code>打断点，查看内容，在经过若干次执行之后：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/74775132.jpg" alt=""></p>
<p>iret将进行退栈操作，此处暂未涉及。</p>
<p>这里写完之后，就可以梳理一下在进入用户态之前都发生了什么：(in kern/init.c)</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/30532.jpg" alt=""></p>
<p>首先，清理bss。这将保证所有未初始化的都是0，在testbss中将会有体现。然后初始化控制台，进行内存的初始化，进程初始化，trap的初始化。随后创建一个env，开始执行。</p>
<p>现在，我们可以讨论在上面提到过的<code>ENV_CREATE</code>。</p>
<p><code>ENV_CREATE</code>在<code>kern/env.c</code>中被定义：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/30871223.jpg" alt=""></p>
<p>首先可以看到本文件对那些骗boot loader装载进来的用户程序的外部定义，随后调用env_create函数，以<code>ENV_PASTE3(_binary_obj_, x, _start)</code>作为传入的ELF文件头结构，以type作为类型被创建。</p>
<p>随后，在create之后，执行load_icode，将对应内存的文件搬运到指定内存，并设置进程的入口点为函数的入口点，为用户进程初始化map一个页空间的栈，准备开始执行。</p>
<p>随后，调用了env_run函数，执行这个已经准备好的用户程序。但是在这个阶段，这个程序实际上还不能被真正执行。</p>
<h3 id="Handling-Interrupts-and-Exceptions"><a href="#Handling-Interrupts-and-Exceptions" class="headerlink" title="Handling Interrupts and Exceptions"></a>Handling Interrupts and Exceptions</h3><p>中断与异常都将会打断原有程序的执行，转而执行其他程序。他们的区别就在于，中断用于处理那些处理器外部的异步事件，而异常处理被处理器在执行指令时发现的错误情况。</p>
<p>中断会被INTR引起，异常会被INT引起。这也确定了breakpoint应该是一个异常而不是中断。</p>
<h3 id="Basics-of-Protected-Control-Transfer"><a href="#Basics-of-Protected-Control-Transfer" class="headerlink" title="Basics of Protected Control Transfer"></a>Basics of Protected Control Transfer</h3><p>中断和异常都可能完成这个转化，完成特权级的转化需要两个东西：<strong>IDT</strong>与<strong>TSS</strong>。</p>
<p><strong>IDT</strong>：IDT确保了用户程序切换到内核态的情况只有已经由kernel定义的几种，保证切换过程中的安全性。 x86允许256个不同的中断或异常，他们有着不一样的<strong>中断向量</strong>，CPU利用中断向量来确定这个中断的中断向量表，进而找到处理中断的入口，执行处理程序。<br>找到中断向量的描述符之后，EIP中装载的将会是中断处理程序的入口地址，CS中装载的是运行优先级。不一样的运行优先级设置带来不一样的结果，在接下来的实验中将会被讨论到。</p>
<p>一个IDT Gate是这样的：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/79807638.jpg" alt=""></p>
<p>segment selector与offset用来描述在段机制下自己的中断响应函数的位置。segment selector负责在GDT里面找到对应的段，offset负责找对应的偏移量。找到函数之后，保存现场并执行响应函数。</p>
<p><strong>TSS</strong>：处理器需要空间来存储旧的寄存器中的值，这样从中断或异常中返回的时候，用户程序才能够接着执行。因此，在从用户态切换到内核态的时候，需要换一个栈进行操作。这时就需要TSS来确定段寄存器来确定这个栈到底在哪里。<br>从用户态切换到内核态时，首先在栈中push一些寄存器值：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-14/87170051.jpg" alt=""></p>
<p>然后加载中断描述符中的值，然后把ESP和SS置为指向新栈的值。</p>
<p>尽管TSS可能会很复杂，但是在这个实验中只是用到了指向内核栈的部分。</p>
<p>在中断发生的时候，系统将会看一下产生中断的程序的特权级，决定应该怎样保护现场。如果在特权状态，不用换栈，只需要保存更少的东西，而处于用户状态下的程序在执行完中断响应函数之后还要从内核栈退回到自己的用户栈，保存了更多的东西。</p>
<p>iret：系统指令，从中断中返回。<br>ret：从函数中返回<br>retf：与ret基本一样，从函数中返回。（弹出栈，拿出返回地址（就是下一条语句）返回值，丢掉压栈参数）</p>
<h3 id="Types-of-Exceptions-and-Interrupts"><a href="#Types-of-Exceptions-and-Interrupts" class="headerlink" title="Types of Exceptions and Interrupts"></a>Types of Exceptions and Interrupts</h3><p>当一个进程在User Environment运行时，忽然遇到了一个中断：</p>
<ol>
<li>进程切换到被TSS定义的那个栈，在JOS中SS0是GD_KD（GDT中的kernel code），ESP0是KSTACKTOP。</li>
<li>进程把一些值push到这个kernel栈里面。</li>
<li>找到IDT entry，开始执行函数</li>
</ol>
<p>需要注意的是，就像上面已经讨论过的，有些中断/异常会push error code，而有的不会。</p>
<p>如果是在内核态发生了中断，就不需要进行换栈操作，这时旧的SS与ESP不会被保存。</p>
<p>怎么从内核态切换到用户态呢，其实方法是相似的。新开一个用户栈，存上中断以为的数据，随后iret，这样就降到了用户模式。</p>
<h3 id="Setting-Up-the-IDT"><a href="#Setting-Up-the-IDT" class="headerlink" title="Setting Up the IDT"></a>Setting Up the IDT</h3><p>现在来查看本实验中关于中断/trap的内容。</p>
<p>在<code>inc/trap.h</code>中定义了许多中断号，PushRegs结构以及TrapFrame结构。</p>
<p>TrapFrame结构中定义了trapnumer、es、ds等在值，这些值在特权级发生改变的时候会被压栈出栈保存，在后面还会用到。</p>
<p>为了完成Exercise4，首先分析trap.c以及trapentry.S中的代码：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/27936694.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/10236379.jpg" alt=""></p>
<p>这两个macro将会帮我们进行trapno的压栈操作，函数名的定义。第一个用于自动压栈errorcode的，后一个处理不自动压栈errorcode的。<br>找到每个中断类型的压栈方式：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/2785767.jpg" alt=""></p>
<p>这时应该明确，这时仍处于原来的特权级。</p>
<p>于是，使用上述两个macro来为trap添加一个入口点，这部分的代码：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/63275240.jpg" alt=""></p>
<p>然后考虑<code>/kern/trap.c</code>中的内容，在这之前，首先查看macro SETGATE的作用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//in inc\mmu.h</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SETGATE(gate, istrap, sel, off, dpl)			\</span></div><div class="line">&#123;								\</div><div class="line">	(gate).gd_off_15_0 = (<span class="keyword">uint32_t</span>) (off) &amp; <span class="number">0xffff</span>;		\</div><div class="line">	(gate).gd_sel = (sel);					\</div><div class="line">	(gate).gd_args = <span class="number">0</span>;					\</div><div class="line">	(gate).gd_rsv1 = <span class="number">0</span>;					\</div><div class="line">	(gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;	\</div><div class="line">	(gate).gd_s = <span class="number">0</span>;					\</div><div class="line">	(gate).gd_dpl = (dpl);					\</div><div class="line">	(gate).gd_p = <span class="number">1</span>;					\</div><div class="line">	(gate).gd_off_31_16 = (<span class="keyword">uint32_t</span>) (off) &gt;&gt; <span class="number">16</span>;		\</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个macro帮我们设置了IDT的Gate。</p>
<p>于是，根据前面对TRAPHANDLER_NOEC与TRAPHANDLER的描述以及SETGATE，写trap_init如下：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/96169964.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/5194488.jpg" alt=""></p>
<p>接下来考虑_alltraps。根据提示，写出如下代码：</p>
<p>提示信息：</p>
<p>Your _alltraps should: </p>
<pre><code>1. push values to make the stack look like a struct Trapframe
2. load GD_KD into %ds and %es
3. pushl %esp to pass a pointer to the Trapframe as an argument to trap()
4. call trap (can trap ever return?)
</code></pre><p>Consider using the pushal instruction; it fits nicely with the layout of the struct Trapframe. </p>
<p>代码：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/93817695.jpg" alt=""></p>
<p>进行makegrade检测：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/34710148.jpg" alt=""></p>
<p>Answer the following questions in your answers-lab3.txt: </p>
<pre><code>1. What is the purpose of having an individual handler function for each exception/interrupt? (i.e., if all exceptions/interrupts were delivered to the same handler, what feature that exists in the current implementation could not be provided?)

2. Did you have to do anything to make the user/softint program behave correctly? The grade script expects it to produce a general protection fault (trap 13), but softint&apos;s code says int $14. Why should this produce interrupt vector 13? What happens if the kernel actually allows softint&apos;s int $14 instruction to invoke the kernel&apos;s page fault handler (which is interrupt vector 14)?
</code></pre><p>回答：</p>
<ol>
<li><p>如果所有的中断都是一个响应函数，那么首先需要统一是不是要自动压栈errorcode，其次在SETGATE时就无法指定特权级，就不能为内核中断提供不同的保护。比如syscall允许用户程序产生，但是诸如divideerror等只可以由硬件产生，如果所有都是用同一个优先级，很容易被别有用心的用户程序取得内核权限。</p>
</li>
<li><p>pagefault14不允许用户程序直接发起，必须经由硬件产生。这种机制可以更好地保护内存。假如允许用户程序自己产生int14，则每引发一个缺页中断系统就需要分配一个虚拟页，可能会被恶意程序利用，使得内存崩溃。而int13则是general protection interrupt，保护自己不去管那些不允许用户自己产生的中断。<br>如果希望int14可以正常被用户程序直接产生，应该将其特权级设置为3.</p>
</li>
</ol>
<h2 id="Page-Faults-Breakpoints-Exceptions-and-System-Calls"><a href="#Page-Faults-Breakpoints-Exceptions-and-System-Calls" class="headerlink" title="Page Faults, Breakpoints Exceptions, and System Calls"></a>Page Faults, Breakpoints Exceptions, and System Calls</h2><h3 id="Handling-Page-Faults"><a href="#Handling-Page-Faults" class="headerlink" title="Handling Page Faults"></a>Handling Page Faults</h3><p>page fault是14号中断。当处理器捕获到14号中断的时候，它会在CR2中存储一个引起pagefault的线性地址。下面来处理这个中断。</p>
<p>在上一步分析到，在把es与ds分别都设置为GD_KD之后，这时调用trap函数，我们先来分析trap函数。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/42158612.jpg" alt=""></p>
<p>FL_IF是在inc/mmu.h中定义的中断标志。如果寄存器eflage中中断标志没有被置位，则不是一个中断。</p>
<p>在tf结构tf_cs的低位存储着优先级，假如优先级是3，则是在用户态。这时是无权处理中断函数的，应该<strong>首先升级成为内核态</strong>，然后再处理。<br>然后调用trap_diapatch，来分发处理各种不同的trap，处理完毕回来之后，如果没有什么异常就可以接着运行。</p>
<p>在trap_dispatch中添加下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(tf-&gt;tf_trapno==T_PGFLT)&#123;</div><div class="line">        page_fault_handler(tf);<span class="comment">//此时该函数尚未完成</span></div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这时去查看page_fault_handle，此函数尚未完成，但是对于用户态的trap已经给出了解决，可以看到一句代码<code>fault_va = rcr2();</code>。这就是前面提到的在CR2中储存引起pagefault的线性地址，随后的打印操作即可以打印出这事的信息。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/48273990.jpg" alt=""></p>
<h3 id="The-Breakpoint-Exception"><a href="#The-Breakpoint-Exception" class="headerlink" title="The Breakpoint Exception"></a>The Breakpoint Exception</h3><p>其实，breakpoint也只是一个异常，函数入口点的相关代码在前面都已经写出来了。<br>需要说的是，在我最早使用breakpoint作为该函数的名字时，运行<code>make run-breakpoint</code>一直不成功。如果breakpoint还有其他用处，希望可以发现。目前暂时搁置这个问题。</p>
<p>这里需要做的只是补充trap_dipatch，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == T_BRKPT) &#123;</div><div class="line">    monitor(tf);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Questions</p>
<pre><code>1. The break point test case will either generate a break point exception or a general protection fault depending on how you initialized the break point entry in the IDT (i.e., your call to SETGATE from trap_init). Why? How do you need to set it up in order to get the breakpoint exception to work as specified above and what incorrect setup would cause it to trigger a general protection fault?

2. What do you think is the point of these mechanisms, particularly in light of what the user/softint test program does?
</code></pre><p>回答：</p>
<ol>
<li><p>这个问题的答案与上一个相似。当特权级设置为0的时候，只允许硬件产生中断而不会允许用户自己去调用。</p>
</li>
<li><p>更好的保护机制。</p>
</li>
</ol>
<p>makegrade信息将在最后一同贴出。</p>
<h3 id="System-calls"><a href="#System-calls" class="headerlink" title="System calls"></a>System calls</h3><p>在JOS中，系统调用定义的中断号是48号，系统调用不能由硬件产生，因此需要允许用户程序来生成系统调用。这也是在SETGATE中最后一个参数是3的原因。system call在初步判断时与trap处理相同，但是处理过程更加复杂。应用程序将会把系统调用的号码以及参数放在寄存器里面，这样内核将不需要在用户环境的堆栈或指令流中找数据。sysno将会在寄存器eax之中，其他参数将会在edx , ecx , ebx , edi , esi之中。返回时的返回值将会存在eax之中。</p>
<p>首先查看<code>lib/syscall.c</code>，syscall的代码以及对应的汇编代码如下：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/41487023.jpg" alt=""></p>
<p>补充<code>kern/syscall.c</code>以及<code>kern/trap.c</code>，代码如下：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/24297553.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/69032262.jpg" alt=""></p>
<p>这里需要提出的是，在<code>kern/syscall.c</code>中有另一个未完成的函数<code>sys_cput</code>，这个函数要求检查内存是否可以被访问，而在后面的练习中有相关函数的补充，在这里先不贴出代码。</p>
<h3 id="User-mode-startup"><a href="#User-mode-startup" class="headerlink" title="User-mode startup"></a>User-mode startup</h3><p>用户程序开始运行时是在<code>lib/entry.S</code>，随后在<code>lib/libmain.c</code>中call libmain()。<br>在<code>lib/entry.S</code>中可以看到：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/45324538.jpg" alt=""></p>
<p>envs已经被定义了，因此下面进入<code>lib/libmain.c</code>来初始化thisenv。根据提示，查看<code>inc/env.h</code>中的ENVX，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ENVX(envid)     ((envid) &amp; (NENV - 1))</span></div></pre></td></tr></table></figure>
<p>为了得到当前的进程号，可以调用在<code>kern/syscall.c</code>中的<code>sys_getenvid</code>函数，该函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">envid_t</span></div><div class="line">sys_getenvid(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> curenv-&gt;env_id;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是，根据<code>inc/env.h</code>，env_id并不是一个完全的envs中的序号，</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/22708337.jpg" alt=""></p>
<p>根据注释，ENVX(eid)才是真正在envs中的偏移，于是，在libmain中的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">thisenv = envs+ENVX(sys_getenvid());</div></pre></td></tr></table></figure>
<p>其实，只有在这部分完成之后，才能正确的调用用户函数。这是因为在退出时需要访问thisenv-&gt;env_id，而先前这个变量并没有值。</p>
<p>在用户程序执行完成之后，就会调用<code>sys_env_destory</code>来退出自己。</p>
<h3 id="Page-faults-and-memory-protection"><a href="#Page-faults-and-memory-protection" class="headerlink" title="Page faults and memory protection"></a>Page faults and memory protection</h3><p>内存保护是操作系统的一个重要特性，确保一个程序中的错误不会破坏其他程序或破坏OS本身。OS通常依赖于硬件来保护自己，他知道哪块虚拟地址可用，哪块不可用，如果一个程序想要访问他没有权限访问的地址，会引发错误。如果这个错误可以被解决，OS会试图解决，如果不能解决，犯错的进程就不可以再运行了。</p>
<p>系统调用为内存保护提出了一个有趣的问题。大多数系统调用接口让用户程序将指针传递给内核。这些指针指向要读取或写入的用户缓冲区。内核然后在执行系统调用的时候去引用这些指针。这有两个问题：</p>
<p>1.内核中的页面错误可能比用户程序中的页面错误严重得多。如果内核页面在处理自己的数据结构的时候出错，这是一个内核错误，而且错误处理程序应该让内核（也就是整个系统）崩溃。但是当内核解引用用户程序给它的指针时，它需要一种方法来记住任何页面错误，这些解除引用实际上是代表用户程序。</p>
<p>2.内核通常拥有比用户程序更多的内存权限。用户程序可能会传递一个指向系统调用的指针，指向内核可以读或写的内存，但是程序不能。内核必须小心，不要被欺骗引用这样一个指针，因为这可能会泄露私有信息或破坏内核的完整性。</p>
<p>下面将处理对用户读写指针的访问权限处理，如果用户想要读写的地方表示允许，就允许，否则不允许。而内核，如果出现了page fault，立即崩溃。</p>
<p>在<code>kern/trap.c</code>中添加对内核发生了pagefault的处理，这也是上面提到的尚未完成的操作。<br>根据提示，由于tf_cs中的低位代表特权级，直接查看特权级：如果不是在用户态发生的，就直接panic。<br>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ((tf-&gt;tf_cs&amp;<span class="number">3</span>) == <span class="number">0</span>)</div><div class="line">    panic(<span class="string">"Kernel page fault!"</span>);</div></pre></td></tr></table></figure>
<p>接下来对<code>kern/pmap.c</code>中的<code>user_mem_check</code>以及<code>user_mem_assert</code>进行操作：</p>
<p>只需要按照说明检查内存中位置以及PTE_P和PTE_U等即可，直接贴出代码：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/79810310.jpg" alt=""></p>
<p>下面是<code>user_mem_assert</code>的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//检查进程env是不是允许访问这个区域</span></div><div class="line"><span class="comment">//如果可以就return</span></div><div class="line"><span class="comment">//不行的话env就死了，如果env是当前运行进程，就不返回了</span></div><div class="line"><span class="comment">//user_mem_check</span></div><div class="line"><span class="keyword">void</span></div><div class="line">user_mem_assert(struct Env *env, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len, <span class="keyword">int</span> perm)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span> (user_mem_check(env, va, len, perm | PTE_U) &lt; <span class="number">0</span>) &#123;</div><div class="line">		cprintf(<span class="string">"[%08x] user_mem_check assertion failure for "</span></div><div class="line">			<span class="string">"va %08x\n"</span>, env-&gt;env_id, user_mem_check_addr);</div><div class="line">		env_destroy(env);	<span class="comment">// may not return</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，对在实验1中写过的debuginfo_eip进行更改，使得backtrace可以使用。<br>将代码贴出：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/326256.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/93317967.jpg" alt=""></p>
<p>本实验的基础部分到这里结束。</p>
<p>最终的makegrade：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/36947975.jpg" alt=""></p>
<p>CHALLENGE：</p>
<p>完成了单步执行的challenge。</p>
<p>根据提示，查找EFLAGS信息，得到这样的信息：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/4368506.jpg" alt=""></p>
<p>于是为了能够单步执行，z在monitor中修改如下部分：</p>
<ol>
<li>添加指令si</li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/34291928.jpg" alt=""></p>
<ol>
<li>写函数mon_si并在.h中声明（声明略去）</li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/78360085.jpg" alt=""></p>
<ol>
<li>修改kern/trap.c，使得能够处理debug的中断信息</li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/25025088.jpg" alt=""></p>
<p>运行：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/52901081.jpg" alt=""></p>
<p>类似的，就可以加上c指令使继续运行到下一个breakpoint。</p>
<ol>
<li><p>添加指令c </p>
</li>
<li><p>写函数mon_c</p>
</li>
</ol>
<p>只是，这时需要将TF位置为0。</p>
<p>结果：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/25564738.jpg" alt=""></p>
<p>为了更好地查看si与c的结果，我将breakpoint.c修改为下：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/1130654.jpg" alt=""></p>
<p>最后，再次运行make grade：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/12202433.jpg" alt=""></p>
<p>本实验完成。代码已经提交到git.mobisys.cc。</p>
<p><a href="https://note.youdao.com/share/?id=940fc869a8dc1daa06e9e955495a80c6&amp;type=notebook#/EE533F3CCE0E4E579776693DB25883E1" target="_blank" rel="external">点击链接预览lab3工程代码~</a></p>
<p><a href="https://pan.baidu.com/s/1bppVmR9" target="_blank" rel="external">如果想要直接下载的话就点这个（这是百度的网盘）</a></p>
<p>yayi2456  &lt;(￣︶￣)↗[GO!]&gt;</p>
<p>最后，列出那些给过我帮助的网站！谢谢！（也便于我以后找到！</p>
<p><a href="https://github.com/Clann24/jos/" target="_blank" rel="external">一个学霸的自我修养 clann24</a></p>
<p>clann的实际代码与README代码不一样啊，而且明明clann的自己可以运行，加到我的代码上却不能运行了。<br>对clann的load_icode存疑。</p>
<p><a href="http://blog.csdn.net/woxiaohahaa/article/details/50550208" target="_blank" rel="external">朴实中透露着惊喜 mick_seu</a></p>
<p>可以说是很厉害了。代码简单易懂，正确率超高，超适用。</p>
<p><a href="https://www.kancloud.cn/wizardforcel/jos-lab/97520" target="_blank" rel="external">学习并快乐着 飞龙</a></p>
<p>飞龙的代码也很简单易懂！而且一看就是自己写的，与网上主流的都不一样。</p>
<p><a href="http://blog.163.com/tianhail@126/blog/static/140395915201021643354880/" target="_blank" rel="external">X86 CPU的EFLAGS寄存器各个标识位  伊凡</a></p>
<p><a href="https://stackoverflow.com/questions/1406783/how-to-read-and-write-x86-flags-registers-directly" target="_blank" rel="external">How to read and write x86 flags registers directly? stackoverflow</a></p>
<p>我需要BB一句。到了OS课的该是大三了。stackoverflow这个社区真的是强推，无数问题都是在这个社区找到的回答。嗯，强推。</p>
<p><a href="https://markdowntohtml.com/" target="_blank" rel="external">markdown to html md转html在线</a></p>
<p>emm其实效果一般…很不好….但是，毕竟在线，不想用的话，自己安装pandoc，费劲费空间。</p>
<p><a href="http://www.atool.org/html2markdown.php" target="_blank" rel="external">另外一个html与md</a></p>
<p><a href="http://www.oschina.net/question/100267_75314" target="_blank" rel="external">markdown的chrome插件</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
<div>
  
</div>

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/27/OS/OS4+Memory and Process/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YaYi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Be With Me">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/27/OS/OS4+Memory and Process/" itemprop="url">串讲复习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-27T19:00:00+08:00">
                2017-11-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/MIT-Lab/" itemprop="url" rel="index">
                    <span itemprop="name">MIT Lab</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p><strong>例：STL的实现</strong><br>printf：<br>对屏幕：</p>
<ol>
<li>在每一个像素有一种颜色</li>
<li>文本模式</li>
</ol>
<h2 id="系统调用与函数调用"><a href="#系统调用与函数调用" class="headerlink" title="系统调用与函数调用"></a>系统调用与函数调用</h2><p>系统调用是中断，相当于在用户程序执行的过程中嵌入一段由OS完成的代码，完成后再返回用户程序。其中，包括特权级的升降。在进行系统调用的过程中，进入之后首先会检查用户传参是否有危险，随后再执行系统调用。这将在一个新的页完成，存在于<strong>内核态独立地址空间</strong>，将会带来包括TLB，Cache等的一系列问题。因此，系统调用的代价比函数调用的代价大得多。</p>
<h1 id="进程间的通信"><a href="#进程间的通信" class="headerlink" title="进程间的通信"></a>进程间的通信</h1><h2 id="直接通信与间接通信"><a href="#直接通信与间接通信" class="headerlink" title="直接通信与间接通信"></a>直接通信与间接通信</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">send(A,)</div></pre></td></tr></table></figure>
<h2 id="阻塞通信与非阻塞通信"><a href="#阻塞通信与非阻塞通信" class="headerlink" title="阻塞通信与非阻塞通信"></a>阻塞通信与非阻塞通信</h2><p>像网络中那样，阻塞通信就是//</p>
<h2 id="通信链路缓冲"><a href="#通信链路缓冲" class="headerlink" title="通信链路缓冲"></a>通信链路缓冲</h2><p><strong>0容量</strong>：发送方需要等待接收方<br><strong>有限容量</strong>：<br><strong>无限容量</strong>：</p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号类似于中段，</p>
<p>是最原始、最简单的一个进程间交互的模式。在关机时，系统将会用这种方式通知各各进程。</p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>父子之间传递信息</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>类似于电子邮件系统。</p>
<p>得到一个队列，使用队列号来标识。此后消息的send与recv都通过这个队列。</p>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>创建共享段<code>shmget(key,size,flags)</code>。其中key是其他人希望与你共享内存的话必须知道的值。<code>shmat(shmid,*shmaddr,flags)</code>把共享段映射到进程地址空间。</p>
<p>在这里，将又会遇到在“哲学家就餐”那部分的问题。另外，还将会有在cache还是内存的问题。cache作为在读写操作时第一个碰到的硬件，是否可以保证进程A写的时候吧东西写进了共享区的物理内存？在B不能使用的时候它的Cache的正确性哈能不能保证？—？</p>
<p>由一个“可否使用cache”的位</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
<div>
  
</div>

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/21/计算机网络/计算机网络概述/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YaYi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Be With Me">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/21/计算机网络/计算机网络概述/" itemprop="url">计算机网络概述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-21T21:51:40+08:00">
                2017-11-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/大三的课/" itemprop="url" rel="index">
                    <span itemprop="name">大三的课</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <p>这是第一次课！时隔许久，也算是复习啦~</p>
<p>#</p>
<h1 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h1><h1 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h1><h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><p>在各种网络之中，端对端之间互相传送<strong>报文</strong>。为了从源系统项目地端系统发送报文，源端系统将报文分成若干的小数据块，成为<strong>分组</strong>。每个分组都通过源端系统与目的端系统之间的<strong>分组交换机</strong>（主要是<strong>路由器</strong>以及<strong>链路交换机</strong>）传送。分组以等于链路最大传输速率的速度通过通信链路，因此如果传输速度是R比特/s，那么传输L比特分组的时间是L/R比特/s。</p>
<h3 id="存储转发传输"><a href="#存储转发传输" class="headerlink" title="存储转发传输"></a>存储转发传输</h3><p>多数分组交换机在链路的输入端使用<strong>存储转发传输</strong>机制，它是指在交换机开始发送第一个比特之前，必须接收到整个分组。</p>
<p>我们看一个例子：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-22/26732713.jpg" alt=""></p>
<p>如果发送方要传送长是L的报文，两条链路传输速率都是Rbit/s，那么到达路由器之前不能转发，首先浪费了L/R s，这时全部到达了，然后转发出去，一共花费了2L/R。（没有考虑线路长度）</p>
<p>而如果数据一旦到达路由器就转发而不用等到全部到达，只需要L/R的时间。</p>
<p>现在计算发送三个分组，从源发送第一个分组到达目的地接收到全部三个分组的时间：<br>在L/R，第一个分组被转发出去，这时源也开始发出第二个分组，2L/R，第一个已经被路由器转发完毕，目的端收到，路由器开始接收第三个分组，源开始发送第三个分组，3L/R，路由器接收第三个分组完成，第二个分组已经送出去被目的接收到，源端发送完毕，4L/R第三个分组完全传送出去，目的端接收到第三个分组。一共4L/R时间。</p>
<p>考虑N条速率均为R的链路（所以一共有N-1个路由器），发送一个分组所需时间是$t=N*\frac{L}{R}$。</p>
<p>如果像上面一样分组发送：</p>
<p>一个长度L的包一次发出去，时间是$t=N*\frac{L}{R}$，如果分成c组，时间为：$t`=(c+N-1)*\frac{L}{c*R}$！！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
<div>
  
</div>

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/15/简单udp通信实现-java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YaYi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Be With Me">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/15/简单udp通信实现-java/" itemprop="url">网络编程一：UDP,CMD,TCP,WebServer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-15T22:12:40+08:00">
                2017-11-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/大三的课/" itemprop="url" rel="index">
                    <span itemprop="name">大三的课</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/大三的课/作业/" itemprop="url" rel="index">
                    <span itemprop="name">作业</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="UDP-CMD"><a href="#UDP-CMD" class="headerlink" title="UDP CMD"></a>UDP CMD</h1><p>今天写webserver的时候发现需要用到以前写的一些程序的知识。所以觉得最好总结一下。</p>
<p>woaibianyi,bianyibangwojiejueledaiamdewenti.xieixeni.</p>
<p>感觉像是…识别不出\n…行吧，myplace myrule，//必须以;结尾！</p>
<h2 id="UDP介绍"><a href="#UDP介绍" class="headerlink" title="UDP介绍"></a>UDP介绍</h2><p>UDP通信使用两个类：<strong>DatagramPacket</strong>与<strong>DatagramSocket</strong>。前者是对UDP包的一个封装，后者是完成两端之间的交流。<br>在UDP里面Server与Client地位同等，彼此没有区分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">DatagramPacket packet=<span class="keyword">new</span> DatagramPacket(buff,buff.length,addr,port);<span class="comment">//发送包;</span></div><div class="line">DatagramPacket packet=<span class="keyword">new</span> DatagramPacket(buff,buff.length);<span class="comment">//接收包;</span></div><div class="line">DatagramSocket socket=<span class="keyword">new</span> DatagramSocket(port);<span class="comment">//指定端口号的socket;</span></div><div class="line">DatagramSocket socket=<span class="keyword">new</span> DatagramSocket();<span class="comment">//自动分配一个可用端口号;</span></div></pre></td></tr></table></figure>
<p>不得不说端口号与进程、socket之间的关系：端口号与进程毛关系没有。一个udp socket只能绑一个端口，一个port只能被一个socket绑。这个原因是在多路复用与多路分解讲到的。否则不知道pck究竟该给谁。</p>
<h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><h3 id="Server的ip获取；获取client的ip与port"><a href="#Server的ip获取；获取client的ip与port" class="headerlink" title="Server的ip获取；获取client的ip与port"></a>Server的ip获取；获取client的ip与port</h3><p><strong>Server端获取Server的ip与port</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">InetAddress.getLocalHost();<span class="comment">//ip获取;</span></div><div class="line">socket.getLocalPort();<span class="comment">//socket绑定的port获取;</span></div></pre></td></tr></table></figure>
<p><strong>Server端获取Client的ip与port</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//pck是从client接收到的包;</span></div><div class="line">pck.getAddress();<span class="comment">//;</span></div><div class="line">pck.getPort();<span class="comment">//;</span></div></pre></td></tr></table></figure>
<h3 id="时间获取"><a href="#时间获取" class="headerlink" title="时间获取"></a>时间获取</h3><ol>
<li>定义：<code>Calendar cal;</code></li>
<li>每次获取时间前都应执行：<code>cal= Calendar.getInstance();</code></li>
<li>获取常用的数据：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> year = cal.get(Calendar.YEAR);</div><div class="line"><span class="keyword">int</span> month=cal.get(Calendar.MONTH)+<span class="number">1</span>;</div><div class="line"><span class="keyword">int</span> day=cal.get(Calendar.DATE);</div><div class="line"><span class="keyword">int</span> week = cal.get(Calendar.DAY_OF_WEEK)-<span class="number">1</span>;</div><div class="line"><span class="keyword">int</span> hour=cal.get(Calendar.HOUR_OF_DAY);</div><div class="line"><span class="keyword">int</span> minute=cal.get(Calendar.MINUTE);</div><div class="line"><span class="keyword">int</span> second=cal.get(Calendar.SECOND);</div></pre></td></tr></table></figure>
<h3 id="使用其他类访问同一可视化界面"><a href="#使用其他类访问同一可视化界面" class="headerlink" title="使用其他类访问同一可视化界面"></a>使用其他类访问同一可视化界面</h3><p>以本程序为例，在主类中创建了一个可视化界面，希望在Time类访问可视化界面的一个label：</p>
<p><strong>在Time类创建一个label，使用主类的label初始化这个label</strong>。</p>
<h3 id="主方法：监听client请求"><a href="#主方法：监听client请求" class="headerlink" title="主方法：监听client请求"></a>主方法：监听client请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">DatagramSocket socket=<span class="keyword">new</span> DatagramSocket(<span class="number">4444</span>);<span class="comment">//固定的一个socket，绑定固定的port;</span></div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">    <span class="keyword">byte</span>[]buff=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">256</span>];<span class="comment">//输入缓冲区;</span></div><div class="line">    DatagramPacket pck=<span class="keyword">new</span> DatagramPacket(buff,buff.length);<span class="comment">//每次都新建一个包，否则会产生缓冲区不干净发送数据错误的问题;</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        server.log.setText(server.log.getText()+<span class="string">"\ni'm at "</span>+InetAddress.getLocalHost()+<span class="string">" "</span>+socket.getLocalPort()+<span class="string">" and listenning~\n"</span>);</div><div class="line">        server.log.setCaretPosition(server.log.getText().length());<span class="comment">//设置目前的光标位置，在可视化界面具体讲;</span></div><div class="line">        socket.receive(pck);<span class="comment">//接收数据包：阻塞方法;</span></div><div class="line">        server.log.setText(server.log.getText()+<span class="string">"i've get a request from "</span>+pck.getAddress()+<span class="string">" "</span>+pck.getPort()+<span class="string">" "</span>+<span class="keyword">new</span> String(pck.getData())+<span class="string">"\n"</span>);<span class="comment">//;</span></div><div class="line">        server.log.setCaretPosition(server.log.getText().length());</div><div class="line">        Server newserver=<span class="keyword">new</span> Server(<span class="keyword">new</span> String(pck.getData()),pck,server);<span class="comment">//新开一个线程，专门负责与这个client的通信;</span></div><div class="line">        <span class="keyword">new</span> Thread(newserver).start();<span class="comment">//新线程开始运行;</span></div><div class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            <span class="comment">// TODO Auto-generated catch block;</span></div><div class="line">         e.printStackTrace();</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>pck.getData();</code>:获取pck包的data信息;<br><code>pck.getAddress();</code>获取包的源地址<br><code>pck.getPort();</code>获取包的源端口</p>
<p><code>InetAddress.getLocalHost();</code>:获取本地ip，可能抛出异常，需要处理<br><code>socket.getLocalPort();</code>获取socket绑定的端口号</p>
<p><code>socket.receive(pck);</code>:等待接收一个包<br><code>socket.send(pck);</code>:发送一个包</p>
<h3 id="String与Unix时间戳之间的转换"><a href="#String与Unix时间戳之间的转换" class="headerlink" title="String与Unix时间戳之间的转换"></a>String与Unix时间戳之间的转换</h3><p>format函数之中是一个Date对象，这个Date对象由一个long构造：list[i]是File类型。也许会说“过时”，没关系，这一整句代码打上去就不会提示了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String dates=<span class="keyword">new</span> java.text.SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(<span class="keyword">new</span> java.util.Date(list[i].lastModified()));</div></pre></td></tr></table></figure>
<p>多说一句SimpleDateFormat：</p>
<p> G 年代标志符<br>  y 年<br>  M 月<br>  d 日<br>  h 时 在上午或下午 (1~12)<br>  H 时 在一天中 (0~23)<br>  m 分<br>  s 秒<br>  S 毫秒<br>  E 星期<br>  D 一年中的第几天<br>  F 一月中第几个星期几<br>  w 一年中第几个星期<br>  W 一月中第几个星期<br>  a 上午 / 下午 标记符<br>  k 时 在一天中 (1~24)<br>  K 时 在上午或下午 (0~11)<br>  z 时区</p>
<p>可以说是十分实用了。</p>
<p>具体信息可以访问<a href="http://blog.csdn.net/gubaohua/article/details/575488" target="_blank" rel="external">这里：SimpleDateFormat使用详解</a></p>
<h3 id="获取本地文件信息"><a href="#获取本地文件信息" class="headerlink" title="获取本地文件信息"></a>获取本地文件信息</h3><p><strong>注意</strong>：没有解决的一个问题：包最后一定会用ASCII为0的char填充满255个，注意！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">File f=<span class="keyword">new</span> File(dirpath);</div><div class="line">File[] list=<span class="keyword">null</span>;</div><div class="line"><span class="keyword">if</span>(f.isDirectory())&#123;</div><div class="line">    list=f.listFiles();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取文件名信息：<code>list[0].getName();</code><br>是否文件？是否目录？:<code>list[0].isFile();list[0].isDirectory();</code><br>还有一系列方法：自己发现吧！</p>
<p>Server的java代码<a href="http://note.youdao.com/noteshare?id=de6b0e25562da7949d1b1b8a51ae865c&amp;sub=E0E99B97DC7A4AAEB00CC82204E767BC" target="_blank" rel="external">看这里</a></p>
<h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><h3 id="client的ip获取"><a href="#client的ip获取" class="headerlink" title="client的ip获取"></a>client的ip获取</h3><p><code>InetAddress.getLocalHost();</code>与Server差不多</p>
<h3 id="设置最大时延"><a href="#设置最大时延" class="headerlink" title="设置最大时延"></a>设置最大时延</h3><p>送出一个包：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">DatagramSocket socket=<span class="keyword">new</span> DatagramSocket();</div><div class="line">socket.setSoTimeout(<span class="number">10000</span>);</div><div class="line">socket.send(pck);</div></pre></td></tr></table></figure>
<p>新开一个线程中：等待接收一旦超时触发异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    socket.receive(pck);</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span>(SocketTimeoutException e)&#123;</div><div class="line">    e.printStackTrace();</div><div class="line">    ori=ori+<span class="string">"timeout!:"</span>+socket.getInetAddress()+<span class="string">" for "</span>+pck.getData().toString()+<span class="string">" has no response . try again!\n"</span>;</div><div class="line">    clientthis.tf.setText(ori);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用String设置指定IP"><a href="#使用String设置指定IP" class="headerlink" title="使用String设置指定IP"></a>使用String设置指定IP</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    <span class="keyword">int</span>[]ipaddr=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</div><div class="line">    String[] ipsplit=<span class="keyword">new</span> String[<span class="number">4</span>];</div><div class="line">    data=data.replace(<span class="string">'.'</span>, <span class="string">'-'</span>);</div><div class="line">    ipsplit=data.split(<span class="string">"-"</span>);<span class="comment">//这两步是当时不懂正则，使的一个小手段;</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(ipsplit[i]!=<span class="keyword">null</span> &amp;&amp; ipsplit[i].isEmpty())&#123;</div><div class="line">        cmd.setText(cmd.getText()+<span class="string">"format of ip addr wrong!split by .\n&gt;"</span>);</div><div class="line">        rows++;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    ipaddr[i]=Integer.parseInt(ipsplit[i]);</div><div class="line">    &#125;<span class="comment">//前面是为了验证给定的string是符合要求的int.int.int.int形式;</span></div><div class="line">    <span class="comment">//得到正确的ip;</span></div><div class="line">   <span class="comment">//转化为byte流;</span></div><div class="line">    <span class="keyword">byte</span>[]byteaddr=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</div><div class="line">    byteaddr[<span class="number">0</span>]=(<span class="keyword">byte</span>)ipaddr[<span class="number">0</span>];</div><div class="line">    byteaddr[<span class="number">1</span>]=(<span class="keyword">byte</span>)ipaddr[<span class="number">1</span>];</div><div class="line">    byteaddr[<span class="number">2</span>]=(<span class="keyword">byte</span>)ipaddr[<span class="number">2</span>];</div><div class="line">    byteaddr[<span class="number">3</span>]=(<span class="keyword">byte</span>)ipaddr[<span class="number">3</span>];</div><div class="line">    <span class="comment">//设置新ip;</span></div><div class="line">    addr=InetAddress.getByAddress(byteaddr);</div><div class="line">    System.out.println(data);</div><div class="line">    cmd.setText(cmd.getText()+<span class="string">"&gt;"</span>);<span class="comment">//先忽略就好;</span></div><div class="line">&#125;<span class="keyword">catch</span>(NumberFormatException e)&#123;<span class="comment">//根本不符合格式;</span></div><div class="line">    e.printStackTrace();</div><div class="line">    cmd.setText(cmd.getText()+<span class="string">" wrong:"</span>+command.substring(<span class="number">7</span>)+<span class="string">"wrong format of ip addr! split by . and only numbers are accept\n&gt;"</span>);</div><div class="line">    rows++;</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span>(UnknownHostException he)&#123;<span class="comment">//;</span></div><div class="line">    he.printStackTrace();</div><div class="line">    cmd.setText(cmd.getText()+<span class="string">"unknown host\n&gt;"</span>);</div><div class="line">    rows++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>client代码<a href="http://note.youdao.com/noteshare?id=45d994163c92b945960698ea27100a1b&amp;sub=3AE87C2D6AF44F2BA331DB9C7904A210" target="_blank" rel="external">看这里</a></p>
<h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><p>可视化部分也在上面的client代码里面。</p>
<h1 id="TCP-WebServer"><a href="#TCP-WebServer" class="headerlink" title="TCP WebServer"></a>TCP WebServer</h1><p>这是第二次作业，使用TCP，利用http1.1，实现一个可以与浏览器进行交互的小型的WebServer。</p>
<p>附加：tcp部分编码设置</p>
<p>String code=”utf-8”;<br>        try {<br>            InputStream instream= new java.io.FileInputStream(file);<br>            byte[] b = new byte[3];<br>            instream.read(b);<br>            instream.close();<br>            if (b[0] == -17 &amp;&amp; b[1] == -69 &amp;&amp; b[2] == -65)code=”utf-8”;<br>            else code=”GBK”;<br>        } catch (IOException e) {<br>            // TODO Auto-generated catch block<br>            e.printStackTrace();<br>        }<br>        return code;</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
<div>
  
</div>

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/14/OS/实验串讲/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YaYi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Be With Me">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/14/OS/实验串讲/" itemprop="url">OS-各实验初讲</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-14T22:05:33+08:00">
                2017-11-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/MIT-Lab/" itemprop="url" rel="index">
                    <span itemprop="name">MIT Lab</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Lab3：User-Environment"><a href="#Lab3：User-Environment" class="headerlink" title="Lab3：User Environment"></a>Lab3：User Environment</h1><h2 id="Pre：实验准备知识"><a href="#Pre：实验准备知识" class="headerlink" title="Pre：实验准备知识"></a>Pre：实验准备知识</h2><h3 id="GCC内联汇编"><a href="#GCC内联汇编" class="headerlink" title="GCC内联汇编"></a>GCC内联汇编</h3><h3 id="特权降级"><a href="#特权降级" class="headerlink" title="特权降级"></a>特权降级</h3><h4 id="基础知识准备"><a href="#基础知识准备" class="headerlink" title="基础知识准备"></a>基础知识准备</h4><p>切换到保护模式之后就会有不同的特权等级，这时默认在最高的特权等级上。这个时候为内核建立了页表结构，接下来将会跳转到用户程序。进行跳转的时候，应该注意：不可以再留着这个高级的运行权限了，因此需要进行特权级的降级。</p>
<p>系统在以上电时，各个资源管理都还没有建立，这个时候处于特权管理模式，在特权模式建立完毕所有的资源映射之后，再降级到通用模式，运行。</p>
<p>因此，一上电运行的指令一旦被不安全的程序接管，将不会降级，保护措施将形同虚设。因此，在智能手机等终端上都有一个叫做trustdo(?)的硬件，它是一个加密的模块，这个模块是系统上电之后运行的第一段代码，作用是验证将要运行的这段代码是不是被授权的，数字签名是否通过，若通过才会运行。trustdo会被做到CPU的芯片中，保证了即使上电后处于特权模式的代码是安全可靠的。</p>
<hr>
<p><strong>iret</strong>：系统指令，从中断中返回。<br><strong>ret</strong>：从函数中返回<br><strong>retf</strong>：与ret基本一样，从函数中返回。（弹出栈，拿出返回地址（就是下一条语句）返回值，丢掉压栈参数）</p>
<p>中断是一个硬件的事件，中断返回与函数返回不同。当一个中断来了，不管你当时在干嘛，就乖乖地保存一下现场去响应中断。这个<strong>保存现场</strong>，包括了硬件将会自动帮你保存的一些现场，比如CS、SS、Flag等等，这些是自动存下的，iret的作用就是自动地将这些东西都弹出。但是这些现场保存并不够，通用寄存器是不会帮你保存的。</p>
<p>ret、iret等等在汇编之中可以随意调用，并不需要其他约束。如果当你在汇编中不是函数（中断）的里面调用了这些，它会干些什么呢？<br>他会把自己认为的自己保存进去的那些东西弹出来，一个是返回地址给PC，一个是返回值给保存返回值的东西。即使没有调用函数，ret的行为也是固定的：<strong>从栈顶弹出两个值，一个给PC，一个给存储返回值的东西</strong>，iret的行为也是固定的，就是从栈顶弹出东西给那些变量。<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-14/87170051.jpg" alt=""><br>这就是保护现场之后的栈。<br>ret是弹出到eip，retf弹出到CS，iret弹出到CS（代码段）、EFLAGS，根据是否改变特权等级，iret会连下面的SS以及esp一起弹出来。</p>
<p>这样，如果一个程序在栈中事先在栈中存了一些数据，然后调用了iret，iret不管栈中究竟是什么，就会弹出5（3）个元素，给对应的寄存器。ret和retf也类似。因此，在汇编中ret们与高级语言的return们的作用不同，汇编中的ret们只是<strong>提供了一个批量修改寄存器的方法</strong>。</p>
<p>系统中有两种中断。中断可能在任意时间发生。在用户模式下与在特权模式下中断发生后系统的动作是不相同的。</p>
<p>在用户模式下，系统会保存这些东西：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-14/4474675.jpg" alt=""><br>还记得在“内存管理”的lab里面讲过的<strong>段选择子</strong>，其中有两个bit标识自己处在什么特权模式下的特权位。这里面有两个段选择子，一个是栈的，一个是代码段的，由于在用户模式下，可以看到CS代码段选择子与SS栈选择子的特权位RPL都是3。</p>
<p>在特权模式下，一旦发生中断：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-14/84089468.jpg" alt=""><br>这时保存的东西比较少。</p>
<p>无论在哪种模式下一旦调用iret，就把这些东西（其实不一定是这些东西，只是对应栈顶的几个数据）弹出去给对应的寄存器。</p>
<h3 id="正题：特权降级"><a href="#正题：特权降级" class="headerlink" title="正题：特权降级"></a>正题：特权降级</h3><p>考虑做完lab2，系统在特权级是0的模式下，这是需要现将自己降级成为特权3的模式，再去运行用户程序。怎么降？</p>
<p>要伪造一个场景：刚刚一个用户程序产生了一个中断所以我升级了，现在我要中断返回。于是我去伪造了一个栈，在栈里头存上了iret希望的那5个数据，每一个是32位。然后调用iret，这些就会从栈中弹出来到达对应的寄存器，然后我就回到了用户模式，那两个段选择子的特权级值就被改为了3。<br>这里需要注意的是，系统原来使用的特权级是0的栈，iret之后这个栈空掉了，但是系统不再使用这个栈，而是重新为用户态开避了一个新的栈，这个栈不再是以前的那个栈了，这个栈放在用户空间的数据段里，它的权限也是3。</p>
<blockquote>
<p>为什么要这样设计呢？在特权模式下，系统并不想和特权级更低的用户态共用一个特权级更高的栈。另一个方面从安全考虑，为了防止用户态随意弹出数据随意插入数据破坏内核运行。</p>
</blockquote>
<p>从特权模式到达用户模式，新创建了一个栈给用户程序使用，这是在刚上电的时候，还没有用户程序运行。用户程序运行过程中可能会有系统调用回到特权模式下，这是将会使用前面提到的系统用的那个栈，系统调用完成之后，不会再为用户程序创建新的栈了，一是占空间，一是以前的运行态不能就这样丢掉。就还让它回到自己原来的栈。</p>
<h2 id="特权级提升"><a href="#特权级提升" class="headerlink" title="特权级提升"></a>特权级提升</h2><p>中断、异常、系统调用：我需要更高特权的东西帮帮我。</p>
<p>在80386中，系统调用就是一个中断。异常是需要紧急处理的中断。</p>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>在32位机器上的中断是一个很复杂的机制，因为那时保护模式已经建立了起来，整个运行在虚拟地址空间上。所以当中段发生的时候，系统使用<strong>中断描述符表</strong>，写着自己所有的中断号。<br>中断描述符寄存器（IDTR）中存的就是中断描述符表（IDT）在内存中的位置以及大小。表按照中断号排序，每一个中断描述符在80386中被叫做一个门，<strong>中断门</strong>（中断），<strong>陷阱门</strong>（异常）。会根z中断发生的编号从表中取出对应的描述符（门），<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-15/43120327.jpg" alt=""><br>取回的描述符是这样的：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-15/96785647.jpg" alt=""><br>segment selector与offset用来描述在段机制下自己的中断响应函数的位置。segment selector负责在GDT里面找到对应的段，offset负责找对应的偏移量。找到函数之后，保存现场并执行响应函数。</p>
<p>在终端发生的时候，系统将会看一下产生中断的程序的特权级，决定应该怎样保护现场。如果在特权状态，不用换栈，只需要保存更少的东西，而处于用户状态下的程序在执行完中断响应函数之后还要从（？）退回到自己的用户栈，保存了更多的东西。</p>
<h3 id="正题：特权级提升"><a href="#正题：特权级提升" class="headerlink" title="正题：特权级提升"></a>正题：特权级提升</h3><p>从特权模式3切换到特权模式0，实际上就是响应一个中断，这就是上面图中的trap。</p>
<p>对于用户程序，os并不信任。当trap发生时，当前用户程序的运行状态会被存入到<strong>内核栈</strong>中，而用户栈并没有变化。这也是中断与普通函数调用的不同。<br>现在已经进入了特权模式，如果不作任何操作，只是调用一个iret，前面讲到的CS，SS特权级3又会被写入到寄存器里面，就又回到了用户态。为了能留在特权模式下，对栈进行伪造，假装在进入终端之前就是一个特权模式：也就是把上面提到的用户态发生中断的栈信息修改成特权模式发生中断的栈信息。这时iret，就可以留在特权模式下。</p>
<p>但是：在伪造的时候，SS被扔掉了。怎么回去呢？80386提供了一个<strong>TSS任务状态段</strong>，它几乎可以存下CPU上所有的寄存器的不止一份拷贝。TSS每个进程一个，会存下一个进程在切换特权状态的时候原特权状态下的SS的值。系统将会自己对TSS进行维护，以确保切换模式时栈的跳转。</p>
<p>TSS存在于哪里呢？在GDT里面有一个TSS的描述符：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-15/80552651.jpg" alt=""></p>
<p>80386中有4个特权模式，目前在虚拟化技术下只是用了3个。</p>
<p>有一个叫做TSR的寄存器，存着selector、base addr以及segment limit。便于直接找到TSS。</p>
<p>如果想要回到用户模式，进入trap，伪造一个从用户态过来的栈，iret即可。</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>用户程序可以通过系统调用访问内核服务，这个过程需要指定中断号，使用tarp或者特殊指令（SYSENTER/SYSEXIT）实现。</p>
<h2 id="关于这次实验"><a href="#关于这次实验" class="headerlink" title="关于这次实验"></a>关于这次实验</h2><p>这里的env就是课上讲的pcb。<br>父子进程的一个作用是父进程要为子进程收尸。</p>
<p>elf格式：linux下的可执行。<br>创建进程并执行elf：没有文件系统怎么办？<br>把指定的文件链接进目标文件，骗bootloader把程序也搬进内存。</p>
<p>-b binary path:-b帮我搬进来。binary这是个可执行程序。<br>然后重生成一个符号表。<br>把这个文件作为一个大数组缀到最后，然后直接使用这个数组。</p>
<p>编码的时候，这个数组还没有，链接的时候才有，怎么办？定义一个外部变量extern。<br>只需知道生成符号表的规则，然后按规则命名即可。</p>
<p>进来之后还只是一个大数组，还需要经过链接之后映射要对应的虚拟地址才能执行。</p>
<h1 id="Lab4-Preemptive-Multitasking"><a href="#Lab4-Preemptive-Multitasking" class="headerlink" title="Lab4-Preemptive Multitasking"></a>Lab4-Preemptive Multitasking</h1><p>lab3做完之后，当一个进程结束之后，就退出。在这个实验中，主要完成的是</p>
<p>本次实验主要是决定：在何时利用什么原则什么地方切换进程。<br>上下文怎么切换？其中一项：一定要把页表换掉，也就是把cr3中的页目录项换掉。之后，连接tlb也会失效，处理流水线，吧上一个进程的东西全部清理掉。</p>
<p>本实验大部分代码都已经写完了，主要是读代码。</p>
<p>如何实现更加有效的调度？更加频繁的调用schedule_yeid。</p>
<p>时钟中断的作用：打断正在执行的程序，调用sched_yield进行进程轮转</p>
<p>在本次实验中有一个时钟中断，你要做的就是在这个时钟中断的响应函数之中做一些事情，决定下一个进程怎么上去谁会上去（就是我们学习过的调度算法）</p>
<h2 id="多核处理器"><a href="#多核处理器" class="headerlink" title="多核处理器"></a>多核处理器</h2><p>一开始是因为没有在一个进程运行的时候调用另一个进程的机制，本实验中的多核只是实验的设计者希望我们体验一下在系统中有多个进程活动是一个什么样的状态，因此鼓励你去多弄几个核心。<br>只要是单核，其实每一个时刻只能有一个进程运行。</p>
<p>为什么会有多核处理器出现呢？在后摩尔时代，为了提升处理器的处理能力。</p>
<p>主核会在系统上电之后接管机器，他们的地位并不是平等的。</p>
<h3 id="现代处理器的休眠唤醒机制"><a href="#现代处理器的休眠唤醒机制" class="headerlink" title="现代处理器的休眠唤醒机制"></a>现代处理器的休眠唤醒机制</h3><p>现代处理器的模式一般有三种：active,idol,sleeping</p>
<p>CPU在关闭的时候，内存并不会关闭。休眠时，找到一个调度点，这时不调度了，存好有用的东西，然后cpu耗电量就会变得非常低。有一个cpu中的寄存器会标志自己刚刚是休眠了还是关机了。如果是休眠，那么内存里面所有的东西都还在，只需要调到该去的地方，然后进行一轮新的调度；如果不是休眠而是关机了，内存中的东西就被清空了，就是上电启动过程。</p>
<p>有时手机会坏掉，就是在锁屏（休眠）之后也会重新起动，这也就是cpu中的那个寄存器坏掉了。</p>
<p>那么，如果帮一个休眠的cpu准备好了它的休眠位以及内存，就可以让它认为它是一个刚刚休眠的cpu。</p>
<p>bsp是主核，在系统上电之后是只有主核启动，直到系统启动完之后，直到需要另外一个核心运行一个进程，bsp帮ap制造一个它刚刚在休眠的假象，然后唤醒它，这样这个ap就会认为自己是刚刚休眠的，然后继续执行。运行完之后，主核就会选择把这个核心给关掉，然后省电。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
<div>
  
</div>

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/12/哈希/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YaYi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Be With Me">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/12/哈希/" itemprop="url">哈希</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-12T23:57:33+08:00">
                2017-11-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>emmm…大二的时候DS只考了80，出来混的，总是要还的。</p>
<h2 id="不希望文件太多都小于512k，会占我的空间。"><a href="#不希望文件太多都小于512k，会占我的空间。" class="headerlink" title="不希望文件太多都小于512k，会占我的空间。"></a>不希望文件太多都小于512k，会占我的空间。</h2><h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><p>哈希其实没什么神秘的，不过是一群贪心的人的产物。</p>
<p>散列函数，将key转化为对应的value值得到索引。这个有诸如<strong>取模</strong>，<strong>ASCII平均</strong>，等等方法。橙皮书上有一种sfold，似乎性能会更好一些。</p>
<h2 id="开哈希"><a href="#开哈希" class="headerlink" title="开哈希"></a>开哈希</h2><p>开哈希类似于静态链表，每一个value对应一个链表，成为挂着的桶。</p>
<h2 id="闭哈希"><a href="#闭哈希" class="headerlink" title="闭哈希"></a>闭哈希</h2><p>闭哈希将node存储在给定的一个数组中。这个数组的下标将作为value的索引值，由于value可能重复，需要探查方式，有很多方式，比如线性探查与二次探查。</p>
<p>关于闭哈希的删除，其实不必真的每次都向前挪，而是增加一个“墓碑”，它代表这里没有数据可以被插入，但是又不是真的空因为需要继续向前探查。<br>当次数多了性能就会下降，一种解决方式是向前挪，另一种是重新散列。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
<div>
  
</div>

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/12/语言们的输出格式控制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YaYi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Be With Me">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/12/语言们的输出格式控制/" itemprop="url">语言们的输出格式控制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-12T23:21:11+08:00">
                2017-11-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/语言/" itemprop="url" rel="index">
                    <span itemprop="name">语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.cnblogs.com/leewiki/archive/2011/12/13/2286168.html" target="_blank" rel="external">待整理</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
<div>
  
</div>

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/09/编译原理——词法分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YaYi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Be With Me">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/09/编译原理——词法分析/" itemprop="url">编译原理——词法分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-09T00:44:47+08:00">
                2017-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编译原理/" itemprop="url" rel="index">
                    <span itemprop="name">编译原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <p>我有罪….我先是用学编译的时间逛了淘宝….然后又用学编译的时间逛了六维…..我有罪….\infty</p>
<blockquote>
<p>时间：1012cp3 3:15开始 词法分析器介绍</p>
<p>编译并不是一件轻松的事情，对于较大的系统，编译的速度并不理想，这也是为什么我们需要优化编译技术。</p>
</blockquote>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>词法单元（单词）</strong>：由一个词法单元名以及一个可选的属性值组成。名即是语法分析器的输入符号token。<br><strong>模式</strong>：一个词法单元的词素可能具有的形式。一个词素不能与两个或多个词法单元进行匹配（二义性）。<br><strong>词素</strong>：源程序中的字符序列，是程序中实际出现的字符串。</p>
<blockquote>
<p>在lex与yacc中，有时会有一个全局变量。他保存了当前词素（词法单元：关于这里，龙书里面的和wg写的不一样呢？）的属性值，这个属性值可以被记录在语法树上。</p>
</blockquote>
<h2 id="词法分析器要干些什么？"><a href="#词法分析器要干些什么？" class="headerlink" title="词法分析器要干些什么？"></a>词法分析器要干些什么？</h2><p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-12/6339247.jpg" alt=""></p>
<ol>
<li>读入源程序字符，生成词素，确定词法单元序列</li>
<li>与符号表进行交互</li>
<li>过滤掉源程序中的<strong>注释</strong>与<strong>空白</strong></li>
<li>将编译器生成的错误信息与位置联系</li>
<li>预处理：扫描阶段完成不需要生成词法单元的简单处理；词法分析阶段处理扫描阶段的输出并生成词法单元</li>
</ol>
<blockquote>
<p>跳过了一些东西</p>
</blockquote>
<h1 id="正则表达式（正规表达式、正规式）"><a href="#正则表达式（正规表达式、正规式）" class="headerlink" title="正则表达式（正规表达式、正规式）"></a>正则表达式（正规表达式、正规式）</h1><p>为什么需要正则表达式来描述字符串序列呢？<br>像在上下文无关文法中所描述的那样，因为字符们所组成的可能的字符串是<strong>无穷</strong>的。</p>
<p>单词是什么？单词的本质就是<strong>符号串的集合</strong>。正则表达式就是代替了自然语言对特定符号串集合的描述。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>符号表</strong>：符号的有穷集合<br><strong>符号串</strong>：字母表中符号构成的有穷序列。也成<strong>句子</strong>，<strong>字</strong>。<strong>|s|</strong>代表<strong>字符串s的长度</strong>，$\epsilon$是空字符串。<br><strong>语言</strong>：是一个给定符号表上的特定的符号串的集合。</p>
<p>比如：给定符号表{1,0}，有符号串01100010，一种语言是{0，1，00，11，000，111….}即串中只含一种字符的字符串集合。</p>
<p>特例：$\varnothing$是<strong>空语言</strong>。{$\epsilon$}是只含空串的语言。</p>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="符号串的运算"><a href="#符号串的运算" class="headerlink" title="符号串的运算"></a>符号串的运算</h3><p><strong>连接</strong>：x=hou y=se xy=house    s$\epsilon$=$\epsilon$s=s  (emmmm说好的不能这样写呢？)<br><strong>幂</strong>：$s^n=s^(n-1) * s^1$</p>
<h3 id="语言的运算"><a href="#语言的运算" class="headerlink" title="语言的运算"></a>语言的运算</h3><p>下表中运算符的优先级由低到高</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算</th>
<th style="text-align:center">定义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">并</td>
<td style="text-align:center">$L\cup M={ s \ s\in L 或 s\in M} $</td>
</tr>
<tr>
<td style="text-align:center">交</td>
<td style="text-align:center">$LM={ st \ s\in L 且 t\in M} $</td>
</tr>
<tr>
<td style="text-align:center">Kleen闭包</td>
<td style="text-align:center">$L^*=\cup_{i=0}^\infty L^i$</td>
</tr>
<tr>
<td style="text-align:center">正则闭包</td>
<td style="text-align:center">$L^*=\cup_{i=1}^\infty L^i$</td>
</tr>
</tbody>
</table>
<p>$$\color{red}{正则表达式&lt;-&gt;语言运算的简洁描述}$$</p>
<h2 id="正则表达式定义"><a href="#正则表达式定义" class="headerlink" title="正则表达式定义"></a>正则表达式定义</h2><p>字母表$\sum$上的正规式r的定义规则，以及r所表示语言L(r)定义：</p>
<ol>
<li>$\epsilon$是正规式，表示语言{$\epsilon$}</li>
<li>若$a\in \sum$则a是正规式，表示语言{a}</li>
<li>r , s是正规式，表示语言L(r)与L(s)，则：<ol>
<li>(r)|(s)是正规式，表示语言L(r)$\cup$L(s)</li>
<li>(r)(s)是正规式，表示语言L(r)L(s)</li>
<li>$(r)^*$是正规式，表示语言$(L(r))^*$</li>
<li>(r)是正规式，表示语言L(r)</li>
</ol>
</li>
</ol>
<p>第三条的四条，优先级从上到下依次升高。</p>
<blockquote>
<p>$(a|b)^*$={所有由a、b组成的符号串}</p>
</blockquote>
<p>正规式<strong>等价</strong>：r=s &lt;-&gt; L(r)=L(s)</p>
<p>正则运算的特性:<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-12/3363060.jpg" alt=""></p>
<p>可以像产生式那样，为正规式指定名字：</p>
<blockquote>
<p>num -&gt; r1<br>其实，上下文无关文法的描述能力包含了正则表达式的描述能力。所有可以被正则表达式描述的都可以被上下文无关文法描述，但是正则表达式并不能描述某些上下文无关文法可以描述的东西。<br>那么为什么需要正则表达式来实现词法分析器？</p>
<ol>
<li>简化编译器的设计：使每一阶段需要做的事情更加简单清晰</li>
<li>提高编译器的效率：使用专门的字符缓冲技术提高编译速度</li>
<li>增强编译器的可移植性：输入设备相关的特殊性被限制在词法阶段</li>
</ol>
</blockquote>
<p>下面举一个例子：</p>
<blockquote>
<p>无符号整数：<br>digit -&gt; 0|1|2|…|9<br>digits -&gt; digit digit*  其实也可以是$digit^+$<br>optional_fraction -&gt; .digits | $\epsilon$<br>optional_exponent -&gt; (E(+|-|$\epsilon$)digits)|$\epsilon<br>num -&gt; digits optional_fraction optional_exponent</p>
</blockquote>
<p><strong>符号简写：</strong></p>
<p><strong>+</strong>:一个或多个实例<br><strong>?</strong>:0或1个实例：$r?=r|\epsilon$$\rightarrow$$L(r)\cup {\epsilon}$<br><strong>[]字符集</strong>:[abc]=&gt;a|b|c、[a-z0-9]=&gt;a|b|..|z|0|1..|9</p>
<h2 id="非正规集"><a href="#非正规集" class="headerlink" title="非正规集"></a>非正规集</h2><p><strong>正规式无法描述的语言</strong>：{wcw|w是a、b组成的字符串}正规式无法描述平衡或嵌套的结构<br><strong>正规式只能表示</strong>：有限的重复、一个给定结构的无限重复</p>
<p>关于正规式的练习，参考<a href="http://blank" target="_blank" rel="external">第三章练习</a></p>
<h1 id="Lex"><a href="#Lex" class="headerlink" title="Lex"></a>Lex</h1><p>使用流程与yacc类似。</p>
<p>$\color{red}{ATTENTION!</p>
<p>在使用project wizard建立lex的时候你写的那个词法分析器的名字就是那个名字，</p>
<p>你最好别自己再修改，否则在VS里面运行不出来！！！}$</p>
<p>给的是字符流，出来的是单词流。</p>
<p>规则段放正则表达式与语义动作。</p>
<p>第四次作业词法分析器设计将会上传。<a href="http://blank" target="_blank" rel="external">click here to get</a></p>
<h1 id="有限自动机"><a href="#有限自动机" class="headerlink" title="有限自动机"></a>有限自动机</h1><p>有限自动机可以直接转换成程序。</p>
<h2 id="NFA"><a href="#NFA" class="headerlink" title="NFA"></a>NFA</h2><h1 id="从正则表达式到自动机"><a href="#从正则表达式到自动机" class="headerlink" title="从正则表达式到自动机"></a>从正则表达式到自动机</h1><p>从这之后，正是lex所做的事情。</p>
<p>在这一节里，将介绍两个过程：一个是正则表达式到NFA，另一个是NFA到DFA。之所以让NFA做一个过渡，是因为正则表达式直接到DFA的算法很复杂。本次更新掠过。</p>
<p>NFA与DFA的性能差别很大：NFA占用空间比较少，但是使用NFA进行词法分析需要在错误态停止，可能需要花费$O(2^n)$的时间复杂度；DFA占用空间很大（最坏情况下$O(2^n)$），但是使用它进行词法分析的时候接近线性时间。</p>
<h2 id="正则-gt-NFA"><a href="#正则-gt-NFA" class="headerlink" title="正则 -&gt; NFA"></a>正则 -&gt; NFA</h2><p>正则表达式构造NFA使用<strong>MacMaughton-Yamada-Thompson算法</strong>。简称<strong>Thompson算法</strong>。这个算法描述如下：</p>
<p><strong>基本规则：</strong></p>
<h2 id="自动机运转"><a href="#自动机运转" class="headerlink" title="自动机运转"></a>自动机运转</h2><blockquote>
<p>s $\leftarrow$ e -closure({s0});<br>c $\leftarrow$ nextchar;<br>while c $\neq$ eof do<br> s $\leftarrow$ e -closure(d(s,c));<br> c $\leftarrow$ nextchar;<br>end;<br>if S$\cap$F$\neq$ $\varnothing$ then return “yes”<br>         else return “no”</p>
</blockquote>
<hr>
<blockquote>
<p>s $\leftarrow$ s0;<br>c $\leftarrow$ nextchar;<br>while c $\neq$ eof do<br> s $\leftarrow$ d(s,c);<br> c $\leftarrow$ nextchar;<br>end;<br>if s is in F then return “yes”<br>            else return “no”</p>
</blockquote>
<p>前面提到了，NFA占空间更少，DFA识别字符串更快，贪心的人类啊希望能糅合这两者的优点。看前面的NFA代码，其实在第四行那句，实际上就是前面提到的构造DFA的过程。人们想到使用Cache。使用NFA，当NFA构造出DFA的一个状态时，就把这个状态构造的条件以及状态本身存到cache里面。当while进一个c的时候，首先看一看现今状态加上c到达的态是不是已经存在cache，如果存在里面，最耗时间的那一部分就不用运行了。cache的管理仍然是程序局限性原则。占用空间不会太大以期望达到折衷的效果。</p>
<p>如果要构造出一个Lax，需要将所有的正则表达式得到的NFA进行一个并操作（保留各自的终态以区分）。然后构造它的DFA。</p>
<p>值得注意的是，这样不能在一个终态停止，而是在错误态终止并退回到最近经过的那个终态（每经过一个终态，记录当前的<strong>输入指针</strong>以及<strong>匹配模式</strong>）。以防止找到前缀，产生错误。这种方法是<strong>最长前缀法</strong>，在前面已经提到过。</p>
<h1 id="DFA优化"><a href="#DFA优化" class="headerlink" title="DFA优化"></a>DFA优化</h1><p>DFA状态数其实不会太多的影响时间复杂度，当状态变少的时候，将会减少存储空间的消耗。</p>
<p><strong>区分：</strong>一个符号串可区分两个状态：这一个串<strong>从这两个状态出发</strong>在DFA上得到的结果一个是accept，一个是reject。在做区分的时候，其实可以看到：最终字符串得到的终态在不同集合，则他们是可区分的。</p>
<blockquote>
<p>Ex<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-9/60487283.jpg" alt=""><br>a不能区分状态A与B。而且还可以看到，以a开头的所有字符串都不可能区分A与B了。再进一步看到，a不可能区分任意两个，因为所有状态在经过a的状态迁移之后都到达了状态B。<br>同理，b不可能区分ACE，以b开头的都不能区分ACE。但是b却可以区分BD。<br>不要忘记，$\epsilon$可是可以区分的。而且他的区分应该被放在最前面，那是因为$\epsilon$区分了终态与其他状态。</p>
</blockquote>
<p>在区分的过程中发现了这样一个规律：如果对于串s，A状态与B状态经过了s都到达同一个状态C，那么以s做前缀的字符串都不可能区分A与B了。当所有字符串都不能区分A与B的时候，可以把A与B合并成同一个状态。但是对于无穷的字符串，怎么确定 “所有都不行” 呢？ 在前面，我们已经提出了一个解决方案——当前缀s不行的时候，所有的sx都不行了。但是，即使是有了这个规律，使用“不行”的这种方法解决问题仍会显得繁琐。</p>
<p>真正在执行的时候，实行的是<strong>分裂</strong>，这样，通过有顺序地枚举字符串，将能被区分开的状态分开。这样对于前面的<strong>不同集合</strong>的说法，也能更好地理解。</p>
<p><strong>算法描述：</strong>首先使用$\epsilon$区分终态与非终态，将它们分为两个集合。随后，像子集构造法那样，有顺序地枚举输入字符串，将那些经过状态迁移能到达终态（不同集合）的状态剔除出去组成一个新的集合（如果两者到达同一个集合，这两者是不能区分的，应该在同一个集合），对于那些含有多个元素的集合，如果经过一系列不同的状态迁移到达不同的集合，仍需要继续分开。直到不再产生新的集合。</p>
<blockquote>
<p>仍然使用上面的例子，进行分裂的过程：</p>
<ol>
<li>$\epsilon$ -&gt; {A,B,C,D}、{E}</li>
<li>a -&gt; {A,B,C,D}  ({B,B,B,B})-&gt;全部一样，以a打头的不用再试</li>
<li>b -&gt; {A,B,C}{D}  ({C,D,C,E})</li>
<li>b -&gt; {A,C}{B}{D}  ({C,C,D})  -&gt; 不同集合</li>
</ol>
<p>最终得到的最小DFA：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/65136532.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/4345780.jpg" alt=""></p>
</blockquote>
<p>最后使用新的状态进行迁移的时候，一定不会出现问题。</p>
<h1 id="补充：从自动机到正则表达式"><a href="#补充：从自动机到正则表达式" class="headerlink" title="补充：从自动机到正则表达式"></a>补充：从自动机到正则表达式</h1><p>可以从一个DFA或NFA得到对应的正则表达式。但是这种方式并不是总是简单的，他只是提供了一个模糊的思路，当一个DFA很复杂的时候，还是需要有聪明才智才行。<br>这里只是简单的给出这个方法，具体可查看<a href="http://note.youdao.com/noteshare?id=9fa52c6fcb1a6637fbdb36f669852abe&amp;sub=9A6AEF1D34C044E68D8BD1AD2057996E" target="_blank" rel="external">这个文件</a>。</p>
<p>为了使讨论更加简单，我们强制一个DFA/NFA应该有下列特性：</p>
<ol>
<li>初态可以到达任意其他状态，没有状态可以通过状态迁移到达初态</li>
<li>只有一个终态，终态不能通过状态迁移到达非终态</li>
<li>初态不能是终态</li>
<li>除了初态与终态，其他状态彼此相连</li>
</ol>
<p>这四个条件看起来很可怕，其实当我们引入了$\varnothing$并根据情况添加初态终态之后，很容易可以把一个DFA/NFA转为一个符合要求的有限自动机。</p>
<p>以一个例子来说明：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/17062978.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/80510309.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/99180281.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/86068172.jpg" alt=""></p>
<p>为了不让自己沾沾自喜，必须指出上面给出的例子很简单，看下面这个：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/70925658.jpg" alt=""></p>
<p>由于生成initstate的一个要求是，不能有进入initstate的箭头，好，像上面一样加一个init，加一个Ac，随即，在删除A的时候就会发现问题。这尼玛转来转去的究竟怎么写边上的正则表达式啊？！</p>
<h1 id="能不能与好不好"><a href="#能不能与好不好" class="headerlink" title="能不能与好不好"></a>能不能与好不好</h1><p>在龙书的第九章。</p>
<ol>
<li><p>流程可否更加简洁？ 正则 -&gt; DFA：本质上还是做子集构造法-吧正则的某些位置对应NFA里面状态，位置集对应NFA的状态集</p>
</li>
<li><p>优化结果？ 最小DFA</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
<div>
  
</div>

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/06/OS/chap3-内存管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YaYi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Be With Me">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/06/OS/chap3-内存管理/" itemprop="url">chap3-内存管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-06T14:13:37+08:00">
                2017-11-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/课/" itemprop="url" rel="index">
                    <span itemprop="name">课</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="内存中的概念"><a href="#内存中的概念" class="headerlink" title="内存中的概念"></a>内存中的概念</h1><p><strong>地址空间</strong>：一个进程可用于寻址内存的一套地址集合。<br><strong>内存管理</strong>：逻辑地址与物理地址之间的映射<br><strong>内存管理的特性</strong>：</p>
<ol>
<li>高效：使得更多的地址可以被使用（其实都是骗–人–进程的）</li>
<li>合理：alloc、free、locate、protect</li>
<li>便利：？<br><strong>内存管理class</strong></li>
<li>简单机制：静态固定</li>
<li>复杂机制：交换、paging</li>
</ol>
<blockquote>
<p>为什么会有这种欺骗的行为存在呢？<br>程序员希望拥有一个又大又快又永久的存储器，希望他们的寻址方式是统一的；但是实际上，又快又大又永久的存储器目前还是不现实的。<br>现在我们有的是：</p>
<ul>
<li>cache：非常快，昂贵</li>
<li>内存：速度适中，价格适中</li>
<li>硬盘：慢，廉价</li>
</ul>
</blockquote>
<p>在计组课里面应该就学过一个各种存储器的速度金字塔。最快的寄存器甚至是按照字节来计算的存储设备。</p>
<p>于是提出问题：如何使用有限的高速存储设备以及较多的低速存储设备来提高的响应速度呢？</p>
<h2 id="内存管理的任务"><a href="#内存管理的任务" class="headerlink" title="内存管理的任务"></a>内存管理的任务</h2><ol>
<li>申请与撤回：资源管理</li>
<li>地址转换：映射管理</li>
<li>分享与保护</li>
<li>空间扩张：你本来不可能占4G的，你非说你占了4个G</li>
</ol>
<h3 id="动态重定位"><a href="#动态重定位" class="headerlink" title="动态重定位"></a>动态重定位</h3><blockquote>
<p>从接口中知道，CPU希望访问一个地址的时候，会给出对应的地址（上总线）以及对应的读写信号etc。</p>
<p>对程序员来说，每一个程序就是一方天地，并不想在程序里面去思考你os应该解决的存储问题，程序认为自己的地址都是从m开始，想访问哪里就访问哪里，但是os并不可以这样做。<br>就像在实验中提到的那样，程序的elf（exe）文件中会有自己的链接地址，这个地址表示程序假设自己被加载到内存的位置，os加载运行的时候需要进行<strong>重定位</strong>，对程序中相关的地址都经过变换。</p>
</blockquote>
<p>对于上述问题，使用两个寄存器来解决，一个是<strong>基址寄存器</strong>，一个是<strong>界限寄存器</strong>，它们在每一个CPU中都存在。基址寄存器存储当前进程的开始物理地址，界限寄存器中存储该程序长度。</p>
<p>当使用一个地址a的时候，首先判断a是否大于界限寄存器中存储的值，如果不是，再将a加上基址寄存器中的值，然后送到地址总线。这些动作都是CPU硬件完成的。</p>
<h2 id="monoprograming：单道程序处理"><a href="#monoprograming：单道程序处理" class="headerlink" title="monoprograming：单道程序处理"></a>monoprograming：单道程序处理</h2><h2 id="multiprogramming"><a href="#multiprogramming" class="headerlink" title="multiprogramming"></a>multiprogramming</h2><p>支持多个进程的os内存管理都需要做什么？</p>
<ol>
<li>申请空间、释放空间</li>
<li>地址转换、内存保护（several method）</li>
<li>CPU利用：MTF的表现</li>
<li>内存扩张：更加柔韧的内存管理</li>
</ol>
<p>使用partition来为每一个进程分配空间</p>
<hr>
<p><strong>动态分区分配</strong>：当程序被加载执行时，分配一个进程制定大小可变的分区，在此分区内地址连续<br>os需要维护所有进程的已分配数据结构以及空闲分区。<br>$$\color{red}{whats this}$$</p>
<h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><p>通常情况下内存是不够用的。仅仅Windows后台应用都会占据一些内存，更不用说开浏览器，开vs等等。为了处理这样的情况，需要，把某一些进程放到外存，为当前运行进程提供内存空间。</p>
<p><strong>交换</strong>：把一个完整的进程调入内存，使该进程运行一段时间，然后存回磁盘。<br>这里提到的交换还不是后面说到的页面置换。</p>
<p><strong>交换中的内存管理</strong>：</p>
<ol>
<li>数据结构与算法：如何描述内存的使用 ； 如何申请、free内存</li>
<li>函数执行：如何消除内存碎片</li>
<li>核心问题的方法？灵活性、稳定性、扩展性</li>
</ol>
<p>关于内存碎片：<br>每次移入内存都是固定的大小，但是有时会移出去，有时会移进来，最终可能会产生许多内存空洞。为了消除内存空洞，需要进行<strong>碎片整理（内存紧缩）</strong>，这个操作很花时间。</p>
<p><strong>碎片整理：紧缩</strong>：<br>什么时候移动？</p>
<p><strong>碎片整理：分区对换</strong>：<br>通过抢占并回收处于等待状态进程的分区，增大可用空间。</p>
<p>核心问题：<br>写程序肯定会经常new吧，这个new是动态分配的内存，只有在运行到这里的时候才会去帮你分配，这种空间是不可预知的，无法准确计算需要空间的最大值。于是在为没一个进程分配空间的时候都可以多分一点。<br>这种分法带来新的问题：<br>将进程换回外存的时候其实并不需要换那些没有有效数据的地址，这是一种浪费。</p>
<h3 id="交换的空闲内存管理"><a href="#交换的空闲内存管理" class="headerlink" title="交换的空闲内存管理"></a>交换的空闲内存管理</h3><h4 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h4><p>就像lab5中的bitmap一样，0代表没有占用，1代表占用。不同的是，这里一个bit代表可能是内存中的一个<strong>分配单元</strong>，可能是4byte，可能是其他。</p>
<p>但是使用位图的话，不利于分配连续的空间，因为需要查找连续的固定字节空间的时间可能比查找一个分配单元空闲多花更多时间。</p>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>这并不是lab2中使用的方法。</p>
<p>维护一个空闲内存段链表与已用内存段链表。在每一个节点标志其状态以及开始地址以及连续地址。</p>
<p>这种方式对上述问题友好。新的问题是如何进行节点的更新与回收，这需要节点的合并与删除、增加等操作<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/19805712.jpg" alt=""></p>
<p><strong>分区管理分配算法</strong>：</p>
<p>当进行内存申请的时候，希望能尽量避免做内存紧缩，这就需要更好的申请方式，而不是每次遇到剩余空间比自己更多的就决定要这个块。</p>
<ol>
<li>首次适配：时间性能好、但会容易导致内存碎片</li>
<li>下次适配：从上次分配的分区开始查找。时间性能好、空闲去分布均匀，较大的空闲分区不易保留</li>
<li>最佳适配：较大空间保留，碎片小而多</li>
<li>最坏适配：着更大的分配：较大分区不会被保留<blockquote>
<p>最佳适配与最坏适配都可以通过维护二级索引来实现更快的查找</p>
</blockquote>
</li>
<li>快速适配：链表的改变十分费劲。为常用大小的块提供专门的索引</li>
</ol>
<h3 id="总结：mono-multi-swap"><a href="#总结：mono-multi-swap" class="headerlink" title="总结：mono\multi\swap"></a>总结：mono\multi\swap</h3><ol>
<li>位图连续空闲空间寻找</li>
<li>链表的空洞</li>
<li>交换的缺点：<ol>
<li>内存碎片</li>
<li>内存的动态增长</li>
<li>如何利用小空间运行大进程？</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Mono</th>
<th style="text-align:center">MFP</th>
<th>Swapping</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Size of proc</td>
<td style="text-align:center">total mem</td>
<td style="text-align:center">partion size</td>
<td>total size of free mem</td>
</tr>
<tr>
<td style="text-align:center">Alloction</td>
<td style="text-align:center">static</td>
<td style="text-align:center">static</td>
<td>dynamic</td>
</tr>
<tr>
<td style="text-align:center">multi-programming</td>
<td style="text-align:center">unsupported</td>
<td style="text-align:center">supported</td>
<td>supported</td>
</tr>
<tr>
<td style="text-align:center">mem space</td>
<td style="text-align:center">continuous</td>
<td style="text-align:center">continuous</td>
<td>continuous</td>
</tr>
<tr>
<td style="text-align:center">mem growth</td>
<td style="text-align:center">unsupported</td>
<td style="text-align:center">un</td>
<td>supported</td>
</tr>
</tbody>
</table>
<p>除了上述的碎片整理，还有<strong>覆盖</strong>技术：（程序员控制</p>
<ol>
<li>划分功能区（ifelse）</li>
<li>确定模块之间的覆盖关系</li>
<li>执行之前预先加载并交换</li>
</ol>
<p>其实是很不好完成的，基础就不好完成，不好判断功能模块，要求的编程技巧太高。</p>
<p>但是，从覆盖技术引出了一个：虚拟内存</p>
<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><ol>
<li>进程的程序段、数据段、堆栈段的总和可以大于物理存储空间</li>
<li>进程不必完全装入内存</li>
<li>os定时将暂且不用的信息换出内存</li>
<li>os负责将换出去的换回来</li>
</ol>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><ol>
<li>页：描述进程逻辑空间的单元</li>
<li>页框：描述物理内存中对应的单元</li>
<li>页表：页与页框之间的映射</li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/6075684.jpg" alt=""></p>
<p>在标准的4KB页面中，位数分别是10-10-12</p>
<p>页转换在mmu中完成，CPU访问到的，在程序之中执行的都是虚拟地址。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/6791125.jpg" alt=""></p>
<p>还记得在计组实验中还被问到了1/0是干吗的，至今难忘。</p>
<p>可能会有是否越界的比较（在标准中不存在，这是因为数据都是正好的）</p>
<hr>
<p>为了考试…</p>
<p>虚拟地址（英语：Virtual address space）在電腦的专用术语中是指标识一个虚拟（非物理地址）的实体地址。虚拟地址这个术语常用在虚拟内存和虚拟网络地址当中。from <a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80" target="_blank" rel="external">wiki</a></p>
<p>在计算机科学中，物理地址（英语：physical address），也叫实地址（real address）、二进制地址（binary address），它是在地址总线上，以电子形式存在的，使得数据总线可以访问主存的某个特定存储单元的内存地址。from <a href="https://zh.wikipedia.org/wiki/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80" target="_blank" rel="external">wiki</a></p>
<p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如RAM）的使用也更有效率。from <a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98" target="_blank" rel="external">wiki</a></p>
<hr>
<h3 id="页表项结构"><a href="#页表项结构" class="headerlink" title="页表项结构"></a>页表项结构</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><strong>page number</strong>：逻辑空间中的页id，<br><strong>frame num</strong>：物理空间中页框的id<br><strong>p/a</strong>：页是不是在内存里面<br><strong>protected</strong>：r/w/e，记录页允许的访问<br><strong>modified</strong>：是不是被修改（脏位<br><strong>referenced</strong>：这个页有没有被使用<br><strong>disable caching</strong>：页面禁用高速缓存</p>
<blockquote>
<p>why 禁用高速缓存？<br>对于那些映射到<strong>设备寄存器</strong>而不是普通物理内存的页面来说，不希望在自己等待设备对自己刚发出去的指令做反应的时候自己的导向地址竟然是cache而不是外部接口。</p>
</blockquote>
<p>in ppt:</p>
<table>
<thead>
<tr>
<th style="text-align:center">page num</th>
<th>p/a</th>
<th>frame num</th>
<th>protected</th>
<th>disable caching</th>
<th>referenced</th>
<th>modified</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h4 id="Design-issue"><a href="#Design-issue" class="headerlink" title="Design issue"></a>Design issue</h4><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/52513606.jpg" alt=""></p>
<h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>10-10-12</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/10468357.jpg" alt=""></p>
<p>除了修改位，每集页表项都是一样的。在非底层页表中，取值为0</p>
<p>其实还可以更多级。</p>
<h3 id="加速分页过程：TLB"><a href="#加速分页过程：TLB" class="headerlink" title="加速分页过程：TLB"></a>加速分页过程：TLB</h3><p>快表：一个将虚拟地址直接映射到物理地址的小型硬件设备，通常在MMU中，其中的项基本不超过64个。</p>
<p>将虚拟地址放在MMU中进行转换时，首先查快表：将该页面号与TLB中所有项同时（并行）进行匹配，如果命中，而且不违反保护位，页框号可以直接从TLB拿出，不必再进行内存访问（访问存储有页表项的内存），如果保护位不允许，就会发生一个页面访问错误。</p>
<p>如果不命中MMU就从内存中找页表项，并将最终找到的页号与页框号等拿出，淘汰tlb中某一个项并添加新来的项。</p>
<p>当从tlb中淘汰值的时候，记得将tlb中存储的修改位换到页面。</p>
<p>tlb表项（示例）</p>
<table>
<thead>
<tr>
<th style="text-align:center">有效位</th>
<th style="text-align:center">虚拟页面号</th>
<th style="text-align:center">修改位</th>
<th style="text-align:center">保护位</th>
<th style="text-align:center">页框号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">123</td>
<td style="text-align:center">1</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">31</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">87</td>
<td style="text-align:center">0</td>
<td style="text-align:center">RX</td>
<td style="text-align:center">87</td>
</tr>
</tbody>
</table>
<p>…</p>
<p>既然TLB这么厉害，为什么不搞一个很大很大的TLB呢。<br>TLB属于高速设备，功耗非常大。</p>
<h3 id="加速分页过程：软件TLB"><a href="#加速分页过程：软件TLB" class="headerlink" title="加速分页过程：软件TLB"></a>加速分页过程：软件TLB</h3><p>当tlb失效的时候，mmu将会告诉os，让os找到要找的页面，从tlb删除一个页面，把这个页加上去。<br>必须在有限的指令内完成，因为tlb失效更加频繁。</p>
<p>但是，当tlb更大一些，这种机制就会变得很有效。这样做的好处是得到一个简单的mmu，从而为CPU其他性能改善提供了空间。</p>
<p>os可以“直觉”那些页面要被使用，然后预先加载到tlb。</p>
<p>《？》<br>在内存固定位置维护大的tlb表项的软件高速缓存。首先检查这个缓存，os可以实质性地减少失效。</p>
<p><strong>软失效</strong>：页面在内存中但是映射不在tlb。<br><strong>硬失效</strong>：页面本身不再内存（当然也不在tlb<strong>so为什么是这样</strong>）</p>
<h3 id="针对大内存：反置页表"><a href="#针对大内存：反置页表" class="headerlink" title="针对大内存：反置页表"></a>针对大内存：反置页表</h3><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/42494861.jpg" alt=""></p>
<p>为什么会出现反置页表？<br><a href="http://kejiao.cntv.cn/20110905/100155.shtml" target="_blank" rel="external">在64位系统下内存</a><br>64位系统，如果仍然保持一个页是4K，那么一共需要有$2^52$个页，只是存储这些页就花费几百G的空间，显然是不合理的。</p>
<p>而目前面临的状态是实际的内存很小，于是可以为每一个页框记录一个页表项。这样对于4K的页以及1G的ram只需要$2^18$个页表项即可。<br>页表项中记录哪一个(进程,虚拟页面)对应于该页框。<br>虽然节省空间，但是不足也是很明显的：<br>将虚拟地址转换为物理地址变得困难</p>
<p>可以使用tlb。但是当tlb失效的时候就很难。<br><strong>基于hash</strong>：把虚拟页号与进程号作为输入，得到的散列值来寻找。</p>
<p><strong>hahs冲突</strong></p>
<p><strong>虚拟存储的基本特征</strong>：</p>
<ol>
<li>不连续（$\color{red}{啥叫虚拟地址空间使用非连续？是说各个区分开吗}）</li>
<li>大用户空间：提供给用户的虚拟地址空间可以大于实际的物理内存</li>
<li>部分交换：虚拟存储只对部分虚拟地址进行调入调出。（不会像交换一样一下一个进程）</li>
</ol>
<p><strong>虚拟页式存储的外存管理</strong>：</p>
<ol>
<li>在哪里保存没有被映射的页？<ol>
<li>需要可以方便的找到在外存中的页面内容</li>
<li>交换空间（磁盘或文件）：采用特殊格式保存没有被映射的页面</li>
</ol>
</li>
<li>虚拟页式存储中的外存选择<ol>
<li>代码段：可执行二进制文件</li>
<li>动态加载的共享式程序段</li>
<li>其他段：交换空间</li>
</ol>
</li>
</ol>
<p><strong>虚拟页式存储的性能</strong>：有效存储访问时间</p>
<p>EAT=访存时间*(1-p)+缺页异常处理时间*缺页率p</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/82455336.jpg" alt=""></p>
<h2 id="pagingsys的工作流程"><a href="#pagingsys的工作流程" class="headerlink" title="pagingsys的工作流程"></a>pagingsys的工作流程</h2><ol>
<li>全局pgtable初始化</li>
<li>创建进程</li>
<li>获取首指令<ol>
<li>pgfault</li>
<li>加载页</li>
<li>更新pgtable</li>
<li>更新tlb</li>
</ol>
</li>
<li>页替换<ol>
<li>pgfault</li>
<li>选择一个页，写回磁盘</li>
<li>把新页换到这里</li>
<li>更新tlb</li>
</ol>
</li>
</ol>
<h2 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h2><ol>
<li>如果内存还有剩余页，分配；把希望访问的页从disk装到这个物理空间，把这个页对应页表的a/p置为1，物理地址映射到新分配的物理地址，重新执行引起缺页中断的指令</li>
<li>如果内存没有剩余的页面，依据页面置换算法选择一个将会被替换的物理页，如果这个物理页的值被修改过，把内存中的值写回外存，把对应逻辑页的a/p置为0，把希望访问的物理页装到这个空间，修改物理页对应的逻辑页面的指示物理页地址以及存在位，重新执行却页指令。</li>
</ol>
<blockquote>
<p>我现在认为，前面提到的挂起状态与现在说的“为了腾内存空间而将一些进程存储的东西先存到外存”是不一样的。<br>挂起的意思应该是pcb都被移动到了外存，根本无法找到这个进程的运行情况，地址空间等；但是这里仅仅是为了节省内存空间，将某些页换到了外存，该进程还是可以继续运行的。只是在需要用这些页的时候可能会引发缺页中断。<br>挂起存在的理由不仅仅是为了节省内存，还有一点是为了更有效的调度，因为所有调度算法考虑的都是就绪队列的进程。</p>
</blockquote>
<h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ol>
<li>缺页中断：需要的页不存在内存之中</li>
<li>页替换：当所有的物理页都被占用；选择一个页被换出去</li>
<li>表现：<ol>
<li>抖动：耗时，低效率</li>
<li>预测：在需要之前就把页面加载进来</li>
<li>最优方案：最远将来（不现实）</li>
</ol>
</li>
</ol>
<p>页面置换算法的功能与目标：</p>
<ol>
<li>功能：当出现缺页异常并且物理内存已经被占满，调出一个物理页给新需要的页使用</li>
<li>设计目标：极可能减少页面的调入调出次数</li>
</ol>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><h3 id="最优页面置换算法"><a href="#最优页面置换算法" class="headerlink" title="最优页面置换算法"></a>最优页面置换算法</h3><p>通常是衡量置换算法的标准</p>
<p>置换在未来最长时间内不访问的页面</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/96462944.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/314073.jpg" alt=""></p>
<h3 id="最近未使用：NRU"><a href="#最近未使用：NRU" class="headerlink" title="最近未使用：NRU"></a>最近未使用：NRU</h3><p>发生pgfault的时候，检查所有页面，将页面分为四类：</p>
<ol>
<li>没有访问 没有修改</li>
<li>没有访问 已经修改该</li>
<li>已经访问 没有修改</li>
<li>已经访问 已经修改</li>
</ol>
<p>需要替换的时候按照首先替换0的规则进行替换。</p>
<p>这是因为每次访问页面都会引发中断：写R/W位，于是os可以利用这个时间做一些事。定时把R位清零来区别最近没有被访问的和已经访问的。</p>
<h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><p>替换最先被换进来的。</p>
<p>通过维护一个记录所有位于内存的逻辑页面链表，将该链表按驻留时间排序，联手最长，连伟最短。缺页的时候进行置换，新页面加到链尾</p>
<p>实现简单，可以用硬件实现，但是性能很差，基本不会单独使用这个算法。</p>
<p><strong>Belady</strong>现象：</p>
<p>分配的物理也数增加，但是却也次数也会增加的现象。</p>
<p>原因：FIFO的置换特征与进程访问内存的动态特征矛盾<br>被他置换出去的不一定是近期不会访问的。</p>
<h3 id="LRU：最近最少使用页面算法"><a href="#LRU：最近最少使用页面算法" class="headerlink" title="LRU：最近最少使用页面算法"></a>LRU：最近最少使用页面算法</h3><p>最近经常访问的页面可能在以后也会经常访问，最近不经常访问的页面可能以后也不会访问。于是选择最长时间没有被访问过的页面替换出去。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/30845425.jpg" alt=""></p>
<blockquote>
<p>这是最优置换算法的一种近似</p>
</blockquote>
<p>虽然可以实现，但是代价很高<br>——需要一个全面的链表，最少使用的在前，最多使用的在后。<br>——需要一个栈，访问页面的时候将这个页号压入栈，并把栈内相同的页号抽出，缺页时拿栈底</p>
<p>使用一个n*n矩阵表示所有页框的信息，当k被访问的时候，把k行设置为1，k列设置为0，一段时间后，每一行的二进制值最小的就是最近最少使用的。</p>
<p><strong>Simple Implementation</strong>：页表项上的计数器<br><strong>硬件实现</strong>：为n<em>n矩阵，使用了特殊的寄存器<br><em>*软件实现</em></em>：NFU</p>
<h3 id="最不常用算法：LFU-NFU"><a href="#最不常用算法：LFU-NFU" class="headerlink" title="最不常用算法：LFU/NFU"></a>最不常用算法：LFU/NFU</h3><p>是对LRU的软件实现。</p>
<p>将每个页面与一个计数器关联，取计数值最小的页面替换</p>
<p>LFU的缺点是他从来不会忘记。以前频繁使用的页面很大可能不会被调出去。：<strong>通过计数器定时右移来改正</strong>-&gt;老化算法<br>LRU关注的是多久未访问而LFU关注的是访问次数，是不一样的。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/89846367.jpg" alt=""></p>
<h3 id="时钟算法"><a href="#时钟算法" class="headerlink" title="时钟算法"></a>时钟算法</h3><p>环状结构，当一个缺页中断到来的时候，首先检查指针所在位置页面的访问位，如果是0就淘汰这个页面，否则置为0，转圈，转到的，如果是0就淘汰，如果是1就变成0，知道找到第一个0。</p>
<p>是LRU与FIFO的折中。<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/9967853.jpg" alt=""></p>
<h3 id="改进的时钟算法"><a href="#改进的时钟算法" class="headerlink" title="改进的时钟算法"></a>改进的时钟算法</h3><p>在页面添加修改位，并在访问时进行相应修改：<br>新改的：RW。<br>每次扫过都将：如果R是1，把R置为0；如果R是0，如果W是1，写这页，写完之后W=0，接着找，如果R=0W=0，就是这个了。</p>
<p>缺页时修改页面标志位，以跳过有修改的页面。<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/7051850.jpg" alt=""></p>
<hr>
<p>上述的都是<strong>局部页面置换算法</strong>。<br>局部页面置换算法选择范围仅仅限于当前进程占用的空间，不考虑进程访存差异。<br><strong>全局页面置换算法</strong>可以逼出其他进程的物理页面：工作集算法、缺页率算法<br>需要动态确定好给每一个进程的物理页面数。</p>
<hr>
<p>CPU利用率达到极致以后，再增加并发进程数iu会出现内存抖动。<br>进程数少时，提高并发进程数，可提高CPU利用率<br>并发进程导致内存访问增加<br>并发进程的内存访问会降低了访存的局部性特征<br>局部性特征的下降会导致缺页率上升和CPU利用率下降</p>
<h3 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h3><h3 id="缺页率置换算法"><a href="#缺页率置换算法" class="headerlink" title="缺页率置换算法"></a>缺页率置换算法</h3><p>缺页次数 / 内存访问次数 或 缺页平均时间间隔的倒数</p>
<p><strong>影响缺页率</strong>：</p>
<ol>
<li>页面置换算法</li>
<li>分配给进程的物理页数目</li>
<li>页面大小</li>
<li>程序的编写方法</li>
</ol>
<p>可以通过调整常驻集的大小，使每一个进程的缺页率保持在一个合适的值。<br>若进程缺页率过高，则增加常驻集以分配更多的物理页面<br>若进程缺页率过低，则减少常驻集以减少它的物理页面数</p>
<blockquote>
<p>为每一个页面计数，达到-m的时候，回收，你要页面就给页面。</p>
</blockquote>
<p>普通访问不做任何事情，缺页的时候，算一下多久没有缺页了，如果数值比较大，看一看是不是有的页面已经没用了，在这期间没有访问的页面被释放。如果小一些，看看是不是需要补一些页面。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/45924471.jpg" alt=""></p>
<p><strong>页替换过程</strong></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/94487722.jpg" alt=""></p>
<h1 id="段机制"><a href="#段机制" class="headerlink" title="段机制"></a>段机制</h1><p><strong>段</strong>：一个程序的逻辑分区<br><strong>页机制缺点</strong>：复杂，消耗资源</p>
<p>地址映射：段中的addr +段中的偏移<br>内存分配：全局段表+本地段表<br>调度：需要时加载段<br>段+分页：用段技术组织节目内容，用分页技术组织物理内存</p>
<h2 id="段地址空间"><a href="#段地址空间" class="headerlink" title="段地址空间"></a>段地址空间</h2><p>进程的段地址空间由多个段组成 ：<br>主代码段 子模块代码段 公用库代码段 堆栈段 堆数据(heap) 初始化数据段 符号表等</p>
<p>段式存储管理的目的：<strong>更细粒度和灵活的分离与共享</strong>一般用于权限控制</p>
<p>段一般是一种段是连续的。有起始地址以及段内偏移量。</p>
<p><strong>段</strong>：表示访问方式和存储数据等属性相同的一段地址空间</p>
<h2 id="段页结合"><a href="#段页结合" class="headerlink" title="段页结合"></a>段页结合</h2><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/3276497.jpg" alt=""></p>
<p>内存共享：通过指向相同的页表基址，实现进程之间的段共享。</p>
<h2 id="link-of-segments"><a href="#link-of-segments" class="headerlink" title="link of segments"></a>link of segments</h2><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/41368943.jpg" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
<div>
  
</div>

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.gif"
                alt="YaYi" />
            
              <p class="site-author-name" itemprop="name">YaYi</p>
              <p class="site-description motion-element" itemprop="description">来如春梦不多时 去似朝云无觅处</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">40</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/yayi2456" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:yourname@gmail.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://stackoverflow.com/yourname" target="_blank" title="StackOverflow">
                    
                      <i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://weibo.com/2723381840/" target="_blank" title="Weibo">
                    
                      <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YaYi</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>





  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>


	<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
本站总访问量 <span id="busuanzi_value_site_pv"></span> &nbsp&nbsp&nbsp
您是第<span id="busuanzi_value_site_uv"></span>个来到的小伙伴



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共82.1k字</span>
</div>



        




  <script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=64002140";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

  
  
<div id="hexo-helper-live2d">
  <canvas id="live2dcanvas" width="150" height="300"></canvas>
</div>
<style>
  #live2dcanvas{
    position: fixed;
    width: 150px;
    height: 300px;
    opacity:0.7;
    right: 0px;
    z-index: 999;
    pointer-events: none;
    bottom: -20px;
  }
</style>
<script type="text/javascript" src="/live2d/device.min.js"></script>
<script type="text/javascript">
const loadScript = function loadScript(c,b){var a=document.createElement("script");a.type="text/javascript";"undefined"!=typeof b&&(a.readyState?a.onreadystatechange=function(){if("loaded"==a.readyState||"complete"==a.readyState)a.onreadystatechange=null,b()}:a.onload=function(){b()});a.src=c;document.body.appendChild(a)};
(function(){
  if((typeof(device) != 'undefined') && (device.mobile())){
    document.getElementById("live2dcanvas").style.width = '75px';
    document.getElementById("live2dcanvas").style.height = '150px';
  }else
    if (typeof(device) === 'undefined') console.error('Cannot find current-device script.');
  loadScript("/live2d/script.js", function(){loadlive2d("live2dcanvas", "/live2d/assets/hijiki.model.json", 0.5);});
})();
</script>

</body>
</html>
