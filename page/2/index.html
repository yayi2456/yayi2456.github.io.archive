<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">

<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>


  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">




  
  
  <link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3">




<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Be With Me" type="application/atom+xml" />






<meta name="description" content="来如春梦不多时 去似朝云无觅处">
<meta property="og:type" content="website">
<meta property="og:title" content="Be With Me">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Be With Me">
<meta property="og:description" content="来如春梦不多时 去似朝云无觅处">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Be With Me">
<meta name="twitter:description" content="来如春梦不多时 去似朝云无觅处">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '61a4cd7c1bed364065c7fe56474ba5df',
      indexName: 'yayiblogsearch',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Be With Me</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8214766f6334490a524e10cda5fd72cf";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Be With Me</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">最喜欢你啦！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            日程表
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
			
			<!--增加的代码 start-->

          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/27/OS/OS4+Memory and Process/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YaYi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Be With Me">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/27/OS/OS4+Memory and Process/" itemprop="url">串讲复习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-27T19:00:00+08:00">
                2017-11-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/MIT-Lab/" itemprop="url" rel="index">
                    <span itemprop="name">MIT Lab</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p><strong>例：STL的实现</strong><br>printf：<br>对屏幕：</p>
<ol>
<li>在每一个像素有一种颜色</li>
<li>文本模式</li>
</ol>
<h2 id="系统调用与函数调用"><a href="#系统调用与函数调用" class="headerlink" title="系统调用与函数调用"></a>系统调用与函数调用</h2><p>系统调用是中断，相当于在用户程序执行的过程中嵌入一段由OS完成的代码，完成后再返回用户程序。其中，包括特权级的升降。在进行系统调用的过程中，进入之后首先会检查用户传参是否有危险，随后再执行系统调用。这将在一个新的页完成，存在于<strong>内核态独立地址空间</strong>，将会带来包括TLB，Cache等的一系列问题。因此，系统调用的代价比函数调用的代价大得多。</p>
<h1 id="进程间的通信"><a href="#进程间的通信" class="headerlink" title="进程间的通信"></a>进程间的通信</h1><h2 id="直接通信与间接通信"><a href="#直接通信与间接通信" class="headerlink" title="直接通信与间接通信"></a>直接通信与间接通信</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">send(A,)</div></pre></td></tr></table></figure>
<h2 id="阻塞通信与非阻塞通信"><a href="#阻塞通信与非阻塞通信" class="headerlink" title="阻塞通信与非阻塞通信"></a>阻塞通信与非阻塞通信</h2><p>像网络中那样，阻塞通信就是//</p>
<h2 id="通信链路缓冲"><a href="#通信链路缓冲" class="headerlink" title="通信链路缓冲"></a>通信链路缓冲</h2><p><strong>0容量</strong>：发送方需要等待接收方<br><strong>有限容量</strong>：<br><strong>无限容量</strong>：</p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号类似于中段，</p>
<p>是最原始、最简单的一个进程间交互的模式。在关机时，系统将会用这种方式通知各各进程。</p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>父子之间传递信息</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>类似于电子邮件系统。</p>
<p>得到一个队列，使用队列号来标识。此后消息的send与recv都通过这个队列。</p>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>创建共享段<code>shmget(key,size,flags)</code>。其中key是其他人希望与你共享内存的话必须知道的值。<code>shmat(shmid,*shmaddr,flags)</code>把共享段映射到进程地址空间。</p>
<p>在这里，将又会遇到在“哲学家就餐”那部分的问题。另外，还将会有在cache还是内存的问题。cache作为在读写操作时第一个碰到的硬件，是否可以保证进程A写的时候吧东西写进了共享区的物理内存？在B不能使用的时候它的Cache的正确性哈能不能保证？—？</p>
<p>由一个“可否使用cache”的位</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
<div>
  
</div>

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/21/计算机网络/计算机网络概述/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YaYi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Be With Me">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/21/计算机网络/计算机网络概述/" itemprop="url">计算机网络概述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-21T21:51:40+08:00">
                2017-11-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/大三的课/" itemprop="url" rel="index">
                    <span itemprop="name">大三的课</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <p>这是第一次课！时隔许久，也算是复习啦~</p>
<p>#</p>
<h1 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h1><h1 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h1><h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><p>在各种网络之中，端对端之间互相传送<strong>报文</strong>。为了从源系统项目地端系统发送报文，源端系统将报文分成若干的小数据块，成为<strong>分组</strong>。每个分组都通过源端系统与目的端系统之间的<strong>分组交换机</strong>（主要是<strong>路由器</strong>以及<strong>链路交换机</strong>）传送。分组以等于链路最大传输速率的速度通过通信链路，因此如果传输速度是R比特/s，那么传输L比特分组的时间是L/R比特/s。</p>
<h3 id="存储转发传输"><a href="#存储转发传输" class="headerlink" title="存储转发传输"></a>存储转发传输</h3><p>多数分组交换机在链路的输入端使用<strong>存储转发传输</strong>机制，它是指在交换机开始发送第一个比特之前，必须接收到整个分组。</p>
<p>我们看一个例子：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-22/26732713.jpg" alt=""></p>
<p>如果发送方要传送长是L的报文，两条链路传输速率都是Rbit/s，那么到达路由器之前不能转发，首先浪费了L/R s，这时全部到达了，然后转发出去，一共花费了2L/R。（没有考虑线路长度）</p>
<p>而如果数据一旦到达路由器就转发而不用等到全部到达，只需要L/R的时间。</p>
<p>现在计算发送三个分组，从源发送第一个分组到达目的地接收到全部三个分组的时间：<br>在L/R，第一个分组被转发出去，这时源也开始发出第二个分组，2L/R，第一个已经被路由器转发完毕，目的端收到，路由器开始接收第三个分组，源开始发送第三个分组，3L/R，路由器接收第三个分组完成，第二个分组已经送出去被目的接收到，源端发送完毕，4L/R第三个分组完全传送出去，目的端接收到第三个分组。一共4L/R时间。</p>
<p>考虑N条速率均为R的链路（所以一共有N-1个路由器），发送一个分组所需时间是$t=N*\frac{L}{R}$。</p>
<p>如果像上面一样分组发送：</p>
<p>一个长度L的包一次发出去，时间是$t=N*\frac{L}{R}$，如果分成c组，时间为：$t`=(c+N-1)*\frac{L}{c*R}$！！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
<div>
  
</div>

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/15/简单udp通信实现-java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YaYi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Be With Me">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/15/简单udp通信实现-java/" itemprop="url">网络编程一：UDP,CMD,TCP,WebServer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-15T22:12:40+08:00">
                2017-11-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/大三的课/" itemprop="url" rel="index">
                    <span itemprop="name">大三的课</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/大三的课/作业/" itemprop="url" rel="index">
                    <span itemprop="name">作业</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="UDP-CMD"><a href="#UDP-CMD" class="headerlink" title="UDP CMD"></a>UDP CMD</h1><p>今天写webserver的时候发现需要用到以前写的一些程序的知识。所以觉得最好总结一下。</p>
<p>woaibianyi,bianyibangwojiejueledaiamdewenti.xieixeni.</p>
<p>感觉像是…识别不出\n…行吧，myplace myrule，//必须以;结尾！</p>
<h2 id="UDP介绍"><a href="#UDP介绍" class="headerlink" title="UDP介绍"></a>UDP介绍</h2><p>UDP通信使用两个类：<strong>DatagramPacket</strong>与<strong>DatagramSocket</strong>。前者是对UDP包的一个封装，后者是完成两端之间的交流。<br>在UDP里面Server与Client地位同等，彼此没有区分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">DatagramPacket packet=<span class="keyword">new</span> DatagramPacket(buff,buff.length,addr,port);<span class="comment">//发送包;</span></div><div class="line">DatagramPacket packet=<span class="keyword">new</span> DatagramPacket(buff,buff.length);<span class="comment">//接收包;</span></div><div class="line">DatagramSocket socket=<span class="keyword">new</span> DatagramSocket(port);<span class="comment">//指定端口号的socket;</span></div><div class="line">DatagramSocket socket=<span class="keyword">new</span> DatagramSocket();<span class="comment">//自动分配一个可用端口号;</span></div></pre></td></tr></table></figure>
<p>不得不说端口号与进程、socket之间的关系：端口号与进程毛关系没有。一个udp socket只能绑一个端口，一个port只能被一个socket绑。这个原因是在多路复用与多路分解讲到的。否则不知道pck究竟该给谁。</p>
<h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><h3 id="Server的ip获取；获取client的ip与port"><a href="#Server的ip获取；获取client的ip与port" class="headerlink" title="Server的ip获取；获取client的ip与port"></a>Server的ip获取；获取client的ip与port</h3><p><strong>Server端获取Server的ip与port</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">InetAddress.getLocalHost();<span class="comment">//ip获取;</span></div><div class="line">socket.getLocalPort();<span class="comment">//socket绑定的port获取;</span></div></pre></td></tr></table></figure>
<p><strong>Server端获取Client的ip与port</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//pck是从client接收到的包;</span></div><div class="line">pck.getAddress();<span class="comment">//;</span></div><div class="line">pck.getPort();<span class="comment">//;</span></div></pre></td></tr></table></figure>
<h3 id="时间获取"><a href="#时间获取" class="headerlink" title="时间获取"></a>时间获取</h3><ol>
<li>定义：<code>Calendar cal;</code></li>
<li>每次获取时间前都应执行：<code>cal= Calendar.getInstance();</code></li>
<li>获取常用的数据：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> year = cal.get(Calendar.YEAR);</div><div class="line"><span class="keyword">int</span> month=cal.get(Calendar.MONTH)+<span class="number">1</span>;</div><div class="line"><span class="keyword">int</span> day=cal.get(Calendar.DATE);</div><div class="line"><span class="keyword">int</span> week = cal.get(Calendar.DAY_OF_WEEK)-<span class="number">1</span>;</div><div class="line"><span class="keyword">int</span> hour=cal.get(Calendar.HOUR_OF_DAY);</div><div class="line"><span class="keyword">int</span> minute=cal.get(Calendar.MINUTE);</div><div class="line"><span class="keyword">int</span> second=cal.get(Calendar.SECOND);</div></pre></td></tr></table></figure>
<h3 id="使用其他类访问同一可视化界面"><a href="#使用其他类访问同一可视化界面" class="headerlink" title="使用其他类访问同一可视化界面"></a>使用其他类访问同一可视化界面</h3><p>以本程序为例，在主类中创建了一个可视化界面，希望在Time类访问可视化界面的一个label：</p>
<p><strong>在Time类创建一个label，使用主类的label初始化这个label</strong>。</p>
<h3 id="主方法：监听client请求"><a href="#主方法：监听client请求" class="headerlink" title="主方法：监听client请求"></a>主方法：监听client请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">DatagramSocket socket=<span class="keyword">new</span> DatagramSocket(<span class="number">4444</span>);<span class="comment">//固定的一个socket，绑定固定的port;</span></div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">    <span class="keyword">byte</span>[]buff=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">256</span>];<span class="comment">//输入缓冲区;</span></div><div class="line">    DatagramPacket pck=<span class="keyword">new</span> DatagramPacket(buff,buff.length);<span class="comment">//每次都新建一个包，否则会产生缓冲区不干净发送数据错误的问题;</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        server.log.setText(server.log.getText()+<span class="string">"\ni'm at "</span>+InetAddress.getLocalHost()+<span class="string">" "</span>+socket.getLocalPort()+<span class="string">" and listenning~\n"</span>);</div><div class="line">        server.log.setCaretPosition(server.log.getText().length());<span class="comment">//设置目前的光标位置，在可视化界面具体讲;</span></div><div class="line">        socket.receive(pck);<span class="comment">//接收数据包：阻塞方法;</span></div><div class="line">        server.log.setText(server.log.getText()+<span class="string">"i've get a request from "</span>+pck.getAddress()+<span class="string">" "</span>+pck.getPort()+<span class="string">" "</span>+<span class="keyword">new</span> String(pck.getData())+<span class="string">"\n"</span>);<span class="comment">//;</span></div><div class="line">        server.log.setCaretPosition(server.log.getText().length());</div><div class="line">        Server newserver=<span class="keyword">new</span> Server(<span class="keyword">new</span> String(pck.getData()),pck,server);<span class="comment">//新开一个线程，专门负责与这个client的通信;</span></div><div class="line">        <span class="keyword">new</span> Thread(newserver).start();<span class="comment">//新线程开始运行;</span></div><div class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            <span class="comment">// TODO Auto-generated catch block;</span></div><div class="line">         e.printStackTrace();</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>pck.getData();</code>:获取pck包的data信息;<br><code>pck.getAddress();</code>获取包的源地址<br><code>pck.getPort();</code>获取包的源端口</p>
<p><code>InetAddress.getLocalHost();</code>:获取本地ip，可能抛出异常，需要处理<br><code>socket.getLocalPort();</code>获取socket绑定的端口号</p>
<p><code>socket.receive(pck);</code>:等待接收一个包<br><code>socket.send(pck);</code>:发送一个包</p>
<h3 id="String与Unix时间戳之间的转换"><a href="#String与Unix时间戳之间的转换" class="headerlink" title="String与Unix时间戳之间的转换"></a>String与Unix时间戳之间的转换</h3><p>format函数之中是一个Date对象，这个Date对象由一个long构造：list[i]是File类型。也许会说“过时”，没关系，这一整句代码打上去就不会提示了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String dates=<span class="keyword">new</span> java.text.SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(<span class="keyword">new</span> java.util.Date(list[i].lastModified()));</div></pre></td></tr></table></figure>
<p>多说一句SimpleDateFormat：</p>
<p> G 年代标志符<br>  y 年<br>  M 月<br>  d 日<br>  h 时 在上午或下午 (1~12)<br>  H 时 在一天中 (0~23)<br>  m 分<br>  s 秒<br>  S 毫秒<br>  E 星期<br>  D 一年中的第几天<br>  F 一月中第几个星期几<br>  w 一年中第几个星期<br>  W 一月中第几个星期<br>  a 上午 / 下午 标记符<br>  k 时 在一天中 (1~24)<br>  K 时 在上午或下午 (0~11)<br>  z 时区</p>
<p>可以说是十分实用了。</p>
<p>具体信息可以访问<a href="http://blog.csdn.net/gubaohua/article/details/575488" target="_blank" rel="external">这里：SimpleDateFormat使用详解</a></p>
<h3 id="获取本地文件信息"><a href="#获取本地文件信息" class="headerlink" title="获取本地文件信息"></a>获取本地文件信息</h3><p><strong>注意</strong>：没有解决的一个问题：包最后一定会用ASCII为0的char填充满255个，注意！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">File f=<span class="keyword">new</span> File(dirpath);</div><div class="line">File[] list=<span class="keyword">null</span>;</div><div class="line"><span class="keyword">if</span>(f.isDirectory())&#123;</div><div class="line">    list=f.listFiles();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取文件名信息：<code>list[0].getName();</code><br>是否文件？是否目录？:<code>list[0].isFile();list[0].isDirectory();</code><br>还有一系列方法：自己发现吧！</p>
<p>Server的java代码<a href="http://note.youdao.com/noteshare?id=de6b0e25562da7949d1b1b8a51ae865c&amp;sub=E0E99B97DC7A4AAEB00CC82204E767BC" target="_blank" rel="external">看这里</a></p>
<h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><h3 id="client的ip获取"><a href="#client的ip获取" class="headerlink" title="client的ip获取"></a>client的ip获取</h3><p><code>InetAddress.getLocalHost();</code>与Server差不多</p>
<h3 id="设置最大时延"><a href="#设置最大时延" class="headerlink" title="设置最大时延"></a>设置最大时延</h3><p>送出一个包：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">DatagramSocket socket=<span class="keyword">new</span> DatagramSocket();</div><div class="line">socket.setSoTimeout(<span class="number">10000</span>);</div><div class="line">socket.send(pck);</div></pre></td></tr></table></figure>
<p>新开一个线程中：等待接收一旦超时触发异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    socket.receive(pck);</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span>(SocketTimeoutException e)&#123;</div><div class="line">    e.printStackTrace();</div><div class="line">    ori=ori+<span class="string">"timeout!:"</span>+socket.getInetAddress()+<span class="string">" for "</span>+pck.getData().toString()+<span class="string">" has no response . try again!\n"</span>;</div><div class="line">    clientthis.tf.setText(ori);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用String设置指定IP"><a href="#使用String设置指定IP" class="headerlink" title="使用String设置指定IP"></a>使用String设置指定IP</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    <span class="keyword">int</span>[]ipaddr=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</div><div class="line">    String[] ipsplit=<span class="keyword">new</span> String[<span class="number">4</span>];</div><div class="line">    data=data.replace(<span class="string">'.'</span>, <span class="string">'-'</span>);</div><div class="line">    ipsplit=data.split(<span class="string">"-"</span>);<span class="comment">//这两步是当时不懂正则，使的一个小手段;</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(ipsplit[i]!=<span class="keyword">null</span> &amp;&amp; ipsplit[i].isEmpty())&#123;</div><div class="line">        cmd.setText(cmd.getText()+<span class="string">"format of ip addr wrong!split by .\n&gt;"</span>);</div><div class="line">        rows++;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    ipaddr[i]=Integer.parseInt(ipsplit[i]);</div><div class="line">    &#125;<span class="comment">//前面是为了验证给定的string是符合要求的int.int.int.int形式;</span></div><div class="line">    <span class="comment">//得到正确的ip;</span></div><div class="line">   <span class="comment">//转化为byte流;</span></div><div class="line">    <span class="keyword">byte</span>[]byteaddr=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</div><div class="line">    byteaddr[<span class="number">0</span>]=(<span class="keyword">byte</span>)ipaddr[<span class="number">0</span>];</div><div class="line">    byteaddr[<span class="number">1</span>]=(<span class="keyword">byte</span>)ipaddr[<span class="number">1</span>];</div><div class="line">    byteaddr[<span class="number">2</span>]=(<span class="keyword">byte</span>)ipaddr[<span class="number">2</span>];</div><div class="line">    byteaddr[<span class="number">3</span>]=(<span class="keyword">byte</span>)ipaddr[<span class="number">3</span>];</div><div class="line">    <span class="comment">//设置新ip;</span></div><div class="line">    addr=InetAddress.getByAddress(byteaddr);</div><div class="line">    System.out.println(data);</div><div class="line">    cmd.setText(cmd.getText()+<span class="string">"&gt;"</span>);<span class="comment">//先忽略就好;</span></div><div class="line">&#125;<span class="keyword">catch</span>(NumberFormatException e)&#123;<span class="comment">//根本不符合格式;</span></div><div class="line">    e.printStackTrace();</div><div class="line">    cmd.setText(cmd.getText()+<span class="string">" wrong:"</span>+command.substring(<span class="number">7</span>)+<span class="string">"wrong format of ip addr! split by . and only numbers are accept\n&gt;"</span>);</div><div class="line">    rows++;</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span>(UnknownHostException he)&#123;<span class="comment">//;</span></div><div class="line">    he.printStackTrace();</div><div class="line">    cmd.setText(cmd.getText()+<span class="string">"unknown host\n&gt;"</span>);</div><div class="line">    rows++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>client代码<a href="http://note.youdao.com/noteshare?id=45d994163c92b945960698ea27100a1b&amp;sub=3AE87C2D6AF44F2BA331DB9C7904A210" target="_blank" rel="external">看这里</a></p>
<h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><p>可视化部分也在上面的client代码里面。</p>
<h1 id="TCP-WebServer"><a href="#TCP-WebServer" class="headerlink" title="TCP WebServer"></a>TCP WebServer</h1><p>这是第二次作业，使用TCP，利用http1.1，实现一个可以与浏览器进行交互的小型的WebServer。</p>
<p>附加：tcp部分编码设置</p>
<p>String code=”utf-8”;<br>        try {<br>            InputStream instream= new java.io.FileInputStream(file);<br>            byte[] b = new byte[3];<br>            instream.read(b);<br>            instream.close();<br>            if (b[0] == -17 &amp;&amp; b[1] == -69 &amp;&amp; b[2] == -65)code=”utf-8”;<br>            else code=”GBK”;<br>        } catch (IOException e) {<br>            // TODO Auto-generated catch block<br>            e.printStackTrace();<br>        }<br>        return code;</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
<div>
  
</div>

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/14/OS/实验串讲/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YaYi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Be With Me">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/14/OS/实验串讲/" itemprop="url">OS-各实验初讲</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-14T22:05:33+08:00">
                2017-11-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/MIT-Lab/" itemprop="url" rel="index">
                    <span itemprop="name">MIT Lab</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Lab3：User-Environment"><a href="#Lab3：User-Environment" class="headerlink" title="Lab3：User Environment"></a>Lab3：User Environment</h1><h2 id="Pre：实验准备知识"><a href="#Pre：实验准备知识" class="headerlink" title="Pre：实验准备知识"></a>Pre：实验准备知识</h2><h3 id="GCC内联汇编"><a href="#GCC内联汇编" class="headerlink" title="GCC内联汇编"></a>GCC内联汇编</h3><h3 id="特权降级"><a href="#特权降级" class="headerlink" title="特权降级"></a>特权降级</h3><h4 id="基础知识准备"><a href="#基础知识准备" class="headerlink" title="基础知识准备"></a>基础知识准备</h4><p>切换到保护模式之后就会有不同的特权等级，这时默认在最高的特权等级上。这个时候为内核建立了页表结构，接下来将会跳转到用户程序。进行跳转的时候，应该注意：不可以再留着这个高级的运行权限了，因此需要进行特权级的降级。</p>
<p>系统在以上电时，各个资源管理都还没有建立，这个时候处于特权管理模式，在特权模式建立完毕所有的资源映射之后，再降级到通用模式，运行。</p>
<p>因此，一上电运行的指令一旦被不安全的程序接管，将不会降级，保护措施将形同虚设。因此，在智能手机等终端上都有一个叫做trustdo(?)的硬件，它是一个加密的模块，这个模块是系统上电之后运行的第一段代码，作用是验证将要运行的这段代码是不是被授权的，数字签名是否通过，若通过才会运行。trustdo会被做到CPU的芯片中，保证了即使上电后处于特权模式的代码是安全可靠的。</p>
<hr>
<p><strong>iret</strong>：系统指令，从中断中返回。<br><strong>ret</strong>：从函数中返回<br><strong>retf</strong>：与ret基本一样，从函数中返回。（弹出栈，拿出返回地址（就是下一条语句）返回值，丢掉压栈参数）</p>
<p>中断是一个硬件的事件，中断返回与函数返回不同。当一个中断来了，不管你当时在干嘛，就乖乖地保存一下现场去响应中断。这个<strong>保存现场</strong>，包括了硬件将会自动帮你保存的一些现场，比如CS、SS、Flag等等，这些是自动存下的，iret的作用就是自动地将这些东西都弹出。但是这些现场保存并不够，通用寄存器是不会帮你保存的。</p>
<p>ret、iret等等在汇编之中可以随意调用，并不需要其他约束。如果当你在汇编中不是函数（中断）的里面调用了这些，它会干些什么呢？<br>他会把自己认为的自己保存进去的那些东西弹出来，一个是返回地址给PC，一个是返回值给保存返回值的东西。即使没有调用函数，ret的行为也是固定的：<strong>从栈顶弹出两个值，一个给PC，一个给存储返回值的东西</strong>，iret的行为也是固定的，就是从栈顶弹出东西给那些变量。<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-14/87170051.jpg" alt=""><br>这就是保护现场之后的栈。<br>ret是弹出到eip，retf弹出到CS，iret弹出到CS（代码段）、EFLAGS，根据是否改变特权等级，iret会连下面的SS以及esp一起弹出来。</p>
<p>这样，如果一个程序在栈中事先在栈中存了一些数据，然后调用了iret，iret不管栈中究竟是什么，就会弹出5（3）个元素，给对应的寄存器。ret和retf也类似。因此，在汇编中ret们与高级语言的return们的作用不同，汇编中的ret们只是<strong>提供了一个批量修改寄存器的方法</strong>。</p>
<p>系统中有两种中断。中断可能在任意时间发生。在用户模式下与在特权模式下中断发生后系统的动作是不相同的。</p>
<p>在用户模式下，系统会保存这些东西：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-14/4474675.jpg" alt=""><br>还记得在“内存管理”的lab里面讲过的<strong>段选择子</strong>，其中有两个bit标识自己处在什么特权模式下的特权位。这里面有两个段选择子，一个是栈的，一个是代码段的，由于在用户模式下，可以看到CS代码段选择子与SS栈选择子的特权位RPL都是3。</p>
<p>在特权模式下，一旦发生中断：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-14/84089468.jpg" alt=""><br>这时保存的东西比较少。</p>
<p>无论在哪种模式下一旦调用iret，就把这些东西（其实不一定是这些东西，只是对应栈顶的几个数据）弹出去给对应的寄存器。</p>
<h3 id="正题：特权降级"><a href="#正题：特权降级" class="headerlink" title="正题：特权降级"></a>正题：特权降级</h3><p>考虑做完lab2，系统在特权级是0的模式下，这是需要现将自己降级成为特权3的模式，再去运行用户程序。怎么降？</p>
<p>要伪造一个场景：刚刚一个用户程序产生了一个中断所以我升级了，现在我要中断返回。于是我去伪造了一个栈，在栈里头存上了iret希望的那5个数据，每一个是32位。然后调用iret，这些就会从栈中弹出来到达对应的寄存器，然后我就回到了用户模式，那两个段选择子的特权级值就被改为了3。<br>这里需要注意的是，系统原来使用的特权级是0的栈，iret之后这个栈空掉了，但是系统不再使用这个栈，而是重新为用户态开避了一个新的栈，这个栈不再是以前的那个栈了，这个栈放在用户空间的数据段里，它的权限也是3。</p>
<blockquote>
<p>为什么要这样设计呢？在特权模式下，系统并不想和特权级更低的用户态共用一个特权级更高的栈。另一个方面从安全考虑，为了防止用户态随意弹出数据随意插入数据破坏内核运行。</p>
</blockquote>
<p>从特权模式到达用户模式，新创建了一个栈给用户程序使用，这是在刚上电的时候，还没有用户程序运行。用户程序运行过程中可能会有系统调用回到特权模式下，这是将会使用前面提到的系统用的那个栈，系统调用完成之后，不会再为用户程序创建新的栈了，一是占空间，一是以前的运行态不能就这样丢掉。就还让它回到自己原来的栈。</p>
<h2 id="特权级提升"><a href="#特权级提升" class="headerlink" title="特权级提升"></a>特权级提升</h2><p>中断、异常、系统调用：我需要更高特权的东西帮帮我。</p>
<p>在80386中，系统调用就是一个中断。异常是需要紧急处理的中断。</p>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>在32位机器上的中断是一个很复杂的机制，因为那时保护模式已经建立了起来，整个运行在虚拟地址空间上。所以当中段发生的时候，系统使用<strong>中断描述符表</strong>，写着自己所有的中断号。<br>中断描述符寄存器（IDTR）中存的就是中断描述符表（IDT）在内存中的位置以及大小。表按照中断号排序，每一个中断描述符在80386中被叫做一个门，<strong>中断门</strong>（中断），<strong>陷阱门</strong>（异常）。会根z中断发生的编号从表中取出对应的描述符（门），<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-15/43120327.jpg" alt=""><br>取回的描述符是这样的：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-15/96785647.jpg" alt=""><br>segment selector与offset用来描述在段机制下自己的中断响应函数的位置。segment selector负责在GDT里面找到对应的段，offset负责找对应的偏移量。找到函数之后，保存现场并执行响应函数。</p>
<p>在终端发生的时候，系统将会看一下产生中断的程序的特权级，决定应该怎样保护现场。如果在特权状态，不用换栈，只需要保存更少的东西，而处于用户状态下的程序在执行完中断响应函数之后还要从（？）退回到自己的用户栈，保存了更多的东西。</p>
<h3 id="正题：特权级提升"><a href="#正题：特权级提升" class="headerlink" title="正题：特权级提升"></a>正题：特权级提升</h3><p>从特权模式3切换到特权模式0，实际上就是响应一个中断，这就是上面图中的trap。</p>
<p>对于用户程序，os并不信任。当trap发生时，当前用户程序的运行状态会被存入到<strong>内核栈</strong>中，而用户栈并没有变化。这也是中断与普通函数调用的不同。<br>现在已经进入了特权模式，如果不作任何操作，只是调用一个iret，前面讲到的CS，SS特权级3又会被写入到寄存器里面，就又回到了用户态。为了能留在特权模式下，对栈进行伪造，假装在进入终端之前就是一个特权模式：也就是把上面提到的用户态发生中断的栈信息修改成特权模式发生中断的栈信息。这时iret，就可以留在特权模式下。</p>
<p>但是：在伪造的时候，SS被扔掉了。怎么回去呢？80386提供了一个<strong>TSS任务状态段</strong>，它几乎可以存下CPU上所有的寄存器的不止一份拷贝。TSS每个进程一个，会存下一个进程在切换特权状态的时候原特权状态下的SS的值。系统将会自己对TSS进行维护，以确保切换模式时栈的跳转。</p>
<p>TSS存在于哪里呢？在GDT里面有一个TSS的描述符：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-15/80552651.jpg" alt=""></p>
<p>80386中有4个特权模式，目前在虚拟化技术下只是用了3个。</p>
<p>有一个叫做TSR的寄存器，存着selector、base addr以及segment limit。便于直接找到TSS。</p>
<p>如果想要回到用户模式，进入trap，伪造一个从用户态过来的栈，iret即可。</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>用户程序可以通过系统调用访问内核服务，这个过程需要指定中断号，使用tarp或者特殊指令（SYSENTER/SYSEXIT）实现。</p>
<h2 id="关于这次实验"><a href="#关于这次实验" class="headerlink" title="关于这次实验"></a>关于这次实验</h2><p>这里的env就是课上讲的pcb。<br>父子进程的一个作用是父进程要为子进程收尸。</p>
<p>elf格式：linux下的可执行。<br>创建进程并执行elf：没有文件系统怎么办？<br>把指定的文件链接进目标文件，骗bootloader把程序也搬进内存。</p>
<p>-b binary path:-b帮我搬进来。binary这是个可执行程序。<br>然后重生成一个符号表。<br>把这个文件作为一个大数组缀到最后，然后直接使用这个数组。</p>
<p>编码的时候，这个数组还没有，链接的时候才有，怎么办？定义一个外部变量extern。<br>只需知道生成符号表的规则，然后按规则命名即可。</p>
<p>进来之后还只是一个大数组，还需要经过链接之后映射要对应的虚拟地址才能执行。</p>
<h1 id="Lab4-Preemptive-Multitasking"><a href="#Lab4-Preemptive-Multitasking" class="headerlink" title="Lab4-Preemptive Multitasking"></a>Lab4-Preemptive Multitasking</h1><p>lab3做完之后，当一个进程结束之后，就退出。在这个实验中，主要完成的是</p>
<p>本次实验主要是决定：在何时利用什么原则什么地方切换进程。<br>上下文怎么切换？其中一项：一定要把页表换掉，也就是把cr3中的页目录项换掉。之后，连接tlb也会失效，处理流水线，吧上一个进程的东西全部清理掉。</p>
<p>本实验大部分代码都已经写完了，主要是读代码。</p>
<p>如何实现更加有效的调度？更加频繁的调用schedule_yeid。</p>
<p>时钟中断的作用：打断正在执行的程序，调用sched_yield进行进程轮转</p>
<p>在本次实验中有一个时钟中断，你要做的就是在这个时钟中断的响应函数之中做一些事情，决定下一个进程怎么上去谁会上去（就是我们学习过的调度算法）</p>
<h2 id="多核处理器"><a href="#多核处理器" class="headerlink" title="多核处理器"></a>多核处理器</h2><p>一开始是因为没有在一个进程运行的时候调用另一个进程的机制，本实验中的多核只是实验的设计者希望我们体验一下在系统中有多个进程活动是一个什么样的状态，因此鼓励你去多弄几个核心。<br>只要是单核，其实每一个时刻只能有一个进程运行。</p>
<p>为什么会有多核处理器出现呢？在后摩尔时代，为了提升处理器的处理能力。</p>
<p>主核会在系统上电之后接管机器，他们的地位并不是平等的。</p>
<h3 id="现代处理器的休眠唤醒机制"><a href="#现代处理器的休眠唤醒机制" class="headerlink" title="现代处理器的休眠唤醒机制"></a>现代处理器的休眠唤醒机制</h3><p>现代处理器的模式一般有三种：active,idol,sleeping</p>
<p>CPU在关闭的时候，内存并不会关闭。休眠时，找到一个调度点，这时不调度了，存好有用的东西，然后cpu耗电量就会变得非常低。有一个cpu中的寄存器会标志自己刚刚是休眠了还是关机了。如果是休眠，那么内存里面所有的东西都还在，只需要调到该去的地方，然后进行一轮新的调度；如果不是休眠而是关机了，内存中的东西就被清空了，就是上电启动过程。</p>
<p>有时手机会坏掉，就是在锁屏（休眠）之后也会重新起动，这也就是cpu中的那个寄存器坏掉了。</p>
<p>那么，如果帮一个休眠的cpu准备好了它的休眠位以及内存，就可以让它认为它是一个刚刚休眠的cpu。</p>
<p>bsp是主核，在系统上电之后是只有主核启动，直到系统启动完之后，直到需要另外一个核心运行一个进程，bsp帮ap制造一个它刚刚在休眠的假象，然后唤醒它，这样这个ap就会认为自己是刚刚休眠的，然后继续执行。运行完之后，主核就会选择把这个核心给关掉，然后省电。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
<div>
  
</div>

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/12/哈希/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YaYi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Be With Me">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/12/哈希/" itemprop="url">哈希</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-12T23:57:33+08:00">
                2017-11-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>emmm…大二的时候DS只考了80，出来混的，总是要还的。</p>
<h2 id="不希望文件太多都小于512k，会占我的空间。"><a href="#不希望文件太多都小于512k，会占我的空间。" class="headerlink" title="不希望文件太多都小于512k，会占我的空间。"></a>不希望文件太多都小于512k，会占我的空间。</h2><h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><p>哈希其实没什么神秘的，不过是一群贪心的人的产物。</p>
<p>散列函数，将key转化为对应的value值得到索引。这个有诸如<strong>取模</strong>，<strong>ASCII平均</strong>，等等方法。橙皮书上有一种sfold，似乎性能会更好一些。</p>
<h2 id="开哈希"><a href="#开哈希" class="headerlink" title="开哈希"></a>开哈希</h2><p>开哈希类似于静态链表，每一个value对应一个链表，成为挂着的桶。</p>
<h2 id="闭哈希"><a href="#闭哈希" class="headerlink" title="闭哈希"></a>闭哈希</h2><p>闭哈希将node存储在给定的一个数组中。这个数组的下标将作为value的索引值，由于value可能重复，需要探查方式，有很多方式，比如线性探查与二次探查。</p>
<p>关于闭哈希的删除，其实不必真的每次都向前挪，而是增加一个“墓碑”，它代表这里没有数据可以被插入，但是又不是真的空因为需要继续向前探查。<br>当次数多了性能就会下降，一种解决方式是向前挪，另一种是重新散列。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
<div>
  
</div>

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/12/语言们的输出格式控制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YaYi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Be With Me">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/12/语言们的输出格式控制/" itemprop="url">语言们的输出格式控制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-12T23:21:11+08:00">
                2017-11-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/语言/" itemprop="url" rel="index">
                    <span itemprop="name">语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.cnblogs.com/leewiki/archive/2011/12/13/2286168.html" target="_blank" rel="external">待整理</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
<div>
  
</div>

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/09/编译原理——词法分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YaYi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Be With Me">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/09/编译原理——词法分析/" itemprop="url">编译原理——词法分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-09T00:44:47+08:00">
                2017-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编译原理/" itemprop="url" rel="index">
                    <span itemprop="name">编译原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <p>我有罪….我先是用学编译的时间逛了淘宝….然后又用学编译的时间逛了六维…..我有罪….\infty</p>
<blockquote>
<p>时间：1012cp3 3:15开始 词法分析器介绍</p>
<p>编译并不是一件轻松的事情，对于较大的系统，编译的速度并不理想，这也是为什么我们需要优化编译技术。</p>
</blockquote>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>词法单元（单词）</strong>：由一个词法单元名以及一个可选的属性值组成。名即是语法分析器的输入符号token。<br><strong>模式</strong>：一个词法单元的词素可能具有的形式。一个词素不能与两个或多个词法单元进行匹配（二义性）。<br><strong>词素</strong>：源程序中的字符序列，是程序中实际出现的字符串。</p>
<blockquote>
<p>在lex与yacc中，有时会有一个全局变量。他保存了当前词素（词法单元：关于这里，龙书里面的和wg写的不一样呢？）的属性值，这个属性值可以被记录在语法树上。</p>
</blockquote>
<h2 id="词法分析器要干些什么？"><a href="#词法分析器要干些什么？" class="headerlink" title="词法分析器要干些什么？"></a>词法分析器要干些什么？</h2><p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-12/6339247.jpg" alt=""></p>
<ol>
<li>读入源程序字符，生成词素，确定词法单元序列</li>
<li>与符号表进行交互</li>
<li>过滤掉源程序中的<strong>注释</strong>与<strong>空白</strong></li>
<li>将编译器生成的错误信息与位置联系</li>
<li>预处理：扫描阶段完成不需要生成词法单元的简单处理；词法分析阶段处理扫描阶段的输出并生成词法单元</li>
</ol>
<blockquote>
<p>跳过了一些东西</p>
</blockquote>
<h1 id="正则表达式（正规表达式、正规式）"><a href="#正则表达式（正规表达式、正规式）" class="headerlink" title="正则表达式（正规表达式、正规式）"></a>正则表达式（正规表达式、正规式）</h1><p>为什么需要正则表达式来描述字符串序列呢？<br>像在上下文无关文法中所描述的那样，因为字符们所组成的可能的字符串是<strong>无穷</strong>的。</p>
<p>单词是什么？单词的本质就是<strong>符号串的集合</strong>。正则表达式就是代替了自然语言对特定符号串集合的描述。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>符号表</strong>：符号的有穷集合<br><strong>符号串</strong>：字母表中符号构成的有穷序列。也成<strong>句子</strong>，<strong>字</strong>。<strong>|s|</strong>代表<strong>字符串s的长度</strong>，$\epsilon$是空字符串。<br><strong>语言</strong>：是一个给定符号表上的特定的符号串的集合。</p>
<p>比如：给定符号表{1,0}，有符号串01100010，一种语言是{0，1，00，11，000，111….}即串中只含一种字符的字符串集合。</p>
<p>特例：$\varnothing$是<strong>空语言</strong>。{$\epsilon$}是只含空串的语言。</p>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="符号串的运算"><a href="#符号串的运算" class="headerlink" title="符号串的运算"></a>符号串的运算</h3><p><strong>连接</strong>：x=hou y=se xy=house    s$\epsilon$=$\epsilon$s=s  (emmmm说好的不能这样写呢？)<br><strong>幂</strong>：$s^n=s^(n-1) * s^1$</p>
<h3 id="语言的运算"><a href="#语言的运算" class="headerlink" title="语言的运算"></a>语言的运算</h3><p>下表中运算符的优先级由低到高</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算</th>
<th style="text-align:center">定义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">并</td>
<td style="text-align:center">$L\cup M={ s \ s\in L 或 s\in M} $</td>
</tr>
<tr>
<td style="text-align:center">交</td>
<td style="text-align:center">$LM={ st \ s\in L 且 t\in M} $</td>
</tr>
<tr>
<td style="text-align:center">Kleen闭包</td>
<td style="text-align:center">$L^*=\cup_{i=0}^\infty L^i$</td>
</tr>
<tr>
<td style="text-align:center">正则闭包</td>
<td style="text-align:center">$L^*=\cup_{i=1}^\infty L^i$</td>
</tr>
</tbody>
</table>
<p>$$\color{red}{正则表达式&lt;-&gt;语言运算的简洁描述}$$</p>
<h2 id="正则表达式定义"><a href="#正则表达式定义" class="headerlink" title="正则表达式定义"></a>正则表达式定义</h2><p>字母表$\sum$上的正规式r的定义规则，以及r所表示语言L(r)定义：</p>
<ol>
<li>$\epsilon$是正规式，表示语言{$\epsilon$}</li>
<li>若$a\in \sum$则a是正规式，表示语言{a}</li>
<li>r , s是正规式，表示语言L(r)与L(s)，则：<ol>
<li>(r)|(s)是正规式，表示语言L(r)$\cup$L(s)</li>
<li>(r)(s)是正规式，表示语言L(r)L(s)</li>
<li>$(r)^*$是正规式，表示语言$(L(r))^*$</li>
<li>(r)是正规式，表示语言L(r)</li>
</ol>
</li>
</ol>
<p>第三条的四条，优先级从上到下依次升高。</p>
<blockquote>
<p>$(a|b)^*$={所有由a、b组成的符号串}</p>
</blockquote>
<p>正规式<strong>等价</strong>：r=s &lt;-&gt; L(r)=L(s)</p>
<p>正则运算的特性:<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-12/3363060.jpg" alt=""></p>
<p>可以像产生式那样，为正规式指定名字：</p>
<blockquote>
<p>num -&gt; r1<br>其实，上下文无关文法的描述能力包含了正则表达式的描述能力。所有可以被正则表达式描述的都可以被上下文无关文法描述，但是正则表达式并不能描述某些上下文无关文法可以描述的东西。<br>那么为什么需要正则表达式来实现词法分析器？</p>
<ol>
<li>简化编译器的设计：使每一阶段需要做的事情更加简单清晰</li>
<li>提高编译器的效率：使用专门的字符缓冲技术提高编译速度</li>
<li>增强编译器的可移植性：输入设备相关的特殊性被限制在词法阶段</li>
</ol>
</blockquote>
<p>下面举一个例子：</p>
<blockquote>
<p>无符号整数：<br>digit -&gt; 0|1|2|…|9<br>digits -&gt; digit digit*  其实也可以是$digit^+$<br>optional_fraction -&gt; .digits | $\epsilon$<br>optional_exponent -&gt; (E(+|-|$\epsilon$)digits)|$\epsilon<br>num -&gt; digits optional_fraction optional_exponent</p>
</blockquote>
<p><strong>符号简写：</strong></p>
<p><strong>+</strong>:一个或多个实例<br><strong>?</strong>:0或1个实例：$r?=r|\epsilon$$\rightarrow$$L(r)\cup {\epsilon}$<br><strong>[]字符集</strong>:[abc]=&gt;a|b|c、[a-z0-9]=&gt;a|b|..|z|0|1..|9</p>
<h2 id="非正规集"><a href="#非正规集" class="headerlink" title="非正规集"></a>非正规集</h2><p><strong>正规式无法描述的语言</strong>：{wcw|w是a、b组成的字符串}正规式无法描述平衡或嵌套的结构<br><strong>正规式只能表示</strong>：有限的重复、一个给定结构的无限重复</p>
<p>关于正规式的练习，参考<a href="http://blank" target="_blank" rel="external">第三章练习</a></p>
<h1 id="Lex"><a href="#Lex" class="headerlink" title="Lex"></a>Lex</h1><p>使用流程与yacc类似。</p>
<p>$\color{red}{ATTENTION!</p>
<p>在使用project wizard建立lex的时候你写的那个词法分析器的名字就是那个名字，</p>
<p>你最好别自己再修改，否则在VS里面运行不出来！！！}$</p>
<p>给的是字符流，出来的是单词流。</p>
<p>规则段放正则表达式与语义动作。</p>
<p>第四次作业词法分析器设计将会上传。<a href="http://blank" target="_blank" rel="external">click here to get</a></p>
<h1 id="有限自动机"><a href="#有限自动机" class="headerlink" title="有限自动机"></a>有限自动机</h1><p>有限自动机可以直接转换成程序。</p>
<h2 id="NFA"><a href="#NFA" class="headerlink" title="NFA"></a>NFA</h2><h1 id="从正则表达式到自动机"><a href="#从正则表达式到自动机" class="headerlink" title="从正则表达式到自动机"></a>从正则表达式到自动机</h1><p>从这之后，正是lex所做的事情。</p>
<p>在这一节里，将介绍两个过程：一个是正则表达式到NFA，另一个是NFA到DFA。之所以让NFA做一个过渡，是因为正则表达式直接到DFA的算法很复杂。本次更新掠过。</p>
<p>NFA与DFA的性能差别很大：NFA占用空间比较少，但是使用NFA进行词法分析需要在错误态停止，可能需要花费$O(2^n)$的时间复杂度；DFA占用空间很大（最坏情况下$O(2^n)$），但是使用它进行词法分析的时候接近线性时间。</p>
<h2 id="正则-gt-NFA"><a href="#正则-gt-NFA" class="headerlink" title="正则 -&gt; NFA"></a>正则 -&gt; NFA</h2><p>正则表达式构造NFA使用<strong>MacMaughton-Yamada-Thompson算法</strong>。简称<strong>Thompson算法</strong>。这个算法描述如下：</p>
<p><strong>基本规则：</strong></p>
<h2 id="自动机运转"><a href="#自动机运转" class="headerlink" title="自动机运转"></a>自动机运转</h2><blockquote>
<p>s $\leftarrow$ e -closure({s0});<br>c $\leftarrow$ nextchar;<br>while c $\neq$ eof do<br> s $\leftarrow$ e -closure(d(s,c));<br> c $\leftarrow$ nextchar;<br>end;<br>if S$\cap$F$\neq$ $\varnothing$ then return “yes”<br>         else return “no”</p>
</blockquote>
<hr>
<blockquote>
<p>s $\leftarrow$ s0;<br>c $\leftarrow$ nextchar;<br>while c $\neq$ eof do<br> s $\leftarrow$ d(s,c);<br> c $\leftarrow$ nextchar;<br>end;<br>if s is in F then return “yes”<br>            else return “no”</p>
</blockquote>
<p>前面提到了，NFA占空间更少，DFA识别字符串更快，贪心的人类啊希望能糅合这两者的优点。看前面的NFA代码，其实在第四行那句，实际上就是前面提到的构造DFA的过程。人们想到使用Cache。使用NFA，当NFA构造出DFA的一个状态时，就把这个状态构造的条件以及状态本身存到cache里面。当while进一个c的时候，首先看一看现今状态加上c到达的态是不是已经存在cache，如果存在里面，最耗时间的那一部分就不用运行了。cache的管理仍然是程序局限性原则。占用空间不会太大以期望达到折衷的效果。</p>
<p>如果要构造出一个Lax，需要将所有的正则表达式得到的NFA进行一个并操作（保留各自的终态以区分）。然后构造它的DFA。</p>
<p>值得注意的是，这样不能在一个终态停止，而是在错误态终止并退回到最近经过的那个终态（每经过一个终态，记录当前的<strong>输入指针</strong>以及<strong>匹配模式</strong>）。以防止找到前缀，产生错误。这种方法是<strong>最长前缀法</strong>，在前面已经提到过。</p>
<h1 id="DFA优化"><a href="#DFA优化" class="headerlink" title="DFA优化"></a>DFA优化</h1><p>DFA状态数其实不会太多的影响时间复杂度，当状态变少的时候，将会减少存储空间的消耗。</p>
<p><strong>区分：</strong>一个符号串可区分两个状态：这一个串<strong>从这两个状态出发</strong>在DFA上得到的结果一个是accept，一个是reject。在做区分的时候，其实可以看到：最终字符串得到的终态在不同集合，则他们是可区分的。</p>
<blockquote>
<p>Ex<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-9/60487283.jpg" alt=""><br>a不能区分状态A与B。而且还可以看到，以a开头的所有字符串都不可能区分A与B了。再进一步看到，a不可能区分任意两个，因为所有状态在经过a的状态迁移之后都到达了状态B。<br>同理，b不可能区分ACE，以b开头的都不能区分ACE。但是b却可以区分BD。<br>不要忘记，$\epsilon$可是可以区分的。而且他的区分应该被放在最前面，那是因为$\epsilon$区分了终态与其他状态。</p>
</blockquote>
<p>在区分的过程中发现了这样一个规律：如果对于串s，A状态与B状态经过了s都到达同一个状态C，那么以s做前缀的字符串都不可能区分A与B了。当所有字符串都不能区分A与B的时候，可以把A与B合并成同一个状态。但是对于无穷的字符串，怎么确定 “所有都不行” 呢？ 在前面，我们已经提出了一个解决方案——当前缀s不行的时候，所有的sx都不行了。但是，即使是有了这个规律，使用“不行”的这种方法解决问题仍会显得繁琐。</p>
<p>真正在执行的时候，实行的是<strong>分裂</strong>，这样，通过有顺序地枚举字符串，将能被区分开的状态分开。这样对于前面的<strong>不同集合</strong>的说法，也能更好地理解。</p>
<p><strong>算法描述：</strong>首先使用$\epsilon$区分终态与非终态，将它们分为两个集合。随后，像子集构造法那样，有顺序地枚举输入字符串，将那些经过状态迁移能到达终态（不同集合）的状态剔除出去组成一个新的集合（如果两者到达同一个集合，这两者是不能区分的，应该在同一个集合），对于那些含有多个元素的集合，如果经过一系列不同的状态迁移到达不同的集合，仍需要继续分开。直到不再产生新的集合。</p>
<blockquote>
<p>仍然使用上面的例子，进行分裂的过程：</p>
<ol>
<li>$\epsilon$ -&gt; {A,B,C,D}、{E}</li>
<li>a -&gt; {A,B,C,D}  ({B,B,B,B})-&gt;全部一样，以a打头的不用再试</li>
<li>b -&gt; {A,B,C}{D}  ({C,D,C,E})</li>
<li>b -&gt; {A,C}{B}{D}  ({C,C,D})  -&gt; 不同集合</li>
</ol>
<p>最终得到的最小DFA：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/65136532.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/4345780.jpg" alt=""></p>
</blockquote>
<p>最后使用新的状态进行迁移的时候，一定不会出现问题。</p>
<h1 id="补充：从自动机到正则表达式"><a href="#补充：从自动机到正则表达式" class="headerlink" title="补充：从自动机到正则表达式"></a>补充：从自动机到正则表达式</h1><p>可以从一个DFA或NFA得到对应的正则表达式。但是这种方式并不是总是简单的，他只是提供了一个模糊的思路，当一个DFA很复杂的时候，还是需要有聪明才智才行。<br>这里只是简单的给出这个方法，具体可查看<a href="http://note.youdao.com/noteshare?id=9fa52c6fcb1a6637fbdb36f669852abe&amp;sub=9A6AEF1D34C044E68D8BD1AD2057996E" target="_blank" rel="external">这个文件</a>。</p>
<p>为了使讨论更加简单，我们强制一个DFA/NFA应该有下列特性：</p>
<ol>
<li>初态可以到达任意其他状态，没有状态可以通过状态迁移到达初态</li>
<li>只有一个终态，终态不能通过状态迁移到达非终态</li>
<li>初态不能是终态</li>
<li>除了初态与终态，其他状态彼此相连</li>
</ol>
<p>这四个条件看起来很可怕，其实当我们引入了$\varnothing$并根据情况添加初态终态之后，很容易可以把一个DFA/NFA转为一个符合要求的有限自动机。</p>
<p>以一个例子来说明：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/17062978.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/80510309.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/99180281.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/86068172.jpg" alt=""></p>
<p>为了不让自己沾沾自喜，必须指出上面给出的例子很简单，看下面这个：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/70925658.jpg" alt=""></p>
<p>由于生成initstate的一个要求是，不能有进入initstate的箭头，好，像上面一样加一个init，加一个Ac，随即，在删除A的时候就会发现问题。这尼玛转来转去的究竟怎么写边上的正则表达式啊？！</p>
<h1 id="能不能与好不好"><a href="#能不能与好不好" class="headerlink" title="能不能与好不好"></a>能不能与好不好</h1><p>在龙书的第九章。</p>
<ol>
<li><p>流程可否更加简洁？ 正则 -&gt; DFA：本质上还是做子集构造法-吧正则的某些位置对应NFA里面状态，位置集对应NFA的状态集</p>
</li>
<li><p>优化结果？ 最小DFA</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
<div>
  
</div>

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/06/OS/chap3-内存管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YaYi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Be With Me">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/06/OS/chap3-内存管理/" itemprop="url">chap3-内存管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-06T14:13:37+08:00">
                2017-11-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/课/" itemprop="url" rel="index">
                    <span itemprop="name">课</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="内存中的概念"><a href="#内存中的概念" class="headerlink" title="内存中的概念"></a>内存中的概念</h1><p><strong>地址空间</strong>：一个进程可用于寻址内存的一套地址集合。<br><strong>内存管理</strong>：逻辑地址与物理地址之间的映射<br><strong>内存管理的特性</strong>：</p>
<ol>
<li>高效：使得更多的地址可以被使用（其实都是骗–人–进程的）</li>
<li>合理：alloc、free、locate、protect</li>
<li>便利：？<br><strong>内存管理class</strong></li>
<li>简单机制：静态固定</li>
<li>复杂机制：交换、paging</li>
</ol>
<blockquote>
<p>为什么会有这种欺骗的行为存在呢？<br>程序员希望拥有一个又大又快又永久的存储器，希望他们的寻址方式是统一的；但是实际上，又快又大又永久的存储器目前还是不现实的。<br>现在我们有的是：</p>
<ul>
<li>cache：非常快，昂贵</li>
<li>内存：速度适中，价格适中</li>
<li>硬盘：慢，廉价</li>
</ul>
</blockquote>
<p>在计组课里面应该就学过一个各种存储器的速度金字塔。最快的寄存器甚至是按照字节来计算的存储设备。</p>
<p>于是提出问题：如何使用有限的高速存储设备以及较多的低速存储设备来提高的响应速度呢？</p>
<h2 id="内存管理的任务"><a href="#内存管理的任务" class="headerlink" title="内存管理的任务"></a>内存管理的任务</h2><ol>
<li>申请与撤回：资源管理</li>
<li>地址转换：映射管理</li>
<li>分享与保护</li>
<li>空间扩张：你本来不可能占4G的，你非说你占了4个G</li>
</ol>
<h3 id="动态重定位"><a href="#动态重定位" class="headerlink" title="动态重定位"></a>动态重定位</h3><blockquote>
<p>从接口中知道，CPU希望访问一个地址的时候，会给出对应的地址（上总线）以及对应的读写信号etc。</p>
<p>对程序员来说，每一个程序就是一方天地，并不想在程序里面去思考你os应该解决的存储问题，程序认为自己的地址都是从m开始，想访问哪里就访问哪里，但是os并不可以这样做。<br>就像在实验中提到的那样，程序的elf（exe）文件中会有自己的链接地址，这个地址表示程序假设自己被加载到内存的位置，os加载运行的时候需要进行<strong>重定位</strong>，对程序中相关的地址都经过变换。</p>
</blockquote>
<p>对于上述问题，使用两个寄存器来解决，一个是<strong>基址寄存器</strong>，一个是<strong>界限寄存器</strong>，它们在每一个CPU中都存在。基址寄存器存储当前进程的开始物理地址，界限寄存器中存储该程序长度。</p>
<p>当使用一个地址a的时候，首先判断a是否大于界限寄存器中存储的值，如果不是，再将a加上基址寄存器中的值，然后送到地址总线。这些动作都是CPU硬件完成的。</p>
<h2 id="monoprograming：单道程序处理"><a href="#monoprograming：单道程序处理" class="headerlink" title="monoprograming：单道程序处理"></a>monoprograming：单道程序处理</h2><h2 id="multiprogramming"><a href="#multiprogramming" class="headerlink" title="multiprogramming"></a>multiprogramming</h2><p>支持多个进程的os内存管理都需要做什么？</p>
<ol>
<li>申请空间、释放空间</li>
<li>地址转换、内存保护（several method）</li>
<li>CPU利用：MTF的表现</li>
<li>内存扩张：更加柔韧的内存管理</li>
</ol>
<p>使用partition来为每一个进程分配空间</p>
<hr>
<p><strong>动态分区分配</strong>：当程序被加载执行时，分配一个进程制定大小可变的分区，在此分区内地址连续<br>os需要维护所有进程的已分配数据结构以及空闲分区。<br>$$\color{red}{whats this}$$</p>
<h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><p>通常情况下内存是不够用的。仅仅Windows后台应用都会占据一些内存，更不用说开浏览器，开vs等等。为了处理这样的情况，需要，把某一些进程放到外存，为当前运行进程提供内存空间。</p>
<p><strong>交换</strong>：把一个完整的进程调入内存，使该进程运行一段时间，然后存回磁盘。<br>这里提到的交换还不是后面说到的页面置换。</p>
<p><strong>交换中的内存管理</strong>：</p>
<ol>
<li>数据结构与算法：如何描述内存的使用 ； 如何申请、free内存</li>
<li>函数执行：如何消除内存碎片</li>
<li>核心问题的方法？灵活性、稳定性、扩展性</li>
</ol>
<p>关于内存碎片：<br>每次移入内存都是固定的大小，但是有时会移出去，有时会移进来，最终可能会产生许多内存空洞。为了消除内存空洞，需要进行<strong>碎片整理（内存紧缩）</strong>，这个操作很花时间。</p>
<p><strong>碎片整理：紧缩</strong>：<br>什么时候移动？</p>
<p><strong>碎片整理：分区对换</strong>：<br>通过抢占并回收处于等待状态进程的分区，增大可用空间。</p>
<p>核心问题：<br>写程序肯定会经常new吧，这个new是动态分配的内存，只有在运行到这里的时候才会去帮你分配，这种空间是不可预知的，无法准确计算需要空间的最大值。于是在为没一个进程分配空间的时候都可以多分一点。<br>这种分法带来新的问题：<br>将进程换回外存的时候其实并不需要换那些没有有效数据的地址，这是一种浪费。</p>
<h3 id="交换的空闲内存管理"><a href="#交换的空闲内存管理" class="headerlink" title="交换的空闲内存管理"></a>交换的空闲内存管理</h3><h4 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h4><p>就像lab5中的bitmap一样，0代表没有占用，1代表占用。不同的是，这里一个bit代表可能是内存中的一个<strong>分配单元</strong>，可能是4byte，可能是其他。</p>
<p>但是使用位图的话，不利于分配连续的空间，因为需要查找连续的固定字节空间的时间可能比查找一个分配单元空闲多花更多时间。</p>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>这并不是lab2中使用的方法。</p>
<p>维护一个空闲内存段链表与已用内存段链表。在每一个节点标志其状态以及开始地址以及连续地址。</p>
<p>这种方式对上述问题友好。新的问题是如何进行节点的更新与回收，这需要节点的合并与删除、增加等操作<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/19805712.jpg" alt=""></p>
<p><strong>分区管理分配算法</strong>：</p>
<p>当进行内存申请的时候，希望能尽量避免做内存紧缩，这就需要更好的申请方式，而不是每次遇到剩余空间比自己更多的就决定要这个块。</p>
<ol>
<li>首次适配：时间性能好、但会容易导致内存碎片</li>
<li>下次适配：从上次分配的分区开始查找。时间性能好、空闲去分布均匀，较大的空闲分区不易保留</li>
<li>最佳适配：较大空间保留，碎片小而多</li>
<li>最坏适配：着更大的分配：较大分区不会被保留<blockquote>
<p>最佳适配与最坏适配都可以通过维护二级索引来实现更快的查找</p>
</blockquote>
</li>
<li>快速适配：链表的改变十分费劲。为常用大小的块提供专门的索引</li>
</ol>
<h3 id="总结：mono-multi-swap"><a href="#总结：mono-multi-swap" class="headerlink" title="总结：mono\multi\swap"></a>总结：mono\multi\swap</h3><ol>
<li>位图连续空闲空间寻找</li>
<li>链表的空洞</li>
<li>交换的缺点：<ol>
<li>内存碎片</li>
<li>内存的动态增长</li>
<li>如何利用小空间运行大进程？</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Mono</th>
<th style="text-align:center">MFP</th>
<th>Swapping</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Size of proc</td>
<td style="text-align:center">total mem</td>
<td style="text-align:center">partion size</td>
<td>total size of free mem</td>
</tr>
<tr>
<td style="text-align:center">Alloction</td>
<td style="text-align:center">static</td>
<td style="text-align:center">static</td>
<td>dynamic</td>
</tr>
<tr>
<td style="text-align:center">multi-programming</td>
<td style="text-align:center">unsupported</td>
<td style="text-align:center">supported</td>
<td>supported</td>
</tr>
<tr>
<td style="text-align:center">mem space</td>
<td style="text-align:center">continuous</td>
<td style="text-align:center">continuous</td>
<td>continuous</td>
</tr>
<tr>
<td style="text-align:center">mem growth</td>
<td style="text-align:center">unsupported</td>
<td style="text-align:center">un</td>
<td>supported</td>
</tr>
</tbody>
</table>
<p>除了上述的碎片整理，还有<strong>覆盖</strong>技术：（程序员控制</p>
<ol>
<li>划分功能区（ifelse）</li>
<li>确定模块之间的覆盖关系</li>
<li>执行之前预先加载并交换</li>
</ol>
<p>其实是很不好完成的，基础就不好完成，不好判断功能模块，要求的编程技巧太高。</p>
<p>但是，从覆盖技术引出了一个：虚拟内存</p>
<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><ol>
<li>进程的程序段、数据段、堆栈段的总和可以大于物理存储空间</li>
<li>进程不必完全装入内存</li>
<li>os定时将暂且不用的信息换出内存</li>
<li>os负责将换出去的换回来</li>
</ol>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><ol>
<li>页：描述进程逻辑空间的单元</li>
<li>页框：描述物理内存中对应的单元</li>
<li>页表：页与页框之间的映射</li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/6075684.jpg" alt=""></p>
<p>在标准的4KB页面中，位数分别是10-10-12</p>
<p>页转换在mmu中完成，CPU访问到的，在程序之中执行的都是虚拟地址。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/6791125.jpg" alt=""></p>
<p>还记得在计组实验中还被问到了1/0是干吗的，至今难忘。</p>
<p>可能会有是否越界的比较（在标准中不存在，这是因为数据都是正好的）</p>
<hr>
<p>为了考试…</p>
<p>虚拟地址（英语：Virtual address space）在電腦的专用术语中是指标识一个虚拟（非物理地址）的实体地址。虚拟地址这个术语常用在虚拟内存和虚拟网络地址当中。from <a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80" target="_blank" rel="external">wiki</a></p>
<p>在计算机科学中，物理地址（英语：physical address），也叫实地址（real address）、二进制地址（binary address），它是在地址总线上，以电子形式存在的，使得数据总线可以访问主存的某个特定存储单元的内存地址。from <a href="https://zh.wikipedia.org/wiki/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80" target="_blank" rel="external">wiki</a></p>
<p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如RAM）的使用也更有效率。from <a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98" target="_blank" rel="external">wiki</a></p>
<hr>
<h3 id="页表项结构"><a href="#页表项结构" class="headerlink" title="页表项结构"></a>页表项结构</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><strong>page number</strong>：逻辑空间中的页id，<br><strong>frame num</strong>：物理空间中页框的id<br><strong>p/a</strong>：页是不是在内存里面<br><strong>protected</strong>：r/w/e，记录页允许的访问<br><strong>modified</strong>：是不是被修改（脏位<br><strong>referenced</strong>：这个页有没有被使用<br><strong>disable caching</strong>：页面禁用高速缓存</p>
<blockquote>
<p>why 禁用高速缓存？<br>对于那些映射到<strong>设备寄存器</strong>而不是普通物理内存的页面来说，不希望在自己等待设备对自己刚发出去的指令做反应的时候自己的导向地址竟然是cache而不是外部接口。</p>
</blockquote>
<p>in ppt:</p>
<table>
<thead>
<tr>
<th style="text-align:center">page num</th>
<th>p/a</th>
<th>frame num</th>
<th>protected</th>
<th>disable caching</th>
<th>referenced</th>
<th>modified</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h4 id="Design-issue"><a href="#Design-issue" class="headerlink" title="Design issue"></a>Design issue</h4><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/52513606.jpg" alt=""></p>
<h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>10-10-12</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/10468357.jpg" alt=""></p>
<p>除了修改位，每集页表项都是一样的。在非底层页表中，取值为0</p>
<p>其实还可以更多级。</p>
<h3 id="加速分页过程：TLB"><a href="#加速分页过程：TLB" class="headerlink" title="加速分页过程：TLB"></a>加速分页过程：TLB</h3><p>快表：一个将虚拟地址直接映射到物理地址的小型硬件设备，通常在MMU中，其中的项基本不超过64个。</p>
<p>将虚拟地址放在MMU中进行转换时，首先查快表：将该页面号与TLB中所有项同时（并行）进行匹配，如果命中，而且不违反保护位，页框号可以直接从TLB拿出，不必再进行内存访问（访问存储有页表项的内存），如果保护位不允许，就会发生一个页面访问错误。</p>
<p>如果不命中MMU就从内存中找页表项，并将最终找到的页号与页框号等拿出，淘汰tlb中某一个项并添加新来的项。</p>
<p>当从tlb中淘汰值的时候，记得将tlb中存储的修改位换到页面。</p>
<p>tlb表项（示例）</p>
<table>
<thead>
<tr>
<th style="text-align:center">有效位</th>
<th style="text-align:center">虚拟页面号</th>
<th style="text-align:center">修改位</th>
<th style="text-align:center">保护位</th>
<th style="text-align:center">页框号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">123</td>
<td style="text-align:center">1</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">31</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">87</td>
<td style="text-align:center">0</td>
<td style="text-align:center">RX</td>
<td style="text-align:center">87</td>
</tr>
</tbody>
</table>
<p>…</p>
<p>既然TLB这么厉害，为什么不搞一个很大很大的TLB呢。<br>TLB属于高速设备，功耗非常大。</p>
<h3 id="加速分页过程：软件TLB"><a href="#加速分页过程：软件TLB" class="headerlink" title="加速分页过程：软件TLB"></a>加速分页过程：软件TLB</h3><p>当tlb失效的时候，mmu将会告诉os，让os找到要找的页面，从tlb删除一个页面，把这个页加上去。<br>必须在有限的指令内完成，因为tlb失效更加频繁。</p>
<p>但是，当tlb更大一些，这种机制就会变得很有效。这样做的好处是得到一个简单的mmu，从而为CPU其他性能改善提供了空间。</p>
<p>os可以“直觉”那些页面要被使用，然后预先加载到tlb。</p>
<p>《？》<br>在内存固定位置维护大的tlb表项的软件高速缓存。首先检查这个缓存，os可以实质性地减少失效。</p>
<p><strong>软失效</strong>：页面在内存中但是映射不在tlb。<br><strong>硬失效</strong>：页面本身不再内存（当然也不在tlb<strong>so为什么是这样</strong>）</p>
<h3 id="针对大内存：反置页表"><a href="#针对大内存：反置页表" class="headerlink" title="针对大内存：反置页表"></a>针对大内存：反置页表</h3><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/42494861.jpg" alt=""></p>
<p>为什么会出现反置页表？<br><a href="http://kejiao.cntv.cn/20110905/100155.shtml" target="_blank" rel="external">在64位系统下内存</a><br>64位系统，如果仍然保持一个页是4K，那么一共需要有$2^52$个页，只是存储这些页就花费几百G的空间，显然是不合理的。</p>
<p>而目前面临的状态是实际的内存很小，于是可以为每一个页框记录一个页表项。这样对于4K的页以及1G的ram只需要$2^18$个页表项即可。<br>页表项中记录哪一个(进程,虚拟页面)对应于该页框。<br>虽然节省空间，但是不足也是很明显的：<br>将虚拟地址转换为物理地址变得困难</p>
<p>可以使用tlb。但是当tlb失效的时候就很难。<br><strong>基于hash</strong>：把虚拟页号与进程号作为输入，得到的散列值来寻找。</p>
<p><strong>hahs冲突</strong></p>
<p><strong>虚拟存储的基本特征</strong>：</p>
<ol>
<li>不连续（$\color{red}{啥叫虚拟地址空间使用非连续？是说各个区分开吗}）</li>
<li>大用户空间：提供给用户的虚拟地址空间可以大于实际的物理内存</li>
<li>部分交换：虚拟存储只对部分虚拟地址进行调入调出。（不会像交换一样一下一个进程）</li>
</ol>
<p><strong>虚拟页式存储的外存管理</strong>：</p>
<ol>
<li>在哪里保存没有被映射的页？<ol>
<li>需要可以方便的找到在外存中的页面内容</li>
<li>交换空间（磁盘或文件）：采用特殊格式保存没有被映射的页面</li>
</ol>
</li>
<li>虚拟页式存储中的外存选择<ol>
<li>代码段：可执行二进制文件</li>
<li>动态加载的共享式程序段</li>
<li>其他段：交换空间</li>
</ol>
</li>
</ol>
<p><strong>虚拟页式存储的性能</strong>：有效存储访问时间</p>
<p>EAT=访存时间*(1-p)+缺页异常处理时间*缺页率p</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/82455336.jpg" alt=""></p>
<h2 id="pagingsys的工作流程"><a href="#pagingsys的工作流程" class="headerlink" title="pagingsys的工作流程"></a>pagingsys的工作流程</h2><ol>
<li>全局pgtable初始化</li>
<li>创建进程</li>
<li>获取首指令<ol>
<li>pgfault</li>
<li>加载页</li>
<li>更新pgtable</li>
<li>更新tlb</li>
</ol>
</li>
<li>页替换<ol>
<li>pgfault</li>
<li>选择一个页，写回磁盘</li>
<li>把新页换到这里</li>
<li>更新tlb</li>
</ol>
</li>
</ol>
<h2 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h2><ol>
<li>如果内存还有剩余页，分配；把希望访问的页从disk装到这个物理空间，把这个页对应页表的a/p置为1，物理地址映射到新分配的物理地址，重新执行引起缺页中断的指令</li>
<li>如果内存没有剩余的页面，依据页面置换算法选择一个将会被替换的物理页，如果这个物理页的值被修改过，把内存中的值写回外存，把对应逻辑页的a/p置为0，把希望访问的物理页装到这个空间，修改物理页对应的逻辑页面的指示物理页地址以及存在位，重新执行却页指令。</li>
</ol>
<blockquote>
<p>我现在认为，前面提到的挂起状态与现在说的“为了腾内存空间而将一些进程存储的东西先存到外存”是不一样的。<br>挂起的意思应该是pcb都被移动到了外存，根本无法找到这个进程的运行情况，地址空间等；但是这里仅仅是为了节省内存空间，将某些页换到了外存，该进程还是可以继续运行的。只是在需要用这些页的时候可能会引发缺页中断。<br>挂起存在的理由不仅仅是为了节省内存，还有一点是为了更有效的调度，因为所有调度算法考虑的都是就绪队列的进程。</p>
</blockquote>
<h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ol>
<li>缺页中断：需要的页不存在内存之中</li>
<li>页替换：当所有的物理页都被占用；选择一个页被换出去</li>
<li>表现：<ol>
<li>抖动：耗时，低效率</li>
<li>预测：在需要之前就把页面加载进来</li>
<li>最优方案：最远将来（不现实）</li>
</ol>
</li>
</ol>
<p>页面置换算法的功能与目标：</p>
<ol>
<li>功能：当出现缺页异常并且物理内存已经被占满，调出一个物理页给新需要的页使用</li>
<li>设计目标：极可能减少页面的调入调出次数</li>
</ol>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><h3 id="最优页面置换算法"><a href="#最优页面置换算法" class="headerlink" title="最优页面置换算法"></a>最优页面置换算法</h3><p>通常是衡量置换算法的标准</p>
<p>置换在未来最长时间内不访问的页面</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/96462944.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/314073.jpg" alt=""></p>
<h3 id="最近未使用：NRU"><a href="#最近未使用：NRU" class="headerlink" title="最近未使用：NRU"></a>最近未使用：NRU</h3><p>发生pgfault的时候，检查所有页面，将页面分为四类：</p>
<ol>
<li>没有访问 没有修改</li>
<li>没有访问 已经修改该</li>
<li>已经访问 没有修改</li>
<li>已经访问 已经修改</li>
</ol>
<p>需要替换的时候按照首先替换0的规则进行替换。</p>
<p>这是因为每次访问页面都会引发中断：写R/W位，于是os可以利用这个时间做一些事。定时把R位清零来区别最近没有被访问的和已经访问的。</p>
<h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><p>替换最先被换进来的。</p>
<p>通过维护一个记录所有位于内存的逻辑页面链表，将该链表按驻留时间排序，联手最长，连伟最短。缺页的时候进行置换，新页面加到链尾</p>
<p>实现简单，可以用硬件实现，但是性能很差，基本不会单独使用这个算法。</p>
<p><strong>Belady</strong>现象：</p>
<p>分配的物理也数增加，但是却也次数也会增加的现象。</p>
<p>原因：FIFO的置换特征与进程访问内存的动态特征矛盾<br>被他置换出去的不一定是近期不会访问的。</p>
<h3 id="LRU：最近最少使用页面算法"><a href="#LRU：最近最少使用页面算法" class="headerlink" title="LRU：最近最少使用页面算法"></a>LRU：最近最少使用页面算法</h3><p>最近经常访问的页面可能在以后也会经常访问，最近不经常访问的页面可能以后也不会访问。于是选择最长时间没有被访问过的页面替换出去。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/30845425.jpg" alt=""></p>
<blockquote>
<p>这是最优置换算法的一种近似</p>
</blockquote>
<p>虽然可以实现，但是代价很高<br>——需要一个全面的链表，最少使用的在前，最多使用的在后。<br>——需要一个栈，访问页面的时候将这个页号压入栈，并把栈内相同的页号抽出，缺页时拿栈底</p>
<p>使用一个n*n矩阵表示所有页框的信息，当k被访问的时候，把k行设置为1，k列设置为0，一段时间后，每一行的二进制值最小的就是最近最少使用的。</p>
<p><strong>Simple Implementation</strong>：页表项上的计数器<br><strong>硬件实现</strong>：为n<em>n矩阵，使用了特殊的寄存器<br><em>*软件实现</em></em>：NFU</p>
<h3 id="最不常用算法：LFU-NFU"><a href="#最不常用算法：LFU-NFU" class="headerlink" title="最不常用算法：LFU/NFU"></a>最不常用算法：LFU/NFU</h3><p>是对LRU的软件实现。</p>
<p>将每个页面与一个计数器关联，取计数值最小的页面替换</p>
<p>LFU的缺点是他从来不会忘记。以前频繁使用的页面很大可能不会被调出去。：<strong>通过计数器定时右移来改正</strong>-&gt;老化算法<br>LRU关注的是多久未访问而LFU关注的是访问次数，是不一样的。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/89846367.jpg" alt=""></p>
<h3 id="时钟算法"><a href="#时钟算法" class="headerlink" title="时钟算法"></a>时钟算法</h3><p>环状结构，当一个缺页中断到来的时候，首先检查指针所在位置页面的访问位，如果是0就淘汰这个页面，否则置为0，转圈，转到的，如果是0就淘汰，如果是1就变成0，知道找到第一个0。</p>
<p>是LRU与FIFO的折中。<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/9967853.jpg" alt=""></p>
<h3 id="改进的时钟算法"><a href="#改进的时钟算法" class="headerlink" title="改进的时钟算法"></a>改进的时钟算法</h3><p>在页面添加修改位，并在访问时进行相应修改：<br>新改的：RW。<br>每次扫过都将：如果R是1，把R置为0；如果R是0，如果W是1，写这页，写完之后W=0，接着找，如果R=0W=0，就是这个了。</p>
<p>缺页时修改页面标志位，以跳过有修改的页面。<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/7051850.jpg" alt=""></p>
<hr>
<p>上述的都是<strong>局部页面置换算法</strong>。<br>局部页面置换算法选择范围仅仅限于当前进程占用的空间，不考虑进程访存差异。<br><strong>全局页面置换算法</strong>可以逼出其他进程的物理页面：工作集算法、缺页率算法<br>需要动态确定好给每一个进程的物理页面数。</p>
<hr>
<p>CPU利用率达到极致以后，再增加并发进程数iu会出现内存抖动。<br>进程数少时，提高并发进程数，可提高CPU利用率<br>并发进程导致内存访问增加<br>并发进程的内存访问会降低了访存的局部性特征<br>局部性特征的下降会导致缺页率上升和CPU利用率下降</p>
<h3 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h3><h3 id="缺页率置换算法"><a href="#缺页率置换算法" class="headerlink" title="缺页率置换算法"></a>缺页率置换算法</h3><p>缺页次数 / 内存访问次数 或 缺页平均时间间隔的倒数</p>
<p><strong>影响缺页率</strong>：</p>
<ol>
<li>页面置换算法</li>
<li>分配给进程的物理页数目</li>
<li>页面大小</li>
<li>程序的编写方法</li>
</ol>
<p>可以通过调整常驻集的大小，使每一个进程的缺页率保持在一个合适的值。<br>若进程缺页率过高，则增加常驻集以分配更多的物理页面<br>若进程缺页率过低，则减少常驻集以减少它的物理页面数</p>
<blockquote>
<p>为每一个页面计数，达到-m的时候，回收，你要页面就给页面。</p>
</blockquote>
<p>普通访问不做任何事情，缺页的时候，算一下多久没有缺页了，如果数值比较大，看一看是不是有的页面已经没用了，在这期间没有访问的页面被释放。如果小一些，看看是不是需要补一些页面。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/45924471.jpg" alt=""></p>
<p><strong>页替换过程</strong></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/94487722.jpg" alt=""></p>
<h1 id="段机制"><a href="#段机制" class="headerlink" title="段机制"></a>段机制</h1><p><strong>段</strong>：一个程序的逻辑分区<br><strong>页机制缺点</strong>：复杂，消耗资源</p>
<p>地址映射：段中的addr +段中的偏移<br>内存分配：全局段表+本地段表<br>调度：需要时加载段<br>段+分页：用段技术组织节目内容，用分页技术组织物理内存</p>
<h2 id="段地址空间"><a href="#段地址空间" class="headerlink" title="段地址空间"></a>段地址空间</h2><p>进程的段地址空间由多个段组成 ：<br>主代码段 子模块代码段 公用库代码段 堆栈段 堆数据(heap) 初始化数据段 符号表等</p>
<p>段式存储管理的目的：<strong>更细粒度和灵活的分离与共享</strong>一般用于权限控制</p>
<p>段一般是一种段是连续的。有起始地址以及段内偏移量。</p>
<p><strong>段</strong>：表示访问方式和存储数据等属性相同的一段地址空间</p>
<h2 id="段页结合"><a href="#段页结合" class="headerlink" title="段页结合"></a>段页结合</h2><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/3276497.jpg" alt=""></p>
<p>内存共享：通过指向相同的页表基址，实现进程之间的段共享。</p>
<h2 id="link-of-segments"><a href="#link-of-segments" class="headerlink" title="link of segments"></a>link of segments</h2><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/41368943.jpg" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
<div>
  
</div>

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/06/OS/chap2-进程与线程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YaYi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Be With Me">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/06/OS/chap2-进程与线程/" itemprop="url">chap2-进程与线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-06T14:13:37+08:00">
                2017-11-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/课/" itemprop="url" rel="index">
                    <span itemprop="name">课</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h1 id="导"><a href="#导" class="headerlink" title="导"></a>导</h1><p>进程模型的进化：</p>
<ol>
<li>第一代：relay , vacuum tubes and plugboards。没有程序与进程的概念</li>
<li>第二代：批处理系统：一个程序完成所有工作。</li>
<li>带三代：mutiprogramming and timesharing。CPU可以切换运行。</li>
<li>第四代：现代OS：进程模型更加成熟，进程调度与相互交流更加成熟，内存保护与管理更加成熟。</li>
</ol>
<p><strong>进程</strong>：计算机上所有可以运行的软件，通常也包括操作系统，被组织成若干顺序进程，简称进程。它包括输入输出程序与状态。</p>
<p>需要区分进程与程序。</p>
<p>进程创建：系统初始化、运行进程的创建进程系统调用被执行、用户请求、批处理作业初始化。</p>
<p>进程终止：正常退出、出错退出（自愿）、严重错误、被杀死（非自愿）</p>
<p>在unix中，每个进程有自己的父进程，有着明显的层次结构，但是在Windows中，虽然也有“句柄”来标识父进程，拥有句柄即可控制及对应的子进程，但是这个“句柄”可以被转让，就不存在明显的层次关系了。</p>
<h2 id="为什么要并发（Cocurrency）？"><a href="#为什么要并发（Cocurrency）？" class="headerlink" title="为什么要并发（Cocurrency）？"></a>为什么要并发（Cocurrency）？</h2><p><strong>whats os?</strong><br>    A special kind of system software that can manage computer in  efficient and reasonable way. It is in charge of managing hardware resource, controlling the running of programs and providing useful services. It is a convenient platform for people to use computer</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h2><ol>
<li>使用cpu的基本数据结构<ol>
<li>逻辑程序：被用户设计实现（envs）</li>
<li>cpu指令序列：</li>
<li>进程：程序与指令之间的数据结构</li>
</ol>
</li>
</ol>
<p><strong>进程</strong>：进程是某一个特定程序的运行实例，包括输入输出程序与状态。在分时操作系统（time-sharing os）中，CPU被多个进程分享，复杂的算法将被用于进程之间的调度。</p>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p>基本状态：</p>
<ol>
<li>running：真正占用CPU</li>
<li>ready：可以运行，等待CPU的使用权</li>
<li>blocked：不能继续运行，等待外部事件（输入输出等）</li>
</ol>
<p>其他状态：</p>
<ol>
<li>new：进程的数据结构已经准备好，但是程序镜像尚未完成装载（env_create到icode_load之前，此时还不可以调用env_run）</li>
<li>exit：程序已经完成了所有工作，但是还没有回收进程的数据结构（exit gracefully之后，free之前）</li>
<li>suspend：运行镜像已经被换到硬盘里面了</li>
</ol>
<blockquote>
<p>为什么block不能直接过渡到running：你都阻塞了，想回来啊？等吧。<br>为什么ready不能直接block？你都没有运行，怎么直到自己要等待一个外部事件去block？</p>
</blockquote>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-14/82449429.jpg" alt=""></p>
<p>那么为什么会<strong>挂起</strong>呢？</p>
<p>挂起是由于：1.等待时间过长 2. 物理地址空间不足。导致该进程所需运行资源被切换到外存。</p>
<p>页面置换是一件很麻烦的事情，需要进行一系列的硬盘操作，硬盘是一个极其慢的设备，那么为什么还要有挂起状态？（废话如果内存也能有120G那么多空间谁会给他换到硬盘啊）</p>
<ol>
<li>提高处理机效率：就绪进程表示空的时候，提交新进程，以提高处理机效率（<em>哈？</em>）</li>
<li>为运行进程提供足够多的内存</li>
<li>便于调试：在调试时，挂起被调试进程对其地址空间进行读写。</li>
</ol>
<p>什么时候会挂起呢？在进程等待外部事件（阻塞）的时候，有可能被挂起。</p>
<p>除此之外的双挂起模型：<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-14/87376882.jpg" alt=""></p>
<p><strong>等待-&gt;等待挂起</strong>：没有进程处于就绪状态或者是就绪进程需要更多的内存资源。(???)<br><strong>就绪-&gt;就绪挂起</strong>：有高优先级的等待进程和低优先级的就绪进程（这是就绪进程被换到外存）<br><strong>运行-&gt;就绪挂起</strong>：对于抢先式分时系统，有高优先级的等待挂起进程因事件出现而进入就绪挂起。<br><strong>等待挂起-&gt;就绪挂起</strong>：等待的事件到了<br><strong>就绪挂起-&gt;就绪</strong>：没有就绪进程或者是就绪挂起进程的优先级比所有就绪进程的优先级都高<br><strong>等待挂起-&gt;等待</strong>：有一个进程释放了内存，一个等待挂起进程的优先级很高</p>
<p>值得一提的是，winxp用的就是上面的双挂起模型。</p>
<p><a href="http://blog.csdn.net/freeelinux/article/details/53562592" target="_blank" rel="external">对挂起的详细分析</a></p>
<blockquote>
<p>为什么要双挂起呢，os真的那么缺内存吗？<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-14/11990991.jpg" alt=""><br><a href="https://github.com/GcsSloop/Note/tree/master/OperatingSystem" target="_blank" rel="external">from:gcssloop/note</a></p>
</blockquote>
<p>linux下使用的进程模型是：</p>
<ol>
<li>TASK_RUNNING</li>
<li>TASK_INTERRUPTIBLE：进程被挂起，直到某些条件变成真。（产生一个中断，在中断中释放一些该进程等待的系统资源，传递唤醒该进程的信号）<br>$$\color{red}{shenme玩意}$$</li>
<li>TASK_UNINTERRUPTIBLE：除了信号不能使它的状态发生变化之外与前一个相同</li>
<li>TASK_STOPED</li>
<li>TASK_TRACED：进程运行被debugger打断</li>
<li>EXIT_ZOMBIE：程序运行已经结束了，但是他的父进程还没有调用一个wait4()或是waitpid()系统调用来返回死掉进程的信息。</li>
<li>EXIT_DEAD</li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-14/55177783.jpg" alt=""></p>
<p>$$\color{red}{so why… kill之后为什么不死}$$</p>
<p>不同的os，其状态设置的差异很大。</p>
<h2 id="进程数据结构"><a href="#进程数据结构" class="headerlink" title="进程数据结构"></a>进程数据结构</h2><p><strong>PCB：进程控制块</strong>：<br>这就是在jos里面的envs那个大数组了，它由操作系统内核维护，也叫进程描述符。（经过了jos的洗礼，其实不用说太多）</p>
<p>所有pcb都在一个特定的内存空间之中。pcb表的size决定了os的并发度。不同状态的进程数据被存在不同的pcb表中。</p>
<p>在一个正经系统中的pcb比env中的项更多，列为：<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-14/88783439.jpg" alt=""></p>
<p>为了将不同运行状态的pcb区分开，可以有两种方法，一种是：<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-14/92773297.jpg" alt=""><br>另一种是：<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-14/64758197.jpg" alt=""></p>
<p>其中第一种是在jos中使用的方式。</p>
<h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><p>进程切换就是我们的sched函数了。<br>切换之前，需要保存在cpu运行程序的山下文（tf内容、pgdir等），切换之后，把新上来的进程的上下文恢复。</p>


<iframe height="363" width="565" src="http://oysmkdi7t.bkt.clouddn.com/%E5%AA%92%E4%BD%932.mp4" frameborder="0" allowfullscreen>
</iframe>


<p>比如说sleep的实现：一个进程运行到了sleep，os去处理这个sleep，此时cpu的掌管权在kernel手里，随后设置一个硬件的时钟中断，然后保护现场，最后os就schedule，把运行权交给了另一个进程，另一个进程运行了一段时间之后硬件的时钟中断raise，打断了另一个进程的运行，于是os处理这个时钟中断保护现场，剥夺了另一个进程的运行权，再一次schedule，进程1开始运行。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-14/62249836.jpg" alt=""></p>
<h2 id="运行镜像（process-image）"><a href="#运行镜像（process-image）" class="headerlink" title="运行镜像（process image）"></a>运行镜像（process image）</h2><p>运行镜像就是☞进程的整个生存周期的描述。</p>
<p><strong>process image的内容</strong>：</p>
<ol>
<li>用户层面：该进程的用户地址空间，比如说程序、堆栈、数据段</li>
<li>寄存器层面：pc、pcw、ir，栈指针其他寄存器</li>
<li>系统层面：pcb等、动态内核指针</li>
</ol>
<p>（emm个人觉得，其实就是pcb里面保存的那些东西，以及那些指针指向的那些空间）</p>
<h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><p>p82</p>
<p>简述：</p>
<p><strong>Q</strong>：什么时候调度？<br>    进程被创建、进程退出<br>    进程阻塞<br>    出现io中断</p>
<p><strong>Q</strong>：为什么要调度？<br>    做更好的选择：优先级、运行时长<br>    保证CPU的效率</p>
<p><strong>Q</strong>：怎么做调度？<br>    使用特定的方式选择一个进程占用CPU<br>    在切换的时候切换上下文</p>
<p><strong>A</strong>：注意：</p>
<ol>
<li>调度的频率是非常重要的</li>
<li>有抢占式调度与非抢占式调度</li>
<li>CPU-bound（计算密集型）与i/o-bound（io密集型）进程</li>
</ol>
<p>CPU资源的时分复用 ：</p>
<ol>
<li>进程切换：CPU资源占用者切换</li>
<li>处理机调度：从就绪队列中挑选进程、从CPU中挑选可使用的CPU</li>
<li>调度程序：调度策略、调度时机</li>
</ol>
<h3 id="when-and-why"><a href="#when-and-why" class="headerlink" title="when and why"></a>when and why</h3><p>上述的调度时间是一个笼统的说法：</p>
<ol>
<li>内核运行调度程序的条件<br> 进程退出<br> 进程从运行态切换到等待</li>
<li>非抢占系统中<br> 当前进程主动放弃CPU</li>
<li>可抢占系统<br> 当前进程时间片用完<br> 中断请求被服务例程响应完成时</li>
</ol>
<p>其实在写完jos的sched函数之后，对何时调度应该有一个认识：无论是何时调度，都是os编写人员决定的（或是用户程序主动放弃）。os为了避免用户程序不自觉，提供了时间中断（timer interrupt），在每一个时间终端的处理中指定schedule。<br>再比如上面提到的io中断，这部分也是os决定的sched，因为trap(jos)是属于kernel部分。</p>
<p>调度的目标：不同的系统中目标是不同的</p>
<ol>
<li><p>在所有系统中：</p>
<ol>
<li>公平性：给每一个进程一个公平使用CPU的机会</li>
<li>策略强制执行:seeing thatstated policy is carried out</li>
<li>平衡：保持整个系统都是有事可干</li>
</ol>
</li>
<li><p>批处理系统：</p>
<ol>
<li>吞吐量：使单位时间的工作量达到最大</li>
<li>周转时间（turnaround time）：在任务提交与任务完成之间时间尽可能小</li>
<li>CPU利用率：让CPU一直有事可干</li>
</ol>
</li>
<li><p>交互系统：</p>
<ol>
<li>响应时间</li>
<li>Proportionality：达到用户期望值</li>
</ol>
</li>
<li><p>实时系统：</p>
<ol>
<li>meet deadline：别丢数据</li>
<li>可预测：在多媒体系统中别有质量上的降低</li>
</ol>
</li>
</ol>
<h3 id="goal"><a href="#goal" class="headerlink" title="goal"></a>goal</h3><p>那么给定一个调度算法，怎么比较他们之间的优劣呢？</p>
<ol>
<li>CPU使用率</li>
<li>吞吐量：单位时间内完成进程的数量</li>
<li>周转时间：进程从初始化到结束绝对时间</li>
<li>等待时间：进程在<strong>就绪</strong>中的时间（不算等待状态的时间，因为这个时间其实是必须花费的）</li>
<li>响应时间：从提交请求到请求响应时间</li>
</ol>
<p><strong>吞吐量与响应时间之间的区别</strong></p>
<p>吞吐量是什么呢？其实就是希望通过合理的调度使规定时间内完成更多的进程，比如说文件传输的时候希望<strong>高带宽</strong>（10M/s与10k/s你想要哪个？）。<br>响应时间是什么呢？就是希望进程对某一个动作尽可能快的作出反应，比如点击按钮搜索之后多久才响应。</p>
<p>吞吐量与响应时间其实是很不同的两个概念，两者我认为在某种情况下是此消彼长的。吞吐量描述的是整体，响应时间描述的特定。</p>
<p><strong>响应时间目标</strong>：</p>
<ol>
<li>减少响应时间 </li>
<li>减少平均响应时间的波动<br>在交互是系统中，减少平均响应时间波动其实更加重要。</li>
</ol>
<p>响应时间是os的计算延时。</p>
<p><strong>吞吐量目标</strong>：</p>
<ol>
<li>增加吞吐量：减少os开销（减少上下文切换）、系统资源的高效利用（CPU、io）</li>
<li>减少等待时间：减少每个进程在就绪呆的时间<br>os需要保证吞吐量的提高不会影响交互体验（os必须不时地进行调度，即使存在许多交互式任务）</li>
</ol>
<p>吞吐量是os的计算带宽</p>
<h3 id="批处理系统中的调度算法"><a href="#批处理系统中的调度算法" class="headerlink" title="批处理系统中的调度算法"></a>批处理系统中的调度算法</h3><p>吞吐量、周转时间、CPU利用率</p>
<ol>
<li>先来先服务：非抢占式<br> 笨蛋算法、简单，某些情况下也合理、io密集型系统中对CPU利用率低到令人发指</li>
<li>最短任务优先：非抢占式<br> 周转时间短、在现实的os中并不会是最优的</li>
<li>最短剩余时间优先：抢占式<br> 将新任务的时间与当前任务的剩余运行时间做对比，如果新任务时间短就让新任务占据CPU、不现实啊</li>
<li>三层调度<br> admission scheduler<br> memory scheduler<br> CPU scheduler</li>
</ol>
<h4 id="先来先服务（FCFS）"><a href="#先来先服务（FCFS）" class="headerlink" title="先来先服务（FCFS）"></a>先来先服务（FCFS）</h4><p>就是先来先运行，也没有抢占，运行到结束就行了。</p>
<p>优点是非常简单，但是缺点更加明显。</p>
<ol>
<li>平均等待时间波动很大，短进程可能会在长进程后面</li>
<li>资源利用率低（一直运行一个你说利用率能高吗），CPU密集型导致io闲置，io密集型导致CPU闲置。</li>
</ol>
<blockquote>
<p>说到这里就想起来一个题外话。上编译课的时候编译老师说他上学那会儿用的编译器是非常老的编译器，性能也不好。一般都是晚上离开实验室的时候把写的东西运行上，第二天回来实验室的时候能出结果都已经很不错了。<br>os课的时候老师说，假如你买了一个服务要去运行自己的程序，本来你就是一个hello world，前面那个人的程序可能特别庞大需要一天来运行，你倒霉催的正好排在那人后面，你可能几秒就完事了，但是那个服务器好巧不巧用的FCFS，那你可就等吧。</p>
</blockquote>
<h4 id="最短时间优先算法（SPN）"><a href="#最短时间优先算法（SPN）" class="headerlink" title="最短时间优先算法（SPN）"></a>最短时间优先算法（SPN）</h4><p>每次选择就绪队列中的运行时间最短的进程来执行，就绪队列按照预期的执行时间来排序。</p>
<p>非常容易就可以想到的是，SPN必定具有<strong>最短平均周转时间</strong>。（如果学过贪心算法，应该很清楚这一点）（吞吐量可不会，SPN是非抢占，只能串行运行的）</p>
<p>缺点也非常明显，你一直运行hello world，人家正儿八经的要运行一天的大程序什么时候才能开始运行啊？<br>可能会导致<strong>饥饿</strong>。</p>
<p>还有一个需要解决的问题是<strong>如何预测程序运行</strong>，不太可能准确预测一个程序需要的执行时间，尤其是当ifelse while等语句十分的情况下，这种运行时间一般都需要在运行时才能确定。<br>不能预测这个算法还有什么好实现的？<br>还有一种方法是问用户，你不能保证用户都是诚实的，但是你可以最多分配用户指定的时间，超出时间就杀死。但是这种方法真的太不友好太不专业了，程序运行中的状况很多，用户也不一定知道运行时间。</p>
<p>所以这种方法其实是不太可行的。</p>
<h4 id="最短剩余时间优先算法（SRT）"><a href="#最短剩余时间优先算法（SRT）" class="headerlink" title="最短剩余时间优先算法（SRT）"></a>最短剩余时间优先算法（SRT）</h4><p>是SPN的可抢占改进版，允许当新进程进入时新进程如果运行时间很短可以代替老进程运行。</p>
<p>其实这才改是真正的最短平均周转时间。（即使是可抢占，也与吞吐量高无缘，又不会在等待的时候调度）。</p>
<p>缺点也差不多与SPN差不多。</p>
<h4 id="最高响应比优先算法（HRRN）"><a href="#最高响应比优先算法（HRRN）" class="headerlink" title="最高响应比优先算法（HRRN）"></a>最高响应比优先算法（HRRN）</h4><p>选择就绪队列中响应比R值最高的进程。不支持抢占。</p>
<p><strong>响应比</strong>：R=(等待时间+执行时间)/执行时间</p>
<p>那也就是等待的时间越长越容易被选中。是在短进程优先算法基础之上的改进，防止无止境地等待。</p>
<h4 id="三层调度"><a href="#三层调度" class="headerlink" title="三层调度"></a>三层调度</h4><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-14/65249341.jpg" alt=""></p>
<h3 id="交互式系统中的调度"><a href="#交互式系统中的调度" class="headerlink" title="交互式系统中的调度"></a>交互式系统中的调度</h3><ol>
<li>时间片轮转：抢占式<br> 时间片耗尽时触发调度、进程等待（阻塞）时触发调度</li>
<li>多级队列：<br> 有多种优先级class，美哟中class存在同一个队列、根据优先级选择进程、高优先级低时间片保证公平</li>
<li>优先级调度：抢占式<br> 每个进程有自己的优先级、CPU选择最高优先级、动态优先级来避免饥饿</li>
</ol>
<p><strong>处理机资源的使用模式</strong>：</p>
<p>进程在CPU计算与io之间进行交替：每次调度决定在下一个CPU计算时将那个工作交给CPU，在时间片机制下，进程可能在结束当前CPU计算之前放弃CPU。</p>
<h4 id="时间片轮转-（RR）"><a href="#时间片轮转-（RR）" class="headerlink" title="时间片轮转 （RR）"></a>时间片轮转 （RR）</h4><p>每当时间片结束，就会引发一个调度，每当进程自己要等待，引发一个调度。每当下去，自觉排在队尾。</p>
<p>时间片轮转的问题是：</p>
<ol>
<li>额外的上下文切换开销</li>
<li>时间片选择问题</li>
</ol>
<p>其实归根结底是时间片选择问题，额外的上下文切换是一定必须的。<br>如果时间片选择太大，就失去了调度的灵活性，等待时间变长，这在交互式系统中可能是不可忍受的。甚至在极限情况下，就退化成了上述的FCFS。<br>如果时间片选择太短，将会浪费大量的时间在上下文切换。比如在linux，上下文切换一次可能需要1ms，如果4ms是时间片长度，那么整个系统中有20%的时间都在做上下文切换。这是没有意义的浪费。<br>经验上，一般将浪费控制在1%，实践篇一般设置在20-50ms。<br>当n（就绪队列长度）比较大的时候，可以把某一些就绪状态的进程给传到就绪挂起。</p>
<h4 id="多级队列调度算法（MQ）"><a href="#多级队列调度算法（MQ）" class="headerlink" title="多级队列调度算法（MQ）"></a>多级队列调度算法（MQ）</h4><p>就绪队列被划分为多个独立的子队列（终端、io、前台交互、后台批处理）<br>每个队列可以有自己的调度策略（前台RR，后台FCFS等）<br>队列之间的调度：</p>
<ol>
<li>固定优先级：可能导致饥饿</li>
<li>时间片轮转：每个队列得到一个确定的能偶用于调度其进程的CPU总时间（比如前台80%后台20%）</li>
</ol>
<h4 id="多级反馈队列算法（MLFQ）"><a href="#多级反馈队列算法（MLFQ）" class="headerlink" title="多级反馈队列算法（MLFQ）"></a>多级反馈队列算法（MLFQ）</h4><p>进程可以在不同队列之间移动的多队列算法。时间片大小可以随着优先级级别增加而减小，如果进程在当前的时间片没有完成，降到下一个优先级。</p>
<p>其特点是：CPU密集型的进程优先级下降很快，而io密集型进程停留在高优先级。</p>
<h4 id="优先级算法（PS）"><a href="#优先级算法（PS）" class="headerlink" title="优先级算法（PS）"></a>优先级算法（PS）</h4><p>是多级队列算法的改进，平衡各进程对响应时间的要求。<br>分为抢占式与非抢占式。<br>通常可以控制其时间片长度。<br>如果io完成，提高优先级，如果时间片用完，将低优先级。</p>
<p><strong>静态优先级</strong>：<br>在创建进程的时候，他的优先级就被确定，直到进程终止之前都不会改变。<br>（系统进程优先级高、io密集型优先级高）</p>
<p><strong>动态优先级</strong>：<br>优先级在创建的时候被赋予，但是在进程运行的过程中可以被改变：</p>
<ol>
<li>在就绪队列中，等待时间延长优先级高。</li>
<li>进程每执行一个时间片就降低这个进程的优先级。</li>
</ol>
<p>对于不同类型的进程：<br><strong>io密集型进程</strong>：他是最高级优先。<br>为什么io密集的优先级比较高呢？这是因为io密集型一般只会占用一小会儿CPU，随后就会等待io外部操作去了。最好的做法是，io一旦就绪就赶紧用一下CPU，然后就可以去等io事件了。如果io密集型进程的优先级比较低，将会浪费很多时间在就绪的等待上。<br>CPU密集型时常需要CPU资源，由于优先级低，可以使用更大的时间片，减少上下文切换的浪费。</p>
<p>动态处理：<br>对于io密集型，尽量别减小优先级。（如果是MLFQ，这是几乎可以保证的，因为io密集，可能在给定的时间片中没有用完时间片就自己进入阻塞状态了）（me）<br>对于cpu密集型，在它的io完成之后，放回io请求时离开的队列，以免每次都回到最高优先级再逐次下降。</p>
<h4 id="最短进程优先"><a href="#最短进程优先" class="headerlink" title="最短进程优先"></a>最短进程优先</h4><h4 id="保证调度"><a href="#保证调度" class="headerlink" title="保证调度"></a>保证调度</h4><p>向用户做出明确的性能保证，然后去实现它。</p>
<p>初始：每个进程同等的share CPU。<br>随后：计算每个进程理应获得的时间与实际获得的时间之比。<br>结果：倾向于运行比率更低的进程，直到它的radio超过他的接近竞争者。</p>
<h4 id="彩票调度"><a href="#彩票调度" class="headerlink" title="彩票调度"></a>彩票调度</h4><p>就是os卖彩票，给每个进程一个彼此不同的彩票，一旦需要调度，就抽彩票，看看谁中奖，中奖的哪个进程获得资源。<br>”所有进程是平等的，但是有一些进程更平等一些“<br>给某些重要的进程额外的彩票，增加他们中奖的几率。</p>
<p>允许进程之间交换彩票，比如客户机进程获得了运行权，然后阻塞等待服务器的响应，这时客户机可以把自己的彩票给服务器机进程，以增加服务器及进程被选中的机会。（实际上，如果没有客户机进程，服务器及进程的存在就是一个错误）</p>
<h3 id="调度实现"><a href="#调度实现" class="headerlink" title="调度实现"></a>调度实现</h3><p>unix：动态优先级算法<br>5.3BSD：MQ<br>Windows：优先级算法<br>Linux：抢占式调度（preemptive scheduling）</p>
<h3 id="调度机制设定"><a href="#调度机制设定" class="headerlink" title="调度机制设定"></a>调度机制设定</h3><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/81651596.jpg" alt=""><br>$$\color{red}{什么鬼这是}$$</p>
<p>在oskernel设计调度算法，就像我们的schedule函数在kernel中完成，并封装用户接口供用户调用。</p>
<p>除了时间片，允许用户也做出调度的决定，完成调度策略设置。</p>
<p><strong>可以参考lab4的文档</strong></p>
<h2 id="进程之间的通信"><a href="#进程之间的通信" class="headerlink" title="进程之间的通信"></a>进程之间的通信</h2><p>消息、管道、消息队列、共享内存</p>
<p>可以参考lab4文档，里面有ipc以及lab5中有共享内存。</p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p><strong>线程</strong>是进程中一个相对独立的、具有可调度特性的<strong>执行单元</strong>。</p>
<p>线程一定不是陌生的，早在大二上学期，就在Java中接触了线程。线程作为实现进程中的并发而存在。</p>
<p>系统提供了线程库Pthread：<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/74457502.jpg" alt=""></p>
<h2 id="线程库"><a href="#线程库" class="headerlink" title="线程库"></a>线程库</h2><p>线程库是针对那些不提供多线程支持的os而设计的在用户态下的库，线程库的处理对这些os是透明的。</p>
<p>即使提供了核心线程支持的os，也有必要提供线程库，可以简化或有利于线程机制的使用。</p>
<p>线程库提供：</p>
<ol>
<li>合适的多线程编程的接口</li>
<li>记录线程状态和调度各个线程的运行机制</li>
</ol>
<p>在系统内部可以使用多种方式实现线程机制：</p>
<ol>
<li>ULT纯用户级线程：线程管理全部由用户程序完成，kernel只管理进程，增加”线程库“概念。</li>
<li>KLT核心级线程：线程有kernel管理，kernel为用户提供系统调用。</li>
</ol>
<p><strong>ULT</strong>：<br>进程表在kernel，线程表在用户空间，使用线程库。线程表由运行时系统管理。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/40601574.jpg" alt=""></p>
<p>ult的优点是：</p>
<ol>
<li>线程切换不需要陷入内核：比陷入内核快一个数量级</li>
<li>允许进程制定自己的调度算法而不会影响os的调度算法程序</li>
<li>ult管理模式可以在任何os下运行，不需要修改内核，只需要线程库。</li>
</ol>
<p>ult的不足是：</p>
<ol>
<li>系统调用会引起进程阻塞</li>
<li>不利于多处理器并行（<strong>why？？？</strong>）</li>
</ol>
<blockquote>
<p>关于系统阻塞的问题：<br>os并不知道进程里还有线程，当一个线程在尚未发生键盘操作的时候读键盘，将会引发阻塞。这时可能整个进程都会被os的调度算法调度下来，整个进程都会阻塞。而要使用线程，应该允许每个线程都能够阻塞调用，而不影响其他线程的运行。现在显然是不行。<br>有两种解决方法，一是修改read在没有外部事件时返回0，但是对read语义的改变休要大量代码的修改。<br>另一种是允许进行阻塞检查，仅在外部事件发生时才进行系统调用，否则先让出使用权给其他线程运行。这种方式一点都不好看，但是也没有其他的方法了。</p>
<p>还有一个问题是进程的无休止运行。没有时间片操作。<br>对ult最大的争论是程序员一般只会在经常发生线程阻塞的程序中才会大量使用线程。</p>
</blockquote>
<p><strong>klt</strong>：<br>线程与进程都在用户空间完成（what？）<br>进程表与线程表都在kernel</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/46110689.jpg" alt=""></p>
<p>优点：<br>线程在kernel中有信息，系统调用基于线程（不存在上述的阻塞）<br>可以克服ult的阻塞与并行度差的缺点，并且kernel也可以使用多线程。</p>
<p>缺点：<br>每次进行线程调度都需要陷入内核</p>
<h2 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h2><p><strong>线程</strong>使劲蹭的一部分，描述指令流执行状态，是进程中的指令执行最小单元，是CPU调度的基本单位。</p>
<p>在进程与线程机制中，进程作为<strong>资源分配</strong>角色，包括地址空间、打开文件等；线程作为<strong>处理机调度</strong>角色，描述进程资源环境中的指令执行序列状态。</p>
<p>进程的表叫做<strong>TCB</strong>。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/26479287.jpg" alt=""></p>
<p>为什么进程有自己独立的栈？<br>进程描述了指令执行状态，而栈中数据与之前执行的指令有关，因此每一个线程都应该有自己的栈。保证执行指令的独立性。</p>
<ol>
<li>调用函数返回</li>
<li>errorno</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">进程中内容</th>
<th style="text-align:center">线程中内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">地址空间</td>
<td style="text-align:center">程序计数器</td>
</tr>
<tr>
<td style="text-align:center">全局变量</td>
<td style="text-align:center">寄存器</td>
</tr>
<tr>
<td style="text-align:center">打开文件</td>
<td style="text-align:center">堆栈</td>
</tr>
<tr>
<td style="text-align:center">子进程</td>
<td style="text-align:center">状态</td>
</tr>
<tr>
<td style="text-align:center">即将发生的报警</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">信号与信号处理程序</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">账户信息</td>
</tr>
</tbody>
</table>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/51773333.jpg" alt=""></p>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>|进程|线程|<br>|资源分配单位|CPU调度单位|<br>|有完整的资源平台|只独享指令执行的必要资源|<br>|基本状态与其他状态与转换|就绪等待运行状态与转换|</p>
<p>线程：减少并发执行的时间与空间开销</p>
<ol>
<li>创建时间比进程短（why）</li>
<li>终止时间比进程短</li>
<li>同一进层内的线程切换时间更短</li>
<li>同一进程之间的线程共享内存与文件，不需要通过内核进行通信。</li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/87331439.jpg" alt=""></p>
<p><strong>what is 多对多</strong></p>
<h2 id="轻权进程"><a href="#轻权进程" class="headerlink" title="轻权进程"></a>轻权进程</h2><p>内核支持的用户线程。</p>
<p>一个进程可以有一个或者多个轻量级进程，每个轻权进程由一个单独的内核线程支持。<br>太过复杂，最后被抛弃。<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/47608393.jpg" alt=""></p>
<h1 id="经典IPC问题"><a href="#经典IPC问题" class="headerlink" title="经典IPC问题"></a>经典IPC问题</h1><p>进程之间的通信，可以参见lab4ipc。</p>
<h2 id="进程之间通信"><a href="#进程之间通信" class="headerlink" title="进程之间通信"></a>进程之间通信</h2><ol>
<li><p>进程之间通信将产生什么问题？</p>
<ol>
<li>异步：从一个进程传递信息到另一个</li>
<li>排外：与其他进程争夺资源</li>
<li>同步：维护适当的运行序列</li>
</ol>
</li>
<li><p>进程之间通信的难处：</p>
<ol>
<li>信息的格式：signal、switch、message</li>
<li>排外与同步：合作问题</li>
</ol>
</li>
<li><p>金字塔规则</p>
</li>
</ol>
<p><strong>竞争条件</strong>：两个或多个进程读写某些共享数据，而最后的果取决于进程运行的精确时序。</p>
<p>书上有一个打印机的例子， 就是说A与B都需要使用打印机，打印机维护in与out指针，供所有进程去访问。假设某一时刻A想打印东西，于是去查找out指针的值，存在临时变量next_free里面，这时时间片来了B上来了，B也要打印东西，于是正常的完成了将东西放在out的位置，out++。这时A回来了，他发现自己next_free是原out值，于是覆盖了B的文件数据，然后把next_free加一，存到out里面。</p>
<h2 id="生产者与消费者问题"><a href="#生产者与消费者问题" class="headerlink" title="生产者与消费者问题"></a>生产者与消费者问题</h2><p>固定大小buffer，生产者加数据，消费者拿数据，更新count，当count是0的时候，消费者休眠，是N的时候生产者休眠。每个进程检查唤醒。</p>
<p>——在数据更新的过程中访问了数据！</p>
<p>概念：<br><strong>race condition</strong>：两个或更多进程竞争同一项资源，在一个进程占用资源的时候其他进程不应该访问。<br><strong>critical region</strong>：对共享内存进行访问的程序片段<br><strong>优秀结果标准</strong>：</p>
<ol>
<li>不可以有两个进程同时处于临界区</li>
<li>不应对CPU的数量与速度有要求</li>
<li>临界区外运行的进程不能阻塞其他进程</li>
<li>进入临界区时不能无限等待</li>
</ol>
<p>《甘特图：临界区》</p>
<p>实际程序中，可以将所有代码根据是否访问共享区域分为四个部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">entry section</div><div class="line">    critical section</div><div class="line">exit section</div><div class="line">    remainder section</div></pre></td></tr></table></figure>
<h3 id="家庭采购协调问题"><a href="#家庭采购协调问题" class="headerlink" title="家庭采购协调问题"></a>家庭采购协调问题</h3><table>
<thead>
<tr>
<th style="text-align:center">时间</th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">3:00</td>
<td style="text-align:center">看冰箱 没面包</td>
<td style="text-align:center">–</td>
</tr>
<tr>
<td style="text-align:center">3:05</td>
<td style="text-align:center">离开家去商店</td>
<td style="text-align:center">–</td>
</tr>
<tr>
<td style="text-align:center">3:10</td>
<td style="text-align:center">到达商店买面包</td>
<td style="text-align:center">看冰箱 没面包</td>
</tr>
<tr>
<td style="text-align:center">3:20</td>
<td style="text-align:center">到家，放面包</td>
<td style="text-align:center">去商店</td>
</tr>
<tr>
<td style="text-align:center">3:25</td>
<td style="text-align:center">–</td>
<td style="text-align:center">到商店买面包</td>
</tr>
<tr>
<td style="text-align:center">3:30</td>
<td style="text-align:center">–</td>
<td style="text-align:center">到家，放面包</td>
</tr>
</tbody>
</table>
<p>我们分析这个问题：</p>
<ol>
<li>如何保证买面包动作的成功与高效：有且仅有一个人去买</li>
<li>可能的解决：加锁 导致的问题：无法取到冰箱中其他东西<br>（具体查看PPT，时间有限）</li>
</ol>
<p>关于临界与外部事件发生：可以将等待临界空闲的进程转到阻塞态。</p>
<h3 id="忙等待"><a href="#忙等待" class="headerlink" title="忙等待"></a>忙等待</h3><p>设计思路：通过全局变量保存临界区状态供进程参考</p>
<h4 id="屏蔽中断（disabling-interrupts）"><a href="#屏蔽中断（disabling-interrupts）" class="headerlink" title="屏蔽中断（disabling interrupts）"></a>屏蔽中断（disabling interrupts）</h4><p>基本思想是在进入临界区之前关中断，这就导致时钟中断也会被关闭，从而没有进程可以打断它。</p>
<p>问题：</p>
<ol>
<li>不支持多CPU</li>
<li>把关中断权限交给用户是不明智的选择</li>
</ol>
<p>但是对于内核来说，关中断是一种很好的方法，可以用来维护多线程（如果支持）或者多CPU之间对就绪队列等的访问<br>（别都选到一个进程就尴尬了，在jos里这会发生错误）（话说，在jos里面实现多CPU的时候可有内核锁机制，下面来看一看锁都加在了哪里）</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/64321100.jpg" alt=""></p>
<h4 id="锁变量（Lock-variable）"><a href="#锁变量（Lock-variable）" class="headerlink" title="锁变量（Lock variable）"></a>锁变量（Lock variable）</h4><p>保存一个名为lock之类的全局变量供各个进程进行检查，实际上无济于事——这不也是临界区吗</p>
<h4 id="严格轮换法（Strict-alertnation）"><a href="#严格轮换法（Strict-alertnation）" class="headerlink" title="严格轮换法（Strict alertnation）"></a>严格轮换法（Strict alertnation）</h4><p>要求进程轮流进入临界区。看了代码就会明白：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">    <span class="keyword">while</span>(trun!=<span class="number">0</span>);<span class="comment">//A进程必须等待turn是0的时候才能进去</span></div><div class="line">    critical_region();</div><div class="line">    turn=<span class="number">1</span>;</div><div class="line">    noncritical_region();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">    <span class="keyword">while</span>(turn!=<span class="number">1</span>);<span class="comment">//B进程必须等到turn是1</span></div><div class="line">    critical_region();</div><div class="line">    turn=<span class="number">0</span>;</div><div class="line">    nocritcal_region();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不是一个很好的方案。</p>
<p>缺点：</p>
<ol>
<li>违反了“进程不应该被处于非临界区的进程阻塞”</li>
<li>浪费CPU时间：忙等待时间</li>
</ol>
<p>很明显啊，他们在轮转的时候，如果A这时需要进入临界区但是B在运行非临界区的程序，A可以被放到阻塞态，这时违反了规则3<br>A可以继续循环，这时每次A上去CPU都会浪费时间空循环，还不如去阻塞态。</p>
<p>还有，如果A需要多次进入临界区，而B主要时间在非临界区，A的效率就变得非常低，绝大多数时间都是在空转。</p>
<p><strong>自旋锁</strong>：用于忙等待的锁。</p>
<p>PPT另有两种，都是失败的方法。暂且不提。</p>
<h4 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h4><p>1981-满足线程之间互斥的经典基于软件的解法</p>
<p>似乎仅用于两个进程：<br><a href="https://zh.wikipedia.org/wiki/Peterson%E7%AE%97%E6%B3%95" target="_blank" rel="external">wiki</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></div><div class="line"><span class="meta">#deine N 2 <span class="comment">//进程数量</span></span></div><div class="line"></div><div class="line"><span class="keyword">int</span> turn;<span class="comment">//轮到进程编号</span></div><div class="line"><span class="keyword">int</span> interested[N];个各进程是不是想去临界区，是不是已经在临界区</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">enter_region</span><span class="params">(<span class="keyword">int</span> process)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> other;<span class="comment">//在临界区的</span></div><div class="line">    other=<span class="number">1</span>-process;</div><div class="line">    interested[process]=TRUE;<span class="comment">//我想进去l临界区</span></div><div class="line">    turn=other;<span class="comment">//</span></div><div class="line">    <span class="keyword">while</span>(turn==other &amp;&amp; interested[other]==TRUE);<span class="comment">//</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">leave_region</span><span class="params">(<span class="keyword">int</span> process)</span></span>&#123;</div><div class="line">    interested[process]=FALSE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行到while处可能会挂起。</p>
<p>怎么使用呢？在每个进程进入临界区之前调用critical_region，退出之后调用leave_region。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/88550095.jpg" alt=""></p>
<p><strong>扩展到N个线程的互斥filter算法</strong>：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/67570267.jpg" alt=""></p>
<h4 id="TSL"><a href="#TSL" class="headerlink" title="TSL"></a>TSL</h4><p>指令：TSL RX LOCK</p>
<p>将lock给rx然后往lock中存一个非0值：保证原子操作，锁内存总线。</p>
<p>代码：<br>    enter_region:<br>        TSL REGISTER , LOCK//原值在寄存器，新值在内存<br>        CMP REGISTER,#0<br>        JNE enter_region<br>        RET//原来是0，可以进去了<br>    leave_region:<br>        MOVE LOCK , #0<br>        RET</p>
<p>一个可以代替tsl的是xchg（是不是很眼熟！）<br>xchg完成的操作是交换两个位置的内容。</p>
<pre><code>enter_region:
    MOVE REGISTER,#1
    XCHG REGISTER,LOCK
    CMP REGISTER,#0
    JNE enter_region
    RET
leave_region:
    MOVE LOCK, #0
    RET
</code></pre><p>锁是一个抽象的数据结构，有方法Acquire与Release。</p>
<p>在获取所的时候，如果锁目前被别人拥有，就等待。<br>释放锁的时候，通知那些等待的进程你们等的锁到了。</p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>使用TSL实现自旋锁：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Lock::Acquire()&#123;</div><div class="line">    <span class="keyword">while</span>(test-<span class="keyword">and</span>-<span class="built_in">set</span>(value));</div><div class="line">&#125;</div><div class="line">Lock::Release()&#123;</div><div class="line">    value=<span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Acquire:不停地区获取锁的值并将锁的值赋为1，直到锁的值变为0。（说明有进程从临界区出来了）</p>
<p>忙等待确实可以解决2个进程之间互斥运行的问题，但是缺点也很多，浪费CPU时间，编程困难，可能会造成优先级错乱。</p>
<h4 id="无忙等待锁"><a href="#无忙等待锁" class="headerlink" title="无忙等待锁"></a>无忙等待锁</h4><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/30861938.jpg" alt=""></p>
<h3 id="睡眠与唤醒"><a href="#睡眠与唤醒" class="headerlink" title="睡眠与唤醒"></a>睡眠与唤醒</h3><p>进程间通信<strong>原语</strong>，在无法进入临界区的时候进入阻塞状态而不是忙等待。</p>
<p>当一个进程发现自己不能进入临界区的时候，就系统调用sleep，阻塞去。另一个进程要离开临界区，就调用wakeup将她唤醒。<br>sleep\wakeup(pid);</p>
<h4 id="简单睡眠唤醒机制"><a href="#简单睡眠唤醒机制" class="headerlink" title="简单睡眠唤醒机制"></a>简单睡眠唤醒机制</h4><p>正如上述。</p>
<p>悲惨的是，假如wakeup信号丢失了，没有被唤醒的进程还在阻塞，假如剩余一个进程进入临界区需要该进程的作用，就都阻塞。</p>
<p>对MCPU不支持：使用进程号。</p>
<p>终于，现在可以考虑一下生产者消费者的解决了：</p>
<p>略。可见书或PPT</p>
<p>这是失败的解决，可能会导致wakeup信号丢失结果二人都去阻塞。</p>
<h3 id="信号量解决"><a href="#信号量解决" class="headerlink" title="信号量解决"></a>信号量解决</h3><p>P-&gt;down V-&gt;up</p>
<p><strong>信号量</strong>：一种新的变量类型，表示唤醒操作剩余次数。（所有相关线程引起的总竞争条件检查次数）<br><strong>信号</strong>是一个抽象数据类型，由一个整形变量与两个原子操作组成。</p>
<p>down：对某个信号量down是检查他的value，如果不是0，就减一，如果是0就去sleep。<br>up：对某个信号量的值加1。如果睡眠，就唤醒。</p>
<p>信号量是被保护的，在初始化完成之后，只能通过pv修改，而pv操作是被保证的原子操作。</p>
<p>通常嘉定信号量是公平的，也就是说不会一直被阻塞在p操作。（假设先进先出）</p>
<p>信号量的实现与前面说到的无忙等待锁很像：<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/30861938.jpg" alt=""><br>其实block也相当于被调度了。<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/8720151.jpg" alt=""></p>
<p>区别在于前面说的无忙等待锁并不是原子性的。</p>
<p><strong>解决方案</strong>：<br>每一个临界区设置一个信号量对象，初值是1代表初始时可以进入一个到临界区去。<br>p在进入之前，v在进入之后。必须成对出现。</p>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>同步可能会被调度序列打乱。（？）</p>
<p>同步与互斥的区别：</p>
<ol>
<li>互斥值放值其他进程进入cr</li>
<li>同步是指实现一个合理的逻辑序列</li>
</ol>
<p>whats this<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/11688740.jpg" alt=""></p>
<h4 id="ipc问题分析——使用信号量解决生产者消费者问题"><a href="#ipc问题分析——使用信号量解决生产者消费者问题" class="headerlink" title="ipc问题分析——使用信号量解决生产者消费者问题"></a>ipc问题分析——使用信号量解决生产者消费者问题</h4><p>1.ipc问题产生 原因：</p>
<ol>
<li>物理序列依赖于调度</li>
<li>逻辑序列依赖应用层需的意愿</li>
<li>竞争条件排斥资源获取</li>
</ol>
<p>在内核态以及用户态都有ipc问题，在内核态是io设备的管理，在用户态是网络应用、数据库等的管理。</p>
<p>ipc问题的关键在于：</p>
<ol>
<li>理解逻辑与物理序列  </li>
<li>逻辑序列依赖于调度</li>
<li>逻辑序列可以被用户控制</li>
</ol>
<p>whats that…..</p>
<p>使用信号量可以实现条件同步。</p>
<p><strong>生产者消费者问题</strong>：<br>一共需要三个信号量：mutex\full\empty。<br>首先，buffer是一个临界区，无论核心进入临界区出来临界区都需要一个信号量，其次，当buffer满的时候（N），生产者不可以进去buffer，需要消费者消费之后up才能进，消费者同理。<br>我认为，后两者实际上是在利用信号量的特点完成程序的逻辑部分，而不仅仅是对临界区的进入控制。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/97276693.jpg" alt=""></p>
<h4 id="monitor-solution"><a href="#monitor-solution" class="headerlink" title="monitor solution"></a>monitor solution</h4><p>信号量的一个缺点是对编程者来说不好写出代码。</p>
<p>monitor（管程）是一对过程、变量、数据结构的集合，（可以被看作是编译器），他们组成一个特殊的模块或软件包</p>
<p>应用：任意时刻管程中只能有一个活跃进程（有效完成互斥）<br>wait and signal：就像pv、du一样<br>不足：只有很少的语言支持。</p>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>组成：一个锁（管程代码互斥）、0或多个条件变量（管理共享数据的并发访问）</p>
<p>进入管程时的互斥由编译器完成</p>
<p><strong>条件变量</strong>：（像是信号量一样的东西）是管程内的的等待机制，允许在进程无法继续运行的时候被阻塞。<br><strong>wait</strong>：无法继续运行时调用，将自己阻塞并掉一个互斥访问进管程<br><strong>signal</strong>：指示一个呼哧进程开始运行，自己退出管程。</p>
<p>wait与signal很像是在之前的sleep与wakeup。但是关键的区别是，这里管程保证了互斥，不允许在wait之前切换进程进入管程。（其实存疑）</p>
<h4 id="条件变量实现"><a href="#条件变量实现" class="headerlink" title="条件变量实现"></a>条件变量实现</h4><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/49329583.jpg" alt=""></p>
<h4 id="管程解决生产者-消费者问题"><a href="#管程解决生产者-消费者问题" class="headerlink" title="管程解决生产者-消费者问题"></a>管程解决生产者-消费者问题</h4><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/21915703.jpg" alt=""></p>
<h4 id="hansen与hoare"><a href="#hansen与hoare" class="headerlink" title="hansen与hoare"></a>hansen与hoare</h4><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/51508560.jpg" alt=""></p>
<p>hansen主张signal只能是管程过程最后一个语句，二hoare则认为不一定，主张signal之后就应该自己阻塞让新的进程进入管程运行。</p>
<p>也是因为这样，，hansen的判断方式使用while而hoare判断使用if。</p>
<p><a href="http://www.cnblogs.com/xybaby/p/6516387.html" target="_blank" rel="external">并发与同步-xybaby</a></p>
<blockquote>
<p>同步互斥，就是在并发的前提下保证一些操作的原子性。</p>
</blockquote>
<h2 id="IPC问题：哲学家就餐"><a href="#IPC问题：哲学家就餐" class="headerlink" title="IPC问题：哲学家就餐"></a>IPC问题：哲学家就餐</h2><p><strong>对互斥访问有限资源的竞争建模</strong></p>
<blockquote>
<p>进程同步也是进程之间直接的制约关系，是为完成某种任务而建立的两个或多个线程，这个线程需要在某些位置上协调他们的工作次序而等待、传递信息所产生的制约关系。进程间的直接制约关系来源于他们之间的合作。</p>
<p>from：<a href="http://www.cnblogs.com/CareySon/archive/2012/04/14/Process-SynAndmutex.html" target="_blank" rel="external">浅谈进程同步与互斥的概念-宋沄剑</a></p>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>互斥：相邻哲学家只有一个人可以使用筷子</p>
<p>同步：</p>
<ol>
<li>想要进餐的哲学家应该拿到两个筷子</li>
<li>同一时刻至多有两个哲学家一同进餐</li>
<li>死锁与饥饿避免</li>
</ol>
<p>ppt</p>
<h2 id="IPC问题：读者与写者"><a href="#IPC问题：读者与写者" class="headerlink" title="IPC问题：读者与写者"></a>IPC问题：读者与写者</h2><p><strong>为数据库访问建模</strong></p>
<p>（会不会产生问题：在不是writer想要放弃的时候强迫writer放弃）——理解错误，<br>P：可不可以得到资源？可以，OK继续执行：不可以OK我去阻塞<br>这个“我”指的是“调用P的那个过程。</p>
<p>保证公平这个，concur是什么？是</p>
<p>##IPC问题：睡觉的理发师</p>
<h2 id="猴子过索桥"><a href="#猴子过索桥" class="headerlink" title="猴子过索桥"></a>猴子过索桥</h2><h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
<div>
  
</div>

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/05/JUnit之一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YaYi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Be With Me">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/05/JUnit之一/" itemprop="url">JUnit之一</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-05T15:27:08+08:00">
                2017-11-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/实验室/" itemprop="url" rel="index">
                    <span itemprop="name">实验室</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://blog.csdn.net/ai92/article/details/302844" target="_blank" rel="external">这是一个简单的JUnit入门介绍</a>。</p>
<p>junit是一个测试框架，把一个java工程按照JUnit运行的时候会启动这些检测，但是这并不影响这个项目作为一个JAVA程序的本质。这个程序仍然可以以Java Application来运行。</p>
<h2 id="在eclipse中使用Junit4进行单元测试"><a href="#在eclipse中使用Junit4进行单元测试" class="headerlink" title="在eclipse中使用Junit4进行单元测试"></a>在eclipse中使用Junit4进行单元测试</h2><p>安装eclipse的时候，应该已经有了junit的jar包，如果没有，可以自己去<strong>maven仓库</strong>搜索下载。</p>
<p><a href="http://tech.sina.com.cn/s/2010-01-18/14081218926.shtml" target="_blank" rel="external">在eclipse中使用Junit4进行单元测试</a></p>
<p>为了方便，我会把上述的方法自己实践并写在下面：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/17569873.jpg" alt=""></p>
<p>不要直接finish。点击next，你将可以选择对哪些方法进行测试，eclipse就会自动帮你命名（which is very essential）</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/14409795.jpg" alt=""><br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/45619270.jpg" alt=""></p>
<p>看！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
<div>
  
</div>

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.gif"
                alt="YaYi" />
            
              <p class="site-author-name" itemprop="name">YaYi</p>
              <p class="site-description motion-element" itemprop="description">来如春梦不多时 去似朝云无觅处</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">38</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/yayi2456" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:yourname@gmail.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://stackoverflow.com/yourname" target="_blank" title="StackOverflow">
                    
                      <i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://weibo.com/2723381840/" target="_blank" title="Weibo">
                    
                      <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YaYi</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>





  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>


	<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
本站总访问量 <span id="busuanzi_value_site_pv"></span> &nbsp&nbsp&nbsp
您是第<span id="busuanzi_value_site_uv"></span>个来到的小伙伴



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共80.1k字</span>
</div>



        




  <script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=64002140";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

  
  
<div id="hexo-helper-live2d">
  <canvas id="live2dcanvas" width="150" height="300"></canvas>
</div>
<style>
  #live2dcanvas{
    position: fixed;
    width: 150px;
    height: 300px;
    opacity:0.7;
    right: 0px;
    z-index: 999;
    pointer-events: none;
    bottom: -20px;
  }
</style>
<script type="text/javascript" src="/live2d/device.min.js"></script>
<script type="text/javascript">
const loadScript = function loadScript(c,b){var a=document.createElement("script");a.type="text/javascript";"undefined"!=typeof b&&(a.readyState?a.onreadystatechange=function(){if("loaded"==a.readyState||"complete"==a.readyState)a.onreadystatechange=null,b()}:a.onload=function(){b()});a.src=c;document.body.appendChild(a)};
(function(){
  if((typeof(device) != 'undefined') && (device.mobile())){
    document.getElementById("live2dcanvas").style.width = '75px';
    document.getElementById("live2dcanvas").style.height = '150px';
  }else
    if (typeof(device) === 'undefined') console.error('Cannot find current-device script.');
  loadScript("/live2d/script.js", function(){loadlive2d("live2dcanvas", "/live2d/assets/hijiki.model.json", 0.5);});
})();
</script>

</body>
</html>
