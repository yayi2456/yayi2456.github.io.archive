<!DOCTYPE html>





<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.2">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=7.4.2">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=7.4.2">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.2" color="#222">
  <link rel="alternate" href="/atom.xml" title="日和" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css?v=7.4.2">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '61a4cd7c1bed364065c7fe56474ba5df',
      indexName: 'yayiblogsearch',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Lab4-Document">
<meta name="keywords" content="OS">
<meta property="og:type" content="article">
<meta property="og:title" content="Lab4_Document">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2017&#x2F;12&#x2F;12&#x2F;OS&#x2F;Lab4_Document&#x2F;index.html">
<meta property="og:site_name" content="日和">
<meta property="og:description" content="Lab4-Document">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-25&#x2F;87627035.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-25&#x2F;96651596.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-25&#x2F;96728212.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-25&#x2F;39840649.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-25&#x2F;29015296.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-26&#x2F;70313494.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-25&#x2F;29300920.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-25&#x2F;92996124.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-25&#x2F;58108225.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-25&#x2F;75077349.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-25&#x2F;63950397.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-25&#x2F;24870973.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-25&#x2F;38167577.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-25&#x2F;44217150.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-25&#x2F;35810116.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-25&#x2F;8461936.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-25&#x2F;59214383.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-25&#x2F;79530109.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-25&#x2F;86607615.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-25&#x2F;74947768.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-25&#x2F;70937828.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-25&#x2F;20728662.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-25&#x2F;47728587.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-25&#x2F;41333018.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-25&#x2F;27465683.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-26&#x2F;2663658.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-26&#x2F;95241296.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-26&#x2F;77522130.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-26&#x2F;27738708.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-26&#x2F;86236764.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-26&#x2F;14374721.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-26&#x2F;57100150.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-26&#x2F;99153651.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-26&#x2F;36579327.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-26&#x2F;42000412.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-26&#x2F;19942562.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-26&#x2F;85310004.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-26&#x2F;89863916.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-26&#x2F;87756184.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-26&#x2F;20379443.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-26&#x2F;74580574.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-26&#x2F;80248583.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-26&#x2F;16842939.jpg">
<meta property="og:updated_time" content="2018-07-20T18:07:05.906Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-12-25&#x2F;87627035.jpg">
  <link rel="canonical" href="http://yoursite.com/2017/12/12/OS/Lab4_Document/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Lab4_Document | 日和</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">日和</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">BE WITH ME</p>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
        
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      
    
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger">
          <i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/12/OS/Lab4_Document/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="傻瓜日和">
      <meta itemprop="description" content="来如春梦不多时 去似朝云无觅处">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日和">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            Lab4_Document
            

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2017-12-12 21:08:40" itemprop="dateCreated datePublished" datetime="2017-12-12T21:08:40+08:00">2017-12-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-07-21 02:07:05" itemprop="dateModified" datetime="2018-07-21T02:07:05+08:00">2018-07-21</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/MIT-Lab/" itemprop="url" rel="index">
                    <span itemprop="name">MIT Lab</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Lab4-Document"><a href="#Lab4-Document" class="headerlink" title="Lab4-Document"></a>Lab4-Document</h1><a id="more"></a>

<h2 id="Part-A-Multiprocessor-Support-and-Cooperative-Multitasking"><a href="#Part-A-Multiprocessor-Support-and-Cooperative-Multitasking" class="headerlink" title="Part A: Multiprocessor Support and Cooperative Multitasking"></a>Part A: Multiprocessor Support and Cooperative Multitasking</h2><h3 id="Multiprocessor-Support"><a href="#Multiprocessor-Support" class="headerlink" title="Multiprocessor Support"></a>Multiprocessor Support</h3><p>在本实验的开始部分，首先将为jos添加多核支持。在多核模式下，所有CPU地位平等，有相同的系统资源与IO总线访问权。但是，在系统启动时，多CPU可以被分为两类：BSP与AP。BSP在系统上电时接管机器，完成系统的初始化，随后，出于某种需要，BSP将会唤醒AP，AP也可以作为独立的CPU执行指令。</p>
<p>在这种系统之中，每个CPU都有一个模块是<strong>LAPIC</strong>，它负责系统的中断传递，为每个CPU提供一个独特的编号。</p>
<p>LAPIC是Local Advanced Programmable Interrupt Controller，local高级可编程中断控制器。LAPIC一般由中断信号、PRT、一组寄存器与其他一些部件组成，可以处理硬件的中断请求信息，并通知CPU进行处理。</p>
<p>在本次实验中，我们将会用到LAPIC模块的如下功能函数：</p>
<ol>
<li>cpunum()：</li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/87627035.jpg" alt=""></p>
<p>该函数中，通过访问lapic[ID]对应字段获得当前的cpu编号。</p>
<ol start="2">
<li>lapic_startap():</li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/96651596.jpg" alt=""></p>
<p>这个函数中，BSP负责对尚未工作的AP进行初始化与唤醒操作。首先设置向量，然后发送INIT中断来重置其他CPU，最终发送STRARTUP信号与开始执行的位置，使一个CPU正式开始工作。</p>
<ol start="3">
<li>lapic_init():</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">lapic_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!lapicaddr) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// lapicaddr is the physical address of the LAPIC's 4K MMIO</span></span><br><span class="line">	<span class="comment">// region.  Map it in to virtual memory so we can access it.</span></span><br><span class="line">	<span class="comment">//lapiaddr是LAPIC的4K的MIMO区域的物理地址</span></span><br><span class="line">	<span class="comment">//把他映射到虚拟地址空间，就可以访问了</span></span><br><span class="line">	lapic = mmio_map_region(lapicaddr, <span class="number">4096</span>);</span><br><span class="line">	<span class="comment">//enable LAPIC；设置伪中断向量</span></span><br><span class="line">	<span class="comment">// Enable local APIC; set spurious interrupt vector.</span></span><br><span class="line">	<span class="comment">//#define SVR     (0x00F0/4)   // Spurious Interrupt Vector</span></span><br><span class="line">	<span class="comment">//#define ENABLE     0x00000100   // Unit Enable</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//in inc/trap.c</span></span><br><span class="line">	<span class="comment">//#define IRQ_OFFSET	32	// IRQ 0 corresponds to int IRQ_OFFSET</span></span><br><span class="line">	<span class="comment">//// Hardware IRQ numbers. We receive these as (IRQ_OFFSET+IRQ_WHATEVER)</span></span><br><span class="line">	<span class="comment">//#define IRQ_SPURIOUS     7</span></span><br><span class="line">	lapicw(SVR, ENABLE | (IRQ_OFFSET + IRQ_SPURIOUS));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The timer repeatedly counts down at bus frequency</span></span><br><span class="line">	<span class="comment">// from lapic[TICR] and then issues an interrupt.  </span></span><br><span class="line">	<span class="comment">//定时器重复从lapic [TICR]的总线频率倒计数，然后发出中断。</span></span><br><span class="line">	<span class="comment">// If we cared more about precise timekeeping,</span></span><br><span class="line">	<span class="comment">// TICR would be calibrated using an external time source.</span></span><br><span class="line">	<span class="comment">//如果我们更关心精确的计时，TICR将使用外部时间源进行校准。</span></span><br><span class="line">	lapicw(TDCR, X1);<span class="comment">//in this:向lapic数组写入东西lapic[TDCR]=X1;</span></span><br><span class="line">	lapicw(TIMER, PERIODIC | (IRQ_OFFSET + IRQ_TIMER));</span><br><span class="line">	lapicw(TICR, <span class="number">10000000</span>); </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Leave LINT0 of the BSP enabled so that it can get</span></span><br><span class="line">	<span class="comment">// interrupts from the 8259A chip.</span></span><br><span class="line">	<span class="comment">//吧BSP的LINT0（向量表0）enable，这样就可以从8259A芯片得到中断</span></span><br><span class="line">	<span class="comment">// According to Intel MP Specification, the BIOS should initialize</span></span><br><span class="line">	<span class="comment">// BSP's local APIC in Virtual Wire Mode, in which 8259A's</span></span><br><span class="line">	<span class="comment">// INTR is virtually connected to BSP's LINTIN0. In this mode,</span></span><br><span class="line">	<span class="comment">// we do not need to program the IOAPIC.</span></span><br><span class="line">	<span class="comment">//根据英特尔MP规范，BIOS应在虚拟线路模式下初始化BSP的本地APIC，</span></span><br><span class="line">	<span class="comment">//其中8259A的INTR虚拟连接到BSP的LINTIN0。 </span></span><br><span class="line">	<span class="comment">//在这种模式下，我们不需要编程IOAPIC。</span></span><br><span class="line">	<span class="comment">//如果当前cpu不是启动cpu，它的中断表0 被mask</span></span><br><span class="line">	<span class="keyword">if</span> (thiscpu != bootcpu)</span><br><span class="line">		lapicw(LINT0, MASKED);</span><br><span class="line">	<span class="comment">// Disable NMI (LINT1) on all CPUs</span></span><br><span class="line">	<span class="comment">//中断表1都被mask</span></span><br><span class="line">	lapicw(LINT1, MASKED);</span><br><span class="line">	<span class="comment">// Disable performance counter overflow interrupts</span></span><br><span class="line">	<span class="comment">// on machines that provide that interrupt entry.</span></span><br><span class="line">	<span class="comment">//在一些特定的版本（提供了中断入口）的机器上，</span></span><br><span class="line">	<span class="comment">//disable PCINT（性能计数器溢出？？？）</span></span><br><span class="line">	<span class="keyword">if</span> (((lapic[VER]&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0xFF</span>) &gt;= <span class="number">4</span>)</span><br><span class="line">		lapicw(PCINT, MASKED);</span><br><span class="line">	<span class="comment">// Map error interrupt to IRQ_ERROR.</span></span><br><span class="line">	lapicw(ERROR, IRQ_OFFSET + IRQ_ERROR);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Clear error status register (requires back-to-back writes).</span></span><br><span class="line">	lapicw(ESR, <span class="number">0</span>);</span><br><span class="line">	lapicw(ESR, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">// Ack any outstanding interrupts.</span></span><br><span class="line">	lapicw(EOI, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">// Send an Init Level De-Assert to synchronize arbitration ID's.</span></span><br><span class="line">	<span class="comment">//#define ICRHI   (0x0310/4)   // Interrupt Command [63:32]</span></span><br><span class="line">	<span class="comment">//#define INIT       0x00000500   // INIT/RESET</span></span><br><span class="line">	<span class="comment">//#define DELIVS     0x00001000   // Delivery status</span></span><br><span class="line">	<span class="comment">//#define LEVEL      0x00008000   // Level triggered</span></span><br><span class="line">	<span class="comment">//#define BCAST      0x00080000   // Send to all APICs, including self.</span></span><br><span class="line">	lapicw(ICRHI, <span class="number">0</span>);</span><br><span class="line">	lapicw(ICRLO, BCAST | INIT | LEVEL);</span><br><span class="line">	<span class="keyword">while</span>(lapic[ICRLO] &amp; DELIVS) ;</span><br><span class="line">	<span class="comment">// Enable interrupts on the APIC (but not on the processor).</span></span><br><span class="line">	<span class="comment">//TPR 任务优先级</span></span><br><span class="line">	lapicw(TPR, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数初始化LAPIC。像其他结构一样，lapic被映射到固定的物理地址，随后进行各种中断向量的设置以及向量表的mask操作，设置错误状态寄存器的值，最后设置任务优先级。</p>
<p>像VGA设备一样，物理地址空间上也为LAPIC设备留了一个洞，它将会被map到虚拟地址的MMIOBASE。这种访问方式使得CPU可以像访问内存一样访问设备。</p>
<blockquote>
<p><strong>Exercise 1</strong></p>
<p>完成mmio_map_region函数，它将会完成把LAPIC设备所占据的物理地址map到预留的虚拟地址部分。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">mmio_map_region(physaddr_t pa, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Where to start the next region.  Initially, this is the</span></span><br><span class="line">	<span class="comment">// beginning of the MMIO region.  Because this is static, its</span></span><br><span class="line">	<span class="comment">// value will be preserved between calls to mmio_map_region</span></span><br><span class="line">	<span class="comment">// (just like nextfree in boot_alloc).</span></span><br><span class="line">	<span class="comment">//这是mmio开始的地方</span></span><br><span class="line">	<span class="keyword">static</span> uintptr_t base = MMIOBASE;</span><br><span class="line">	<span class="comment">// Reserve size bytes of virtual memory starting at base and</span></span><br><span class="line">	<span class="comment">// map physical pages [pa,pa+size) to virtual addresses</span></span><br><span class="line">	<span class="comment">// [base,base+size).  Since this is device memory and not</span></span><br><span class="line">	<span class="comment">// regular DRAM, you'll have to tell the CPU that it isn't</span></span><br><span class="line">	<span class="comment">// safe to cache access to this memory.  Luckily, the page</span></span><br><span class="line">	<span class="comment">// tables provide bits for this purpose; simply create the</span></span><br><span class="line">	<span class="comment">// mapping with PTE_PCD|PTE_PWT (cache-disable and</span></span><br><span class="line">	<span class="comment">// write-through) in addition to PTE_W.  (If you're interested</span></span><br><span class="line">	<span class="comment">// in more details on this, see section 10.5 of IA32 volume</span></span><br><span class="line">	<span class="comment">// 3A.)</span></span><br><span class="line">	<span class="comment">//保留虚拟内存的的size字节，并把物理地址pa，pa+size给map到base,base+size，</span></span><br><span class="line">	<span class="comment">//由于这是设备的内存，并不是dram，需要告诉cpu缓存到这里的access是不安全的，</span></span><br><span class="line">	<span class="comment">//幸运的是，页表提供了这样的位</span></span><br><span class="line">	<span class="comment">//只需要使用PTE_PCD|PTE_PWT|PTE_W即可</span></span><br><span class="line">	<span class="comment">//如果你对这个很有兴趣，可以去看10.5节，IA32 卷3A</span></span><br><span class="line">	<span class="comment">// Be sure to round size up to a multiple of PGSIZE and to</span></span><br><span class="line">	<span class="comment">// handle if this reservation would overflow MMIOLIM (it's</span></span><br><span class="line">	<span class="comment">// okay to simply panic if this happens).</span></span><br><span class="line">	<span class="comment">//确保你roundsizeup</span></span><br><span class="line">	<span class="comment">//确保你检测是不是会超过MMIOLIM，如果超过了，panic</span></span><br><span class="line">	<span class="comment">// Hint: The staff solution uses boot_map_region.</span></span><br><span class="line">	<span class="comment">//使用boot_map_region</span></span><br><span class="line">	<span class="comment">// Your code here:</span></span><br><span class="line">	<span class="comment">//Note:pa=5 size=7 pgsize=10</span></span><br><span class="line">	<span class="comment">//actually endsp shall be 20</span></span><br><span class="line">	uint32_t endsp=ROUNDUP(size+pa,PGSIZE);</span><br><span class="line">	pa=ROUNDDOWN(pa,PGSIZE);</span><br><span class="line">	size=endsp-pa;</span><br><span class="line">	<span class="keyword">if</span>(base+size&gt;MMIOLIM)panic(<span class="string">"the reservation would overflow MMIOLIM"</span>);</span><br><span class="line">	boot_map_region(kern_pgdir,base,size,pa,PTE_PCD|PTE_PWT|PTE_W);</span><br><span class="line">	<span class="comment">//panic("mmio_map_region not implemented");</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	base+=size;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">void</span>*)(base-size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里需要注意的是size与paddr的关系。由于最终覆盖到的地址应该在size+paddr，因此不能使用ROUNDDOWN(paddr)与ROUNDUP(size)直接做运算，否则可能会产生缺页的情况。</p>
</blockquote>
<h3 id="Application-Processor-Bootstrap"><a href="#Application-Processor-Bootstrap" class="headerlink" title="Application Processor Bootstrap"></a>Application Processor Bootstrap</h3><p>在<strong>i386_init</strong>函数中，本实验又增加了新的初始化过程：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/96728212.jpg" alt=""></p>
<p>在启动AP之前，BSP将会首先去获知多处理器的信息，比如CPU总数，他们各自的APIC编号以及LAPIC的MMIO地址。<strong>kern/mpconfig.c</strong>中的<strong>mp_init</strong>函数通过访问MP配置表来获知这些信息。随后，<strong>lapic_init</strong>初始化LAPIC设备，<strong>pic_init</strong>在更底层的部分初始化8259A的中断控制器。最后<strong>boot_aps</strong>函数(kern/init.c)将会启动各个AP，使他们从<strong>MPENTRY_PADDR</strong>开始运行。</p>
<p><strong>boot_aps</strong>函数如下：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/39840649.jpg" alt=""></p>
<p>可以看到，BSP首先将AP启动后执行的代码搬到AP的启动位置code，随后逐个唤醒AP。对每一个AP，将会告诉它它的内核栈的位置，随后调用<strong>lapic_statrap</strong>(kern/lapic.c)。lapic_startap的代码在上方已经贴出，它为CPU设置各种中断信息并最终给出STRATUP信号表明AP已经设置完成，随后AP开始从给定地址开始运行。进入<strong>mpentry.S</strong>的运行，设置initial页表并转入自己的内核栈，随后调用<strong>mp_main</strong>函数，设置页表，初始化LAPIC、GDT以及trap，随后告诉<strong>boot_aps</strong>这个CPU设置完毕，<strong>boot_aps</strong>接收到AP的信息之后，进入下一个AP的初始化。</p>
<p>随后就像在Lab3中的那样，调用用户程序。</p>
<blockquote>
<p><strong>Exercise 2</strong></p>
<p>修改<strong>page_init</strong>函数，不再将从MPENTRY_PADDR开始的虚拟地址添加到可用页上，给出更新后的函数：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/29015296.jpg" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Question</strong></p>
<ol>
<li>Compare kern/mpentry.S side by side with boot/boot.S. Bearing in mind that kern/mpentry.S is compiled and linked to run above KERNBASE just like everything else in the kernel, what is the purpose of macro MPBOOTPHYS? Why is it necessary in kern/mpentry.S but not in boot/boot.S? In other words, what could go wrong if it were omitted in kern/mpentry.S? Hint: recall the differences between the link address and the load address that we have discussed in Lab 1. </li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/70313494.jpg" alt=""><br>MPBOOTYPHYS的目的是计算应该访问的地址。<br>与boot.S不同，在mpentry.S中启动的AP，其load进的地址并不是像boot一样与假设自己被加载进来的地址相同，而是被BSP加载到MPENTRY_PADDR。为了访问到正确的物理地址，应该换算成希望加载进来的地址再进行对地址的操作。</p>
</blockquote>
<h3 id="Per-CPU-State-and-Initialization"><a href="#Per-CPU-State-and-Initialization" class="headerlink" title="Per-CPU State and Initialization"></a>Per-CPU State and Initialization</h3><p>在多CPU的系统中，需要明确每个CPU私有的状态以及共有的资源划分。在<strong>kern/cpu.h</strong>中定义的CpuInfo结构存储有大部分的私有信息。thiscpu指向当前cpu的CpuInfo结构。</p>
<blockquote>
<p><strong>Exercise 3</strong><br>修改<strong>mem_init_mp</strong>函数，为每个CPU map一个内核栈。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/29300920.jpg" alt=""></p>
<p>像在memlayout.h中定义的那样，补充后的代码是：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/92996124.jpg" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Exercise 4</strong></p>
<p>修改<strong>trap_init_percpu</strong>使得在多CPU环境下可以运行</p>
<p>代码：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/58108225.jpg" alt=""></p>
<p>这段代码中一共有四个需要修改的地方，一是所有的ts应该修改为thiscpu-&gt;ts，而是栈顶应该由KSTACKTOP-(KSTKSIZE + KSTKGAP)变为KSTACKTOP-i*(KSTKSIZE + KSTKGAP)，三是gdt中tss表项位置应该由[(GD_TSS0 &gt;&gt; 3)变为[(GD_TSS0 &gt;&gt; 3)+i，四是load选择子的时候应该修改为对应cpu的选择子ltr(GD_TSS0+i*8);。</p>
</blockquote>
<p>这样就完成了不同CPU的trap初始化。</p>
<p>完成这里的操作之后，make qemu CPUS=4，可以看到所有函数检查通过，CPU信息输出。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/75077349.jpg" alt=""></p>
<h3 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a>Locking</h3><p>上述完成之后，代码将会停在原地。为了使得AP能够进一步运行，需要首先解决多个CPU同时运行内核代码的竞争状况。为了解决这个问题，采用内核锁机制。当有进程在内核空间时，内核将会上一个锁，回到用户空间后，锁被释放。</p>
<p>在<strong>kern/spinlock.h</strong>中定义了一个kernel_lock，提供了<strong>lock_kernel</strong>与<strong>unlock_kernel</strong>函数。需要我们自己来决定加锁解锁的位置。</p>
<blockquote>
<p><strong>Exercise 5</strong><br>加锁与解锁</p>
<ol>
<li><p>在i386_init中，在BSP唤醒其他CPU之前加锁：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/63950397.jpg" alt=""></p>
</li>
<li><p>在mp_main中，在AP初始化之后加锁，然后调用sched_yield来开始调度。<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/24870973.jpg" alt=""></p>
</li>
<li><p>在trap中，如果是从用户模式来的trap，就获得锁。<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/38167577.jpg" alt=""></p>
</li>
<li><p>在env_run中，在进入用户模式的时候释放锁<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/44217150.jpg" alt=""></p>
</li>
</ol>
</blockquote>
<hr>
<blockquote>
<p>Question</p>
<ol>
<li>It seems that using the big kernel lock guarantees that only one CPU can run the kernel code at a time. Why do we still need separate kernel stacks for each CPU? Describe a scenario in which using a shared kernel stack will go wrong, even with the protection of the big kernel lock. </li>
</ol>
</blockquote>
<blockquote>
<p>这是因为在lab3中已经写过，当用户进程发生中断的时候，执行的代码中有：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/35810116.jpg" alt=""><br>这段代码是产生中断之后硬件自己就会执行的，在这个时候仍未调用trap，自然还没有为内核加锁。也就是说，如果使用同一个栈，当两个cpu同时发生中断的时候，这段代码很可能会被打断执行顺序，从而导致内核栈的混乱。</p>
</blockquote>
<h3 id="Round-Robin-Scheduling"><a href="#Round-Robin-Scheduling" class="headerlink" title="Round-Robin Scheduling"></a>Round-Robin Scheduling</h3><p>接下来，将会修改调度过程的代码，来为jos添加调度的功能。</p>
<p>在这里，这个功能会被描述为：</p>
<p>函数<strong>shced_yield</strong>负责选择一个新进程运行，它从当前运行进程的编号开始寻找，找第一个有着ENV_RUNNABLE的进程把运行权交付给它。如果没有其他进程是ENV_RUNNABLE状态而且现在的进程还可以运行，那就还让现在的进程运行。</p>
<blockquote>
<p><strong>Exercise 6</strong></p>
<p>修改该sched_yield函数：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/8461936.jpg" alt=""></p>
</blockquote>
<p>需要注意的是，这时syscall函数仍未被完成，需要在此后陆续添加更多的SYS_*来允许用户空间的系统调用。</p>
<p>随后可以测试，修改i386_init函数，创建3个进程：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/59214383.jpg" alt=""></p>
<p>使用make qemu CPUS=2，可以得到结果：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/79530109.jpg" alt=""></p>
<blockquote>
<p>Question</p>
<ol>
<li>In your implementation of env_run() you should have called lcr3(). Before and after the call to lcr3(), your code makes references (at least it should) to the variable e, the argument to env_run. Upon loading the %cr3 register, the addressing context used by the MMU is instantly changed. But a virtual address (namely e) has meaning relative to a given address context–the address context specifies the physical address to which the virtual address maps. Why can the pointer e be dereferenced both before and after the addressing switch? </li>
</ol>
<p>e所指示的空间是在mem_init中被申请的物理空间，它并不会存在于每个进程的可用页表里供进程自己决定map的虚拟地址，而是对每个进程而言都是一样的。</p>
<ol start="2">
<li>Whenever the kernel switches from one environment to another, it must ensure the old environment’s registers are saved so they can be restored properly later. Why? Where does this happen?</li>
</ol>
<p>只有这样做，才能保存上一个进程的运行状态信息，恢复进程运行时才不会出错。<br>这个操作发生在trap函数中，代码是这样的：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/86607615.jpg" alt=""><br>它保存了发生trap的进程的tf。<br>然而，进程之间切换由kernel决定。每次发生进程调度，都会发生trap（这里将syscall主动放弃cpu也通过trap完成）</p>
</blockquote>
<h3 id="System-Calls-for-Environment-Creation"><a href="#System-Calls-for-Environment-Creation" class="headerlink" title="System Calls for Environment Creation"></a>System Calls for Environment Creation</h3><p>下面将允许用户进程创建子进程并执行。</p>
<p>在Unix中，fork函数可以用来创建子进程。这个子进程完全copy了父进程的地址空间，二者唯一不同的是在父进程中fork返回子进程的编号而在子进程中返回的是0。</p>
<p>我们将实现一个更加原始的fork，首先需要完成一些系统调用函数。<br>在这些个函数之中，需要频繁用到函数envid2env来检查进程操作是否合法，首先来分析这个envid2env函数：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/74947768.jpg" alt=""></p>
<p>如果envid是0，说明是当前进程希望获得自己的env结构，直接允许获得，返回curenv，函数成功。<br>如果给的envid不合法或者指定进程是free进程，无法得到进程结构，返回bad environment。<br>否则如果指定需要检查权限，那么给定的envid必须是当前进程的子进程，如果满足要求返回成功，否则返回失败：bad environment。</p>
<blockquote>
<p><strong>Exercise 7</strong>：</p>
<p>只需要按照要求完成代码：</p>
<p><strong>sys_exofork</strong>：创建一个新进程，其中，用户地址空间没有任何map，不可以运行。子进程将会拥有和父进程一样的寄存器状态值，该函数在子进程中返回0，在父进程中返回子进程的id。（由于子进程刚刚被创建的时候是没有执行能力的，因此实际上，在子进程中是无法返回的，直到其父进程用下面的函数将子进程标记为可运行）<br>代码：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/70937828.jpg" alt=""></p>
<p><strong>sys_env_set_status</strong>：设置一个进程的状态为ENV_RUNNABLE或者是ENV_NOT_RUNNABLE。<br>代码：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/20728662.jpg" alt=""></p>
<p><strong>sys_page_alloc</strong>：申请一个物理页并把它map在给定进程的给定地址。<br>代码：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/47728587.jpg" alt=""></p>
<p><strong>sys_page_map</strong>：把给定进程的某一个页的映射同样映射到另一个进程的给定地址，这样，这两个进程享有了共享的一个物理页。<br>代码：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/41333018.jpg" alt=""></p>
<p><strong>sys_page_unmap</strong>：把某一个页从某一个进程的对应地址上unmap。<br>代码：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/27465683.jpg" alt=""></p>
</blockquote>
<p>完成这些之后，partA的dumbfork测试就可以通过了。</p>
<h2 id="Part-B-Copy-on-Write-Fork"><a href="#Part-B-Copy-on-Write-Fork" class="headerlink" title="Part B: Copy-on-Write Fork"></a>Part B: Copy-on-Write Fork</h2><p>像在前面提到的一样，Unix提供了fork函数，这个函数将会复制整个父进程的地址空间。xv6 Unix的fork将会复制父进程的所有页到新的页，这也是在dumbfork里面做的。但是，这样的操作耗时而且通常都是无用功：创建出的子进程可能很快就会被父进程委派去做其他的工作，子进程的地址空间很快会被新的数据取代。</p>
<p>出于这种考虑，现在来实现一种新的特性，子进程与父进程将享有同一套地址空间，直到有进程真的要去修改这块空间。这样的技术叫做<strong>copy-on-write</strong>。</p>
<p>在这种特性之下，当创建子进程的时候，父进程仅仅将自己的映射关系给子进程，同时把自己共享出去的页都标记为只读。当有一方想要修改该虚拟地址空间时触发一个page fault，这时，内核才真正意识到需要一个新的页，这时才会去为发生错误的进程申请一个自己的页。这样的设计使得子进程在执行之前花费的代价很少，一般只会有一个栈的页。</p>
<h3 id="User-level-page-fault-handling"><a href="#User-level-page-fault-handling" class="headerlink" title="User-level page fault handling"></a>User-level page fault handling</h3><p>用户层面的缺页异常有很多种引起的可能，cow只是其中的一种。内核必须能够决定为不同程序空间引起的缺页异常提供不一样的解决方式，比如，在栈中发生的缺页异常需要申请并map一个物理页，在bss区域引起的缺页中断会申请一个全0的物理页然后映射。</p>
<p>对内核来说，有很多信息都可以作为判断依据，接下来，将完成我们的pgfault处理函数。</p>
<h3 id="Setting-the-Page-Fault-Handler"><a href="#Setting-the-Page-Fault-Handler" class="headerlink" title="Setting the Page Fault Handler"></a>Setting the Page Fault Handler</h3><p>为了处理缺页中断，用户进程需要向内核注册并存储自己的缺页中断处理函数的入口点。为了实现这个功能，在Env结构中新加了成员<code>env_pgfault_upcall</code>。</p>
<blockquote>
<p><strong>Exercise 8</strong>：<br>完成函数<code>sys_env_set_pgfault_upcall</code>，确保进行了权限检查。</p>
<p>根据提示，该函数为特定进程设置一个缺页中断处理函数。这个进程必须是自己或者是自己的子进程。<br>写出代码：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/2663658.jpg" alt=""></p>
</blockquote>
<h3 id="Normal-and-Exception-Stacks-in-User-Environments"><a href="#Normal-and-Exception-Stacks-in-User-Environments" class="headerlink" title="Normal and Exception Stacks in User Environments"></a>Normal and Exception Stacks in User Environments</h3><p>在正常的执行中，用户进程将会在用户栈中执行，esp指向栈顶，当一个缺页中断发生的时候，内核将会使用户进程重新在另一个栈中运行缺页中断的处理函数。也就是，我们需要使内核能够自动换栈。</p>
<p>异常栈有一个page大小，最顶端是UXSTACKTOP。因此，第一个中断发生后将会空间UXSTACKTOP-PGSIZE到UXSTACKTOP之间作为异常栈。在处理函数中可以通过各种调用恢复原进程的正确执行，随后该函数返回，回到上次发生中断的地方，重新执行出错代码。<br>每一个希望有用户层次的缺页中断处理函数的进程都必须支持申请新页来作为他自己的异常栈。</p>
<h3 id="Invoking-the-User-Page-Fault-Handler"><a href="#Invoking-the-User-Page-Fault-Handler" class="headerlink" title="Invoking the User Page Fault Handler"></a>Invoking the User Page Fault Handler</h3><p>接下来我们要修改trap中的代码，使它有以下的功能。</p>
<p>如果这个用户进程并没有自己的缺页中断处理函数，当他有缺页中断发生的时候，就销毁这个进程然后退出，否则。</p>
<p>异常栈中的情况是这样的：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/95241296.jpg" alt=""></p>
<p>UXSTTACKTOP是栈底，依次push进了许多变量，他们与结构<strong>UTrapframe</strong>吻合。函数执行结束后，需要从异常栈返回原本的用户栈。</p>
<p>实际情况中可能更加复杂：缺页中断额处理函数本身还可能会发生中断，这时，继续往栈顶push数据，但是需要注意，由于一些原因，需要先push一个32bit的空位。这个将会在后面进行解释。如果tf-&gt;tf_esp在上述区域之中，那么就是在异常栈中发生的缺页中断，否则就是在原本的用户进程中发生的中断。</p>
<blockquote>
<p><strong>Exercise 9</strong></p>
<p>完成函数<code>page_fault_handler</code>。他需要将用户空间的缺页中断给用户的处理函数。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/77522130.jpg" alt=""></p>
<p>首先，只有有处理函数才能进行下一步的操作，否则将会free掉这个进程。<br>随后确定将要push的结构的首地址。如果当前进程可以访问这个地址，那么就把对应的地址写为对应的值，保存好之前执行状态的信息。保存完之后，将程序的下一个执行地址设置为函数的入口地址，将该进程的栈顶设置为异常栈的栈顶，运行。</p>
</blockquote>
<h3 id="User-mode-Page-Fault-Entrypoint"><a href="#User-mode-Page-Fault-Entrypoint" class="headerlink" title="User-mode Page Fault Entrypoint"></a>User-mode Page Fault Entrypoint</h3><p>接下来，需要我们完成执行C程序并且返回到原执行状态的汇编指令，该汇编指令是<code>sys_env_set_pgfault_upcall</code>的处理过程。</p>
<blockquote>
<p><strong>Exercise 10</strong>：<br>完成lib/pfentry.S中的<code>_pgfault_upcall</code>过程。</p>
<p>只需要根据提示，结合上述的异常栈动作：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/27738708.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/86236764.jpg" alt=""></p>
</blockquote>
<p>最后，完成C程序库部分的缺页异常处理机制：</p>
<blockquote>
<p><strong>Exercise 11</strong>：<br>完成lib/pgfault.c中的<code>set_pgfault_handler</code>函数：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/14374721.jpg" alt=""></p>
</blockquote>
<h3 id="Implementing-Copy-on-Write-Fork"><a href="#Implementing-Copy-on-Write-Fork" class="headerlink" title="Implementing Copy-on-Write Fork"></a>Implementing Copy-on-Write Fork</h3><p>fork函数是一个cow的子进程创建函数，它的控制流程是这样的：</p>
<ol>
<li><p>使用<code>set_pgfault_handler</code>来确定中断处理函数C程序层面的入口</p>
</li>
<li><p>调用<code>sys_exofork</code>创建一个新进程</p>
</li>
<li><p>对每一个可写的或是cow的在UTOP之下的页，父进程为之调用<strong>duppage</strong>函数，这个函数将会把cow的页map到子进程地址空间，然后重新在自己的地址空间map这些页。</p>
</li>
<li><p>父进程为子进程设置缺页中断处理函数入口点</p>
</li>
<li><p>子进程可以运行了，父进程将其标志为RUNNABLE</p>
</li>
</ol>
<p>之后，每次想要修改cow页面都会触发缺页中断，触发之后过程如下：</p>
<ol>
<li><p>kernel把pagefault告诉_pgfault_upcall，执行入口调用pgfault函数</p>
</li>
<li><p>pgfault检查错误是写错误而且页面是cow，否则panic</p>
</li>
<li><p>pgfault申请新的页，map到一个临时地址，把出错的页面信息copy到新的页面，随后把新页map到一个合适的地址。</p>
</li>
</ol>
<p>kernle会把进程的页表都map到UVPT页目录map到UVPD，方便根据虚拟地址获取对应页的权限信息。首先我们先来看一看这个小技巧。</p>
<p>在内核中可以使用函数<code>pgdir_walk</code>获得权限信息，但是在用户空间，虚拟地址的翻译决定了自身的页表与页目录是不可见的。为了方便的获取权限信息，我们向用户进程的页目录中插入一个特殊的entry。这个entry指向页目录的首部。</p>
<p>这样，当我们访问一个PDX与PTX均是特定数值V的虚拟地址时，我们访问到了页目录。<br>这个地址作为指针数组的开头，使用某虚拟地址的PDX作为索引，使我们可以访问到页目录的各项。</p>
<p>当我们访问一个PDX是V但是PTX不是V的虚拟地址时，我们访问到了页表。同样地我们可以访问到各个页表项。</p>
<p>上述提到的两个虚拟地址分别是UVPD与UVPT。在memlayout.h中定义。<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/57100150.jpg" alt=""></p>
<blockquote>
<p><strong>Exercise 12</strong>：<br>完成frok，duppage以及pgfault。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/99153651.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/36579327.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/42000412.jpg" alt=""></p>
</blockquote>
<p>partB到这里就结束了，在进入partC之前，首先来梳理一下从fork开始的整个运行过程。</p>
<p>当一个用户进程调用fork函数创建子进程，在fork中将申请一个新的进程，复制父进程的地址空间映射给子进程并把二者空间中的对应页都标记为cow，随后父进程为子进程申请用户栈，设置缺页处理过程入口点，最终将子进程的状态标记为可运行。fork退出后将得到两个可运行的进程，在子进程中fork函数返回的是0，在父进程中返回的是子进程的进程id，随后二者可以区分开开始运行。</p>
<p>子进程开始运行其他东西或是父进程需要写数据的时候，其中一个必然会触发一个cow的缺页中断。这个进程的缺页中断经过内核dispatch，将会执行我们在trap中完成的处理函数，假设它已经设置了自己的处理函数，那么就会创建一个异常栈，开始执行在pfentry.S中的汇编代码，执行完毕之后返回原来发生错误的执行位置，继续执行。</p>
<h2 id="Part-C-Preemptive-Multitasking-and-Inter-Process-communication-IPC"><a href="#Part-C-Preemptive-Multitasking-and-Inter-Process-communication-IPC" class="headerlink" title="Part C: Preemptive Multitasking and Inter-Process communication (IPC)"></a>Part C: Preemptive Multitasking and Inter-Process communication (IPC)</h2><h3 id="Clock-Interrupts-and-Preemption"><a href="#Clock-Interrupts-and-Preemption" class="headerlink" title="Clock Interrupts and Preemption"></a>Clock Interrupts and Preemption</h3><p>在此之前，我们不同进程之间的调度都是自愿的。下面将通过引入时钟中断来强制进行调度。</p>
<h3 id="Interrupt-discipline"><a href="#Interrupt-discipline" class="headerlink" title="Interrupt discipline"></a>Interrupt discipline</h3><p>外部中断在本实验中一共有16个，标号是32-47。在本实验中，内核中的外部中断被忽略，在用户空间中通过设置FL_IF来设置允许外部中断。</p>
<blockquote>
<p><strong>Exercise 13</strong>：<br>修改trapentry.S以及trap.c来初始化上述的中断，然后修改该env_alloc允许用户空间的外部中断</p>
<p>像上一个实验一样即可：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/19942562.jpg" alt=""><br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/85310004.jpg" alt=""></p>
<p>只需在指定的位置将新建的env的tf_eflags修改为FL_IF允许即可。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/89863916.jpg" alt=""></p>
</blockquote>
<h3 id="Handling-Clock-Interrupts"><a href="#Handling-Clock-Interrupts" class="headerlink" title="Handling Clock Interrupts"></a>Handling Clock Interrupts</h3><p>在lapic_init以及pic_init中，已经设置好了产生时钟中断，下面需要处理时钟中断。</p>
<blockquote>
<p><strong>Exercise 14</strong>：<br>修改trap_dispatch，它调用sched_yield。<br>直接给出代码：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/87756184.jpg" alt=""></p>
</blockquote>
<h3 id="Inter-Process-communication-IPC"><a href="#Inter-Process-communication-IPC" class="headerlink" title="Inter-Process communication (IPC)"></a>Inter-Process communication (IPC)</h3><p>进程间的通信有很多种模型，这里只实现简单的一种。</p>
<h3 id="IPC-in-JOS"><a href="#IPC-in-JOS" class="headerlink" title="IPC in JOS"></a>IPC in JOS</h3><p>这里进程可以相互发送或接收的信息有：一个32bit的数据或是一整个页。整个页的发送是通过共享内存来实现的，这在下面将具体说明。</p>
<h3 id="Sending-and-Receiving-Messages"><a href="#Sending-and-Receiving-Messages" class="headerlink" title="Sending and Receiving Messages"></a>Sending and Receiving Messages</h3><p>为了接收数据，进程将调用sys_ipc_recv。这个系统调用使这个进程不可运行，直到收到数据。当进程等待接收消息时，任何其他进程都可以向其发送消息不会检查权限。</p>
<p>为了尝试发送一个值，一个环境调用sys_ipc_try_send与接收者的环境ID和要发送的值。如果指定的环境实际上正在接收（它已经调用sys_ipc_recv并且还没有获得值），则发送递送消息并返回0.否则发送返回-E_IPC_NOT_RECV以指示目标环境当前不期望接收值。</p>
<h3 id="Transferring-Pages"><a href="#Transferring-Pages" class="headerlink" title="Transferring Pages"></a>Transferring Pages</h3><p>当进程使用小于UTOP的dstva调用sys_ipc_recv时，表明它愿意接收页面映射。如果发送者发送一个页面，那么该页面应该被映射到接收者地址空间中的dstva。如果接收者已经有了一个映射到dstva的页面，那么这个页面被unmap。</p>
<p>当环境使用小于UTOP的srcva调用sys_ipc_try_send时，说明发送者想要发送当前映射到srcva（发送者）的页面到接收者，具有权限perm。在一个成功的IPC之后，发送者在srcva的地址空间保留其原始的映射，但是接收者也在接收者的地址空间中获得了原来由接收者指定的dstva的同一物理页面的映射。结果这个页面在发送者和接收者之间被共享。</p>
<p>如果发送者或接收者不指示应该传送页面，则不传送页面。在任何IPC之后，内核将接收方的Env结构中的新字段env_ipc_perm设置为所接收页面的权限，如果没有收到页面，则为零。</p>
<h3 id="Implementing-IPC"><a href="#Implementing-IPC" class="headerlink" title="Implementing IPC"></a>Implementing IPC</h3><blockquote>
<p><strong>Exercise 15</strong>：<br>根据说明补充syscall与ipc中的函数：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/20379443.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/74580574.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/80248583.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/16842939.jpg" alt=""></p>
</blockquote>
<p>本实验结束。</p>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/OS/" rel="tag"># OS</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2017/12/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E6%88%91%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8/" rel="next" title="我的编译器">
                  <i class="fa fa-chevron-left"></i> 我的编译器
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2017/12/16/%E6%9C%88%E5%8D%8E/%E6%B5%81%E5%85%89/" rel="prev" title="流光">
                  流光 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Lab4-Document"><span class="nav-number">1.</span> <span class="nav-text">Lab4-Document</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-A-Multiprocessor-Support-and-Cooperative-Multitasking"><span class="nav-number">1.1.</span> <span class="nav-text">Part A: Multiprocessor Support and Cooperative Multitasking</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Multiprocessor-Support"><span class="nav-number">1.1.1.</span> <span class="nav-text">Multiprocessor Support</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Application-Processor-Bootstrap"><span class="nav-number">1.1.2.</span> <span class="nav-text">Application Processor Bootstrap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Per-CPU-State-and-Initialization"><span class="nav-number">1.1.3.</span> <span class="nav-text">Per-CPU State and Initialization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Locking"><span class="nav-number">1.1.4.</span> <span class="nav-text">Locking</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Round-Robin-Scheduling"><span class="nav-number">1.1.5.</span> <span class="nav-text">Round-Robin Scheduling</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#System-Calls-for-Environment-Creation"><span class="nav-number">1.1.6.</span> <span class="nav-text">System Calls for Environment Creation</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-B-Copy-on-Write-Fork"><span class="nav-number">1.2.</span> <span class="nav-text">Part B: Copy-on-Write Fork</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#User-level-page-fault-handling"><span class="nav-number">1.2.1.</span> <span class="nav-text">User-level page fault handling</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Setting-the-Page-Fault-Handler"><span class="nav-number">1.2.2.</span> <span class="nav-text">Setting the Page Fault Handler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Normal-and-Exception-Stacks-in-User-Environments"><span class="nav-number">1.2.3.</span> <span class="nav-text">Normal and Exception Stacks in User Environments</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Invoking-the-User-Page-Fault-Handler"><span class="nav-number">1.2.4.</span> <span class="nav-text">Invoking the User Page Fault Handler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#User-mode-Page-Fault-Entrypoint"><span class="nav-number">1.2.5.</span> <span class="nav-text">User-mode Page Fault Entrypoint</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Implementing-Copy-on-Write-Fork"><span class="nav-number">1.2.6.</span> <span class="nav-text">Implementing Copy-on-Write Fork</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-C-Preemptive-Multitasking-and-Inter-Process-communication-IPC"><span class="nav-number">1.3.</span> <span class="nav-text">Part C: Preemptive Multitasking and Inter-Process communication (IPC)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Clock-Interrupts-and-Preemption"><span class="nav-number">1.3.1.</span> <span class="nav-text">Clock Interrupts and Preemption</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Interrupt-discipline"><span class="nav-number">1.3.2.</span> <span class="nav-text">Interrupt discipline</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Handling-Clock-Interrupts"><span class="nav-number">1.3.3.</span> <span class="nav-text">Handling Clock Interrupts</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Inter-Process-communication-IPC"><span class="nav-number">1.3.4.</span> <span class="nav-text">Inter-Process communication (IPC)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IPC-in-JOS"><span class="nav-number">1.3.5.</span> <span class="nav-text">IPC in JOS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sending-and-Receiving-Messages"><span class="nav-number">1.3.6.</span> <span class="nav-text">Sending and Receiving Messages</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Transferring-Pages"><span class="nav-number">1.3.7.</span> <span class="nav-text">Transferring Pages</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Implementing-IPC"><span class="nav-number">1.3.8.</span> <span class="nav-text">Implementing IPC</span></a></li></ol></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/avatar.gif"
      alt="傻瓜日和">
  <p class="site-author-name" itemprop="name">傻瓜日和</p>
  <div class="site-description" itemprop="description">来如春梦不多时 去似朝云无觅处</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/yayi2456" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;yayi2456" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:yangying2456@gmail.com" title="E-Mail &amp;rarr; mailto:yangying2456@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">傻瓜日和</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.2
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.2"></script><script src="/js/motion.js?v=7.4.2"></script>
<script src="/js/schemes/pisces.js?v=7.4.2"></script>

<script src="/js/next-boot.js?v=7.4.2"></script>



  








  <script src="/js/local-search.js?v=7.4.2"></script>










<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'forest',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>




  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":"hijiki","bottom":-30,"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
