<!DOCTYPE html>





<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.2">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=7.4.2">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=7.4.2">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.2" color="#222">
  <link rel="alternate" href="/atom.xml" title="日和" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css?v=7.4.2">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '61a4cd7c1bed364065c7fe56474ba5df',
      indexName: 'yayiblogsearch',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Lab3 Document">
<meta name="keywords" content="OS">
<meta property="og:type" content="article">
<meta property="og:title" content="Lab3_Document">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2017&#x2F;11&#x2F;27&#x2F;OS&#x2F;Lab3_Document&#x2F;index.html">
<meta property="og:site_name" content="日和">
<meta property="og:description" content="Lab3 Document">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;83894027.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;91108119.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;83957122.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;74775132.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;30532.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;30871223.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;79807638.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-14&#x2F;87170051.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;27936694.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;10236379.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;2785767.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;63275240.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;96169964.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;5194488.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;93817695.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;34710148.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;42158612.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;48273990.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;41487023.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;24297553.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;69032262.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;45324538.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;22708337.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;79810310.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;326256.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;93317967.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;36947975.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;4368506.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;34291928.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;78360085.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;25025088.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;52901081.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;25564738.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;1130654.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;12202433.jpg">
<meta property="og:updated_time" content="2018-07-20T18:07:05.899Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;oysmkdi7t.bkt.clouddn.com&#x2F;17-11-28&#x2F;83894027.jpg">
  <link rel="canonical" href="http://yoursite.com/2017/11/27/OS/Lab3_Document/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Lab3_Document | 日和</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">日和</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">BE WITH ME</p>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
        
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      
    
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger">
          <i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/27/OS/Lab3_Document/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="傻瓜日和">
      <meta itemprop="description" content="来如春梦不多时 去似朝云无觅处">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日和">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            Lab3_Document
            

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2017-11-27 19:00:00" itemprop="dateCreated datePublished" datetime="2017-11-27T19:00:00+08:00">2017-11-27</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-07-21 02:07:05" itemprop="dateModified" datetime="2018-07-21T02:07:05+08:00">2018-07-21</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/MIT-Lab/" itemprop="url" rel="index">
                    <span itemprop="name">MIT Lab</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Lab3-Document"><a href="#Lab3-Document" class="headerlink" title="Lab3 Document"></a>Lab3 Document</h1><a id="more"></a>

<h2 id="Part-A：User-Enviornments-and-Exception-Handling"><a href="#Part-A：User-Enviornments-and-Exception-Handling" class="headerlink" title="Part A：User Enviornments and Exception Handling"></a>Part A：User Enviornments and Exception Handling</h2><p>在这一部分，首先需要了解关于在本实验中env（进程）的相关定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in inc/env.h</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    ENV_FREE = <span class="number">0</span>,</span><br><span class="line">    ENV_DYING,</span><br><span class="line">    ENV_RUNNABLE,</span><br><span class="line">    ENV_RUNNING,</span><br><span class="line">    ENV_NOT_RUNNABLE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这是在本实验中定义的进程状态，在实验中，仅用到了ENV_FREE、ENV_RUNNABLE、以及ENV_RUNNING。</p>
<p>类似于课上讲的pcb，在本实验中对一个进程的描述定义如下：</p>
<p><code>//in inc/env.c</code></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/83894027.jpg" alt=""></p>
<p>第一个变量env_tf是当中断或异常或系统调用发生的时候，该进程需要保存的寄存器的值；最后一个变量指明了该进程的地址空间。</p>
<p>在kern/env.c中可以看到，关于进程，有三个全局的变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">envs</span> = <span class="title">NULL</span>;</span><span class="comment">// All environments</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">curenv</span> = <span class="title">NULL</span>;</span><span class="comment">// The current env</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_free_list</span>;</span><span class="comment">// Free environment list</span></span><br></pre></td></tr></table></figure>

<p>在马上进行的初始化之后，在envs所标识的物理地址开始，一直到<code>NENV\*(struct Env)</code>结束，是所有可以被使用的进程描述结构占用的空间，每一个(struct Env)大小都是一个可用的Env描述。curenv被指示为是当前正在运行的进程。env_free_list指向第一个可以使用的进程描述结构，这样的设计使得进程描述结构的申请与销毁都变得很容易，而且由于该链表中存储的是处于ENV_FREE状态的进程，很少需要有添加删除的过程。</p>
<h3 id="Allocating-the-Environments-Array"><a href="#Allocating-the-Environments-Array" class="headerlink" title="Allocating the Environments Array"></a>Allocating the Environments Array</h3><p>就像在实验二中那样，在这里需要修改<code>pmap.c</code>中的代码，为envs映射空间。仿照在lab2中的写法，修改程序如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in kern/pmap.c the first LAB3: Your code here</span></span><br><span class="line">envs=(struct Env\*)(boot\_alloc(NENV\*<span class="keyword">sizeof</span>(struct Env)));<span class="comment">//为Env结构申请空间</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in kern/pmap.c the second LAB3: Your code here</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ROUNDUP(NENV\*<span class="keyword">sizeof</span>(struct Env),PGSIZE);i+=PGSIZE)&#123;</span><br><span class="line">        page_insert(kern_pgdir,(struct PageInfo\*)pa2page(PADDR(envs)+i),(<span class="keyword">void</span>\*)(UENVS+i),PTE_U);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>像在lab2中做过的那样，<code>boot\_map\_region</code>使得从PADDR(envs)开始，连续PTSIZE的物理空间映射到从UENVS开始的虚拟地址空间上。</p>
<p>做到这里尝试<code>make qemu</code>的时候，发现失败了。</p>
<p><strong>注意</strong>：回想在lab2中所做的工作，在<code>page_init</code>函数中曾经为没有用的页面加入freelist。查看当时的代码发现，那时计算剩余空间的时候，是从为npages分配空间呢的后一页开始计算的。在<code>mem_init</code>中修改了之后的映射之后，这时的freelist应该从envs占用所有空间之后的第一页进行添加，于是修改代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> begin=(<span class="keyword">int</span>)ROUNDUP(((<span class="keyword">char</span>*)envs) + (<span class="keyword">sizeof</span>(struct Env) * NENV) - <span class="number">0xf0000000</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=begin/PGSIZE;i&lt;npages;i++)&#123;</span><br><span class="line">    pages[i].pp_ref=<span class="number">0</span>;</span><br><span class="line">    pages[i].pp_link=page_free_list;</span><br><span class="line">    page_free_list=&amp;pages[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次<code>make qemu</code>，得到结果如下：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/91108119.jpg" alt=""></p>
<h3 id="Creating-and-Running-Environments"><a href="#Creating-and-Running-Environments" class="headerlink" title="Creating and Running Environments"></a>Creating and Running Environments</h3><p>在这一部分，将会完善<code>kern/env.c</code>中的内容，来建立起一个进程操作的雏形。</p>
<p>由于还没有文件系统，这时我们用一个技巧来骗过boot loader，使得bootloader加载kernel的时候也把我们需要的用户程序加载进来。这些用户程序在<code>user</code>文件夹下。</p>
<p>首先， -b binary option告诉编译器只需要将程序编译成二进制文件，而不需要生成.o文件，随后把这个文件作为一个较大的数组放在最后，同时在真正应该被搬进内存的文件中声明extern变量，告诉编译器在链接之前先不要管这个。随后，在链接阶段，大数组已经被load进来，与其他代码一同进行地址映射。最终这里的代码可以被执行。</p>
<p>查看<code>kern/init.c</code>文件，发现在所有初始化之后有这样的语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(TEST)</span></span><br><span class="line">    <span class="comment">// Don't touch -- used by grading script!</span></span><br><span class="line">    ENV_CREATE(TEST, ENV_TYPE_USER);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// Touch all you want.</span></span><br><span class="line">    ENV_CREATE(user_testbss, ENV_TYPE_USER);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这是告诉编译器：如果用户采用<code>make qemu</code>的方式运行，那么就创建一个user_testbss这样的用户进程，实际上就是执行testbss.c文件生成的那个binary。</p>
<p>在env完成之后对这里进行更深一步的讨论。</p>
<p>接下来需要写出下面几个函数的代码：</p>
<ol>
<li>env_init</li>
<li>env_setup_vm</li>
<li>region_alloc</li>
<li>load_icode</li>
<li>env_create</li>
<li>env_run</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mark all environments in 'envs' as free, set their env_ids to 0,</span></span><br><span class="line"><span class="comment">// and insert them into the env_free_list.</span></span><br><span class="line"><span class="comment">//把所有的envs设置成free的，他们的id都是0，然后插入freelist</span></span><br><span class="line"><span class="comment">// Make sure the environments are in the free list in the same order</span></span><br><span class="line"><span class="comment">// they are in the envs array (i.e., so that the first call to</span></span><br><span class="line"><span class="comment">// env_alloc() returns envs[0]).</span></span><br><span class="line"><span class="comment">//需要保证所有在freelist里面的env的顺序与在数组中的env相同？？？</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//本函数：初始化所有在env数组中的的env结构，把它们加到freelist里面，要求如上。</span></span><br><span class="line"><span class="comment">//在meminit之后执行。</span></span><br><span class="line"><span class="comment">//env数组：*envs，当前：*curenv，freelist：*env_free_list</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">env_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    struct Env*current=NULL;</span><br><span class="line">    <span class="keyword">int</span> i=NENV-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//一共NENV个env</span></span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//NENV is defined in inc/env.h</span></span><br><span class="line">    <span class="comment">//current-&gt;env_tf=3;</span></span><br><span class="line">    envs[i].env_id=<span class="number">0</span>;</span><br><span class="line">    envs[i].env_runs=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//  current-&gt;env_pgdir=NULL;</span></span><br><span class="line">    envs[i].env_link=env_free_list;</span><br><span class="line">    env_free_list=&amp;envs[i];</span><br><span class="line">    i--;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// Per-CPU part of the initialization</span></span><br><span class="line">    env_init_percpu();</span><br><span class="line">    cprintf(<span class="string">"envinit done!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数比较简单，需要注意的一点是要求倒着添加到链表里面。其他只是按照要求写的代码。</p>
<p>这个函数在最后执行了一个已经完成的函数：<code>env_init_percpu</code>，如下图：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/83957122.jpg" alt=""></p>
<p>该函数完成对各个段寄存器的设置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为进程e初始化内核虚拟空间</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">env_setup_vm(struct Env *e)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	struct PageInfo *p = NULL;</span><br><span class="line">	<span class="comment">// Allocate a page for the page directory</span></span><br><span class="line">	<span class="keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	<span class="comment">// Now, set e-&gt;env_pgdir and initialize the page directory.</span></span><br><span class="line">	<span class="comment">//初始化pagedir？</span></span><br><span class="line">	<span class="comment">// Hint:</span></span><br><span class="line">	<span class="comment">//    - The VA space of all envs is identical above UTOP</span></span><br><span class="line">	<span class="comment">//	(except at UVPT, which we've set below).</span></span><br><span class="line">	<span class="comment">//	See inc/memlayout.h for permissions and layout.</span></span><br><span class="line">	<span class="comment">//	Can you use kern_pgdir as a template?  Hint: Yes.</span></span><br><span class="line">	<span class="comment">//	(Make sure you got the permissions right in Lab 2.)</span></span><br><span class="line">	<span class="comment">//所有envs的虚拟地址空间都在UTOP之上</span></span><br><span class="line">	<span class="comment">//查看inc/memlayout.h看许可以及布局</span></span><br><span class="line">	<span class="comment">//可以使用kern_pgdir作为一个模板</span></span><br><span class="line">    <span class="comment">//    - The initial VA below UTOP is empty.</span></span><br><span class="line">	<span class="comment">//    - You do not need to make any more calls to page_alloc.</span></span><br><span class="line">	<span class="comment">//    - Note: In general, pp_ref is not maintained for</span></span><br><span class="line">	<span class="comment">//	physical pages mapped only above UTOP, but env_pgdir</span></span><br><span class="line">	<span class="comment">//	is an exception -- you need to increment env_pgdir's</span></span><br><span class="line">	<span class="comment">//	pp_ref for env_free to work correctly.</span></span><br><span class="line">	<span class="comment">//    - The functions in kern/pmap.h are handy.</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	e-&gt;env_pgdir=(pde_t*)page2kva(p);<span class="comment">//page2kva in pmap.c</span></span><br><span class="line">	p-&gt;pp_ref++;</span><br><span class="line">	memcpy(e-&gt;env_pgdir,kern_pgdir,PGSIZE);<span class="comment">//kernel's e is the kernel's e</span></span><br><span class="line">	<span class="comment">//permission:RR</span></span><br><span class="line">	<span class="comment">//p[PDX(UTOP)] = PADDR(p) | PTE_U | PTE_P;</span></span><br><span class="line">	<span class="comment">// UVPT maps the env's own page table read-only.</span></span><br><span class="line">	<span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">	e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为进程申请len字节的物理地址空间，然后把它map到va</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">region_alloc(struct Env *e, <span class="keyword">void</span> *va, size_t len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="comment">// (But only if you need it for load_icode.)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Hint: It is easier to use region_alloc if the caller can pass</span></span><br><span class="line">	<span class="comment">//   'va' and 'len' values that are not page-aligned.</span></span><br><span class="line">	<span class="comment">//如果允许传入不是页对齐的va（虚拟地址）和len（长度）的话会更好一些</span></span><br><span class="line">	<span class="comment">//   You should round va down, and round (va + len) up.</span></span><br><span class="line">	<span class="comment">//   (Watch out for corner-cases!)</span></span><br><span class="line">	<span class="comment">//什么叫corner-cases</span></span><br><span class="line">	<span class="comment">//获取首地址</span></span><br><span class="line">	<span class="comment">//只是申请了页面，其实没有真正的物理空间</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=(uint32_t)ROUNDDOWN(va,PGSIZE);i&lt;(uint32_t)ROUNDUP(va+len,PGSIZE);i+=PGSIZE)&#123;</span><br><span class="line">		struct PageInfo*pa=page_alloc(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(pa==NULL)panic(<span class="string">"fail to alloc !in region_alloc!"</span>);</span><br><span class="line">		page_insert(e-&gt;env_pgdir,pa,(<span class="keyword">void</span>*)i,PTE_U|PTE_W);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数指定进程申请从指定虚拟地址开始的len字节空间。由于vs与va+len可能不是页面对齐的，因此真正在分配页面的时候，需要做操作ROUNDOWN与ROUNDUP来进行页面的对齐。当申请页面失败时，panic，否则就将页面插入到当前进程的pgdir中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">load_icode(struct Env *e, uint8_t *binary)<span class="comment">//binary：ELF</span></span><br><span class="line">&#123;<span class="comment">//注意，对应的用户数据已经在内存中了</span></span><br><span class="line">	struct Elf*elf=(struct Elf*)binary;<span class="comment">//给定的ELF文件头结构（更详细的，查看inc/elf.h）</span></span><br><span class="line">	struct Proghdr *ph, *eph;<span class="comment">//ELF文件指定程序段的程序头</span></span><br><span class="line">		<span class="comment">// is this a valid ELF?</span></span><br><span class="line">	<span class="keyword">if</span> (elf-&gt;e_magic != ELF_MAGIC)</span><br><span class="line">		panic(<span class="string">"not a elf!"</span>);</span><br><span class="line">	ph = (struct Proghdr *) ((uint8_t *) elf + elf-&gt;e_phoff);<span class="comment">//第一个程序头开始</span></span><br><span class="line">	eph = ph + elf-&gt;e_phnum;<span class="comment">//最后一个不是程序头结构开始的位置</span></span><br><span class="line">	lcr3(PADDR(e-&gt;env_pgdir));<span class="comment">//将CR3中装载进去这次的页目录</span></span><br><span class="line">	<span class="keyword">for</span> (; ph &lt; eph; ph++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(ph-&gt;p_type==ELF_PROG_LOAD)&#123;</span><br><span class="line">		region_alloc(e,(<span class="keyword">void</span>*)ph-&gt;p_va,ph-&gt;p_memsz);</span><br><span class="line">        <span class="comment">//申请从ph-&gt;p_va程序假设自己所在的虚拟地址开始，到va+memsz结束的空间</span></span><br><span class="line">		memmove((<span class="keyword">void</span>*)ph-&gt;p_va,binary+ph-&gt;p_offset,ph-&gt;p_filesz);</span><br><span class="line">    <span class="comment">//  The ph-&gt;p_filesz bytes from the ELF binary, starting at</span></span><br><span class="line">	<span class="comment">//  'binary + ph-&gt;p_offset', should be copied to virtual address</span></span><br><span class="line">	<span class="comment">//  ph-&gt;p_va.  Any remaining memory bytes should be cleared to zero.</span></span><br><span class="line">	<span class="comment">//  (The ELF header should have ph-&gt;p_filesz &lt;= ph-&gt;p_memsz.)</span></span><br><span class="line">	<span class="comment">//  Use functions from the previous lab to allocate and map pages.</span></span><br><span class="line">	<span class="comment">//在ELF中的ph-&gt;p_filesz字节的，从binary+ph-&gt;p_offset都应该被copy到虚拟地址空间ph-&gt;p_va</span></span><br><span class="line">	<span class="comment">//任何剩余的空间被清零</span></span><br><span class="line">		memset((<span class="keyword">void</span>*)(ph-&gt;p_va+ph-&gt;p_filesz),<span class="number">0</span>,ph-&gt;p_memsz-ph-&gt;p_filesz);<span class="comment">//eme2file</span></span><br><span class="line">		<span class="comment">//memcpy((void*)ph-&gt;p_va,binary+ph-&gt;p_offset,ph-&gt;p_filesz);</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//after modification , everything is OK!</span></span><br><span class="line">	<span class="comment">// call the entry point from the ELF header</span></span><br><span class="line">	<span class="comment">// note: does not return!</span></span><br><span class="line">	<span class="comment">//((void (*)(void)) (ELFHDR-&gt;e_entry))();</span></span><br><span class="line">	e-&gt;env_tf.tf_eip=elf-&gt;e_entry;</span><br><span class="line">	<span class="comment">// Now map one page for the program's initial stack</span></span><br><span class="line">	<span class="comment">// at virtual address USTACKTOP - PGSIZE.</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	region_alloc(e,(<span class="keyword">void</span>*)(USTACKTOP-PGSIZE),PGSIZE);</span><br><span class="line">	lcr3(PADDR(kern_pgdir));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数负责把已经装入内存的binary文件重新装载到ELF文件头中指定的位置，并为用户进程创建一个栈。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_create(uint8_t *binary, <span class="keyword">enum</span> EnvType type)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	struct Env *newenv_store;</span><br><span class="line">	<span class="keyword">int</span> result=env_alloc(&amp;newenv_store,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(result&lt;<span class="number">0</span>)panic(<span class="string">"env_alloc: %e"</span>, result); ;</span><br><span class="line">	<span class="keyword">if</span>(result==<span class="number">0</span>)&#123;</span><br><span class="line">		newenv_store-&gt;env_type=type;</span><br><span class="line">		load_icode(newenv_store,binary);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用到了已经定义好的函数：<code>env_alloc</code>。<code>env_create</code>本身比较简单，我们来看一下<code>env_alloc</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">env_alloc(struct Env **newenv_store, envid_t parent_id)</span><br><span class="line">&#123;</span><br><span class="line">	int32_t generation;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	struct Env *e;</span><br><span class="line">	<span class="comment">//没有新的可以用了</span></span><br><span class="line">	<span class="keyword">if</span> (!(e = env_free_list))</span><br><span class="line">		<span class="keyword">return</span> -E_NO_FREE_ENV;</span><br><span class="line">	<span class="comment">// Allocate and set up the page directory for this environment.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = env_setup_vm(e)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	<span class="comment">// Generate an env_id for this environment.</span></span><br><span class="line">	generation = (e-&gt;env_id + (<span class="number">1</span> &lt;&lt; ENVGENSHIFT)) &amp; ~(NENV - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (generation &lt;= <span class="number">0</span>)	<span class="comment">// Don't create a negative env_id.</span></span><br><span class="line">		generation = <span class="number">1</span> &lt;&lt; ENVGENSHIFT;</span><br><span class="line">	e-&gt;env_id = generation | (e - envs);</span><br><span class="line">	<span class="comment">// Set the basic status variables.</span></span><br><span class="line">	e-&gt;env_parent_id = parent_id;</span><br><span class="line">	e-&gt;env_type = ENV_TYPE_USER;</span><br><span class="line">	e-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">	e-&gt;env_runs = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// Clear out all the saved register state,</span></span><br><span class="line">	<span class="comment">// to prevent the register values</span></span><br><span class="line">	<span class="comment">// of a prior environment inhabiting this Env structure</span></span><br><span class="line">	<span class="comment">// from "leaking" into our new environment.</span></span><br><span class="line">	memset(&amp;e-&gt;env_tf, <span class="number">0</span>, sizeof(e-&gt;env_tf));</span><br><span class="line">	<span class="comment">// Set up appropriate initial values for the segment registers.</span></span><br><span class="line">	<span class="comment">// GD_UD is the user data segment selector in the GDT, and</span></span><br><span class="line">	<span class="comment">// GD_UT is the user text segment selector (see inc/memlayout.h).</span></span><br><span class="line">	<span class="comment">// The low 2 bits of each segment register contains the</span></span><br><span class="line">	<span class="comment">// Requestor Privilege Level (RPL); 3 means user mode.  When</span></span><br><span class="line">	<span class="comment">// we switch privilege levels, the hardware does various</span></span><br><span class="line">	<span class="comment">// checks involving the RPL and the Descriptor Privilege Level</span></span><br><span class="line">	<span class="comment">// (DPL) stored in the descriptors themselves.</span></span><br><span class="line">	e-&gt;env_tf.tf_ds = GD_UD | <span class="number">3</span>;</span><br><span class="line">	e-&gt;env_tf.tf_es = GD_UD | <span class="number">3</span>;</span><br><span class="line">	e-&gt;env_tf.tf_ss = GD_UD | <span class="number">3</span>;</span><br><span class="line">	e-&gt;env_tf.tf_esp = USTACKTOP;</span><br><span class="line">	e-&gt;env_tf.tf_cs = GD_UT | <span class="number">3</span>;</span><br><span class="line">	<span class="comment">// You will set e-&gt;env_tf.tf_eip later.</span></span><br><span class="line">	<span class="comment">// commit the allocation</span></span><br><span class="line">	env_free_list = e-&gt;env_link;</span><br><span class="line">	*newenv_store = e;</span><br><span class="line">	cprintf(<span class="string">"[%08x] new env %08x\n"</span>, curenv ? curenv-&gt;env_id : <span class="number">0</span>, e-&gt;env_id);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数完成一系列的初始化操作，申请新进程，地址空间申请，一些属性的设置（这也是在env_init中不是做设置的原因），寄存器值的清理与设置等等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_run(struct Env *e)</span><br><span class="line">&#123;</span><br><span class="line">		<span class="keyword">if</span> (curenv != e) &#123;</span><br><span class="line">		<span class="comment">// if (curenv-&gt;env_status == ENV_RUNNING)</span></span><br><span class="line">		<span class="comment">// 	curenv-&gt;env_status = ENV_RUNNABLE;</span></span><br><span class="line">		curenv = e;</span><br><span class="line">		e-&gt;env_status = ENV_RUNNING;</span><br><span class="line">		e-&gt;env_runs++;</span><br><span class="line">		lcr3(PADDR(e-&gt;env_pgdir));<span class="comment">//将当前的地址空间设置为当前进程的地址空间</span></span><br><span class="line">	&#125;</span><br><span class="line">	env_pop_tf(&amp;e-&gt;env_tf);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//panic("env_run not yet implemented");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数只需要根据提示即可写出，看一下<code>env_pop_tf</code>的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_pop_tf(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">__asm <span class="title">__volatile</span><span class="params">(<span class="string">"movl %0,%%esp\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="string">"\tpopal\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="string">"\tpopl %%es\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="string">"\tpopl %%ds\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="string">"\taddl $0x8,%%esp\n"</span> <span class="comment">/* skip tf_trapno and tf_errcode */</span></span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="string">"\tiret"</span></span></span></span><br><span class="line"><span class="function"><span class="params">		: : <span class="string">"g"</span> (tf)</span> : "memory")</span>;</span><br><span class="line">	<span class="comment">//对应的汇编代码：</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	mov tf,eax</span></span><br><span class="line"><span class="comment">	movl eax,esp</span></span><br><span class="line"><span class="comment">	popal</span></span><br><span class="line"><span class="comment">	popl es</span></span><br><span class="line"><span class="comment">	popl ds</span></span><br><span class="line"><span class="comment">	addl $0x8,esp</span></span><br><span class="line"><span class="comment">	iret</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">//从这里开始，真正退出了内核态，进入用户态</span></span><br><span class="line">	panic(<span class="string">"iret failed"</span>);  <span class="comment">/* mostly to placate the compiler */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真正开始运行时，是需要trap伪装栈内容之后才能调用该函数，进入用户态的。trap的内容将在PartB讨论。届时还会需要用到该函数的内容。</p>
<p>按照文档的说明，使用<code>b env_pop_tf</code>打断点，查看内容，在经过若干次执行之后：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/74775132.jpg" alt=""></p>
<p>iret将进行退栈操作，此处暂未涉及。</p>
<p>这里写完之后，就可以梳理一下在进入用户态之前都发生了什么：(in kern/init.c)</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/30532.jpg" alt=""></p>
<p>首先，清理bss。这将保证所有未初始化的都是0，在testbss中将会有体现。然后初始化控制台，进行内存的初始化，进程初始化，trap的初始化。随后创建一个env，开始执行。</p>
<p>现在，我们可以讨论在上面提到过的<code>ENV_CREATE</code>。</p>
<p><code>ENV_CREATE</code>在<code>kern/env.c</code>中被定义：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/30871223.jpg" alt=""></p>
<p>首先可以看到本文件对那些骗boot loader装载进来的用户程序的外部定义，随后调用env_create函数，以<code>ENV_PASTE3(_binary_obj_, x, _start)</code>作为传入的ELF文件头结构，以type作为类型被创建。</p>
<p>随后，在create之后，执行load_icode，将对应内存的文件搬运到指定内存，并设置进程的入口点为函数的入口点，为用户进程初始化map一个页空间的栈，准备开始执行。</p>
<p>随后，调用了env_run函数，执行这个已经准备好的用户程序。但是在这个阶段，这个程序实际上还不能被真正执行。</p>
<h3 id="Handling-Interrupts-and-Exceptions"><a href="#Handling-Interrupts-and-Exceptions" class="headerlink" title="Handling Interrupts and Exceptions"></a>Handling Interrupts and Exceptions</h3><p>中断与异常都将会打断原有程序的执行，转而执行其他程序。他们的区别就在于，中断用于处理那些处理器外部的异步事件，而异常处理被处理器在执行指令时发现的错误情况。</p>
<p>中断会被INTR引起，异常会被INT引起。这也确定了breakpoint应该是一个异常而不是中断。</p>
<h3 id="Basics-of-Protected-Control-Transfer"><a href="#Basics-of-Protected-Control-Transfer" class="headerlink" title="Basics of Protected Control Transfer"></a>Basics of Protected Control Transfer</h3><p>中断和异常都可能完成这个转化，完成特权级的转化需要两个东西：<strong>IDT</strong>与<strong>TSS</strong>。</p>
<p><strong>IDT</strong>：IDT确保了用户程序切换到内核态的情况只有已经由kernel定义的几种，保证切换过程中的安全性。 x86允许256个不同的中断或异常，他们有着不一样的<strong>中断向量</strong>，CPU利用中断向量来确定这个中断的中断向量表，进而找到处理中断的入口，执行处理程序。<br>找到中断向量的描述符之后，EIP中装载的将会是中断处理程序的入口地址，CS中装载的是运行优先级。不一样的运行优先级设置带来不一样的结果，在接下来的实验中将会被讨论到。</p>
<p>一个IDT Gate是这样的：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/79807638.jpg" alt=""></p>
<p>segment selector与offset用来描述在段机制下自己的中断响应函数的位置。segment selector负责在GDT里面找到对应的段，offset负责找对应的偏移量。找到函数之后，保存现场并执行响应函数。</p>
<p><strong>TSS</strong>：处理器需要空间来存储旧的寄存器中的值，这样从中断或异常中返回的时候，用户程序才能够接着执行。因此，在从用户态切换到内核态的时候，需要换一个栈进行操作。这时就需要TSS来确定段寄存器来确定这个栈到底在哪里。<br>从用户态切换到内核态时，首先在栈中push一些寄存器值：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-14/87170051.jpg" alt=""></p>
<p>然后加载中断描述符中的值，然后把ESP和SS置为指向新栈的值。</p>
<p>尽管TSS可能会很复杂，但是在这个实验中只是用到了指向内核栈的部分。</p>
<p>在中断发生的时候，系统将会看一下产生中断的程序的特权级，决定应该怎样保护现场。如果在特权状态，不用换栈，只需要保存更少的东西，而处于用户状态下的程序在执行完中断响应函数之后还要从内核栈退回到自己的用户栈，保存了更多的东西。</p>
<p>iret：系统指令，从中断中返回。<br>ret：从函数中返回<br>retf：与ret基本一样，从函数中返回。（弹出栈，拿出返回地址（就是下一条语句）返回值，丢掉压栈参数）</p>
<h3 id="Types-of-Exceptions-and-Interrupts"><a href="#Types-of-Exceptions-and-Interrupts" class="headerlink" title="Types of Exceptions and Interrupts"></a>Types of Exceptions and Interrupts</h3><p>当一个进程在User Environment运行时，忽然遇到了一个中断：</p>
<ol>
<li>进程切换到被TSS定义的那个栈，在JOS中SS0是GD_KD（GDT中的kernel code），ESP0是KSTACKTOP。</li>
<li>进程把一些值push到这个kernel栈里面。</li>
<li>找到IDT entry，开始执行函数</li>
</ol>
<p>需要注意的是，就像上面已经讨论过的，有些中断/异常会push error code，而有的不会。</p>
<p>如果是在内核态发生了中断，就不需要进行换栈操作，这时旧的SS与ESP不会被保存。</p>
<p>怎么从内核态切换到用户态呢，其实方法是相似的。新开一个用户栈，存上中断以为的数据，随后iret，这样就降到了用户模式。</p>
<h3 id="Setting-Up-the-IDT"><a href="#Setting-Up-the-IDT" class="headerlink" title="Setting Up the IDT"></a>Setting Up the IDT</h3><p>现在来查看本实验中关于中断/trap的内容。</p>
<p>在<code>inc/trap.h</code>中定义了许多中断号，PushRegs结构以及TrapFrame结构。</p>
<p>TrapFrame结构中定义了trapnumer、es、ds等在值，这些值在特权级发生改变的时候会被压栈出栈保存，在后面还会用到。</p>
<p>为了完成Exercise4，首先分析trap.c以及trapentry.S中的代码：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/27936694.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/10236379.jpg" alt=""></p>
<p>这两个macro将会帮我们进行trapno的压栈操作，函数名的定义。第一个用于自动压栈errorcode的，后一个处理不自动压栈errorcode的。<br>找到每个中断类型的压栈方式：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/2785767.jpg" alt=""></p>
<p>这时应该明确，这时仍处于原来的特权级。</p>
<p>于是，使用上述两个macro来为trap添加一个入口点，这部分的代码：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/63275240.jpg" alt=""></p>
<p>然后考虑<code>/kern/trap.c</code>中的内容，在这之前，首先查看macro SETGATE的作用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in inc\mmu.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETGATE(gate, istrap, sel, off, dpl)			\</span></span><br><span class="line">&#123;								\</span><br><span class="line">	(gate).gd_off_15_0 = (<span class="keyword">uint32_t</span>) (off) &amp; <span class="number">0xffff</span>;		\</span><br><span class="line">	(gate).gd_sel = (sel);					\</span><br><span class="line">	(gate).gd_args = <span class="number">0</span>;					\</span><br><span class="line">	(gate).gd_rsv1 = <span class="number">0</span>;					\</span><br><span class="line">	(gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;	\</span><br><span class="line">	(gate).gd_s = <span class="number">0</span>;					\</span><br><span class="line">	(gate).gd_dpl = (dpl);					\</span><br><span class="line">	(gate).gd_p = <span class="number">1</span>;					\</span><br><span class="line">	(gate).gd_off_31_16 = (<span class="keyword">uint32_t</span>) (off) &gt;&gt; <span class="number">16</span>;		\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个macro帮我们设置了IDT的Gate。</p>
<p>于是，根据前面对TRAPHANDLER_NOEC与TRAPHANDLER的描述以及SETGATE，写trap_init如下：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/96169964.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/5194488.jpg" alt=""></p>
<p>接下来考虑_alltraps。根据提示，写出如下代码：</p>
<p>提示信息：</p>
<p>Your _alltraps should:<br>    1. push values to make the stack look like a struct Trapframe<br>    2. load GD_KD into %ds and %es<br>    3. pushl %esp to pass a pointer to the Trapframe as an argument to trap()<br>    4. call trap (can trap ever return?)<br>Consider using the pushal instruction; it fits nicely with the layout of the struct Trapframe. </p>
<p>代码：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/93817695.jpg" alt=""></p>
<p>进行makegrade检测：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/34710148.jpg" alt=""></p>
<p>Answer the following questions in your answers-lab3.txt: </p>
<pre><code>1. What is the purpose of having an individual handler function for each exception/interrupt? (i.e., if all exceptions/interrupts were delivered to the same handler, what feature that exists in the current implementation could not be provided?)

2. Did you have to do anything to make the user/softint program behave correctly? The grade script expects it to produce a general protection fault (trap 13), but softint&apos;s code says int $14. Why should this produce interrupt vector 13? What happens if the kernel actually allows softint&apos;s int $14 instruction to invoke the kernel&apos;s page fault handler (which is interrupt vector 14)?</code></pre><p>回答：</p>
<ol>
<li><p>如果所有的中断都是一个响应函数，那么首先需要统一是不是要自动压栈errorcode，其次在SETGATE时就无法指定特权级，就不能为内核中断提供不同的保护。比如syscall允许用户程序产生，但是诸如divideerror等只可以由硬件产生，如果所有都是用同一个优先级，很容易被别有用心的用户程序取得内核权限。</p>
</li>
<li><p>pagefault14不允许用户程序直接发起，必须经由硬件产生。这种机制可以更好地保护内存。假如允许用户程序自己产生int14，则每引发一个缺页中断系统就需要分配一个虚拟页，可能会被恶意程序利用，使得内存崩溃。而int13则是general protection interrupt，保护自己不去管那些不允许用户自己产生的中断。<br>如果希望int14可以正常被用户程序直接产生，应该将其特权级设置为3.</p>
</li>
</ol>
<h2 id="Page-Faults-Breakpoints-Exceptions-and-System-Calls"><a href="#Page-Faults-Breakpoints-Exceptions-and-System-Calls" class="headerlink" title="Page Faults, Breakpoints Exceptions, and System Calls"></a>Page Faults, Breakpoints Exceptions, and System Calls</h2><h3 id="Handling-Page-Faults"><a href="#Handling-Page-Faults" class="headerlink" title="Handling Page Faults"></a>Handling Page Faults</h3><p>page fault是14号中断。当处理器捕获到14号中断的时候，它会在CR2中存储一个引起pagefault的线性地址。下面来处理这个中断。</p>
<p>在上一步分析到，在把es与ds分别都设置为GD_KD之后，这时调用trap函数，我们先来分析trap函数。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/42158612.jpg" alt=""></p>
<p>FL_IF是在inc/mmu.h中定义的中断标志。如果寄存器eflage中中断标志没有被置位，则不是一个中断。</p>
<p>在tf结构tf_cs的低位存储着优先级，假如优先级是3，则是在用户态。这时是无权处理中断函数的，应该<strong>首先升级成为内核态</strong>，然后再处理。<br>然后调用trap_diapatch，来分发处理各种不同的trap，处理完毕回来之后，如果没有什么异常就可以接着运行。</p>
<p>在trap_dispatch中添加下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(tf-&gt;tf_trapno==T_PGFLT)&#123;</span><br><span class="line">        page_fault_handler(tf);<span class="comment">//此时该函数尚未完成</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时去查看page_fault_handle，此函数尚未完成，但是对于用户态的trap已经给出了解决，可以看到一句代码<code>fault_va = rcr2();</code>。这就是前面提到的在CR2中储存引起pagefault的线性地址，随后的打印操作即可以打印出这事的信息。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/48273990.jpg" alt=""></p>
<h3 id="The-Breakpoint-Exception"><a href="#The-Breakpoint-Exception" class="headerlink" title="The Breakpoint Exception"></a>The Breakpoint Exception</h3><p>其实，breakpoint也只是一个异常，函数入口点的相关代码在前面都已经写出来了。<br>需要说的是，在我最早使用breakpoint作为该函数的名字时，运行<code>make run-breakpoint</code>一直不成功。如果breakpoint还有其他用处，希望可以发现。目前暂时搁置这个问题。</p>
<p>这里需要做的只是补充trap_dipatch，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == T_BRKPT) &#123;</span><br><span class="line">    monitor(tf);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Questions<br>    1. The break point test case will either generate a break point exception or a general protection fault depending on how you initialized the break point entry in the IDT (i.e., your call to SETGATE from trap_init). Why? How do you need to set it up in order to get the breakpoint exception to work as specified above and what incorrect setup would cause it to trigger a general protection fault?</p>
<pre><code>2. What do you think is the point of these mechanisms, particularly in light of what the user/softint test program does?</code></pre><p>回答：</p>
<ol>
<li><p>这个问题的答案与上一个相似。当特权级设置为0的时候，只允许硬件产生中断而不会允许用户自己去调用。</p>
</li>
<li><p>更好的保护机制。</p>
</li>
</ol>
<p>makegrade信息将在最后一同贴出。</p>
<h3 id="System-calls"><a href="#System-calls" class="headerlink" title="System calls"></a>System calls</h3><p>在JOS中，系统调用定义的中断号是48号，系统调用不能由硬件产生，因此需要允许用户程序来生成系统调用。这也是在SETGATE中最后一个参数是3的原因。system call在初步判断时与trap处理相同，但是处理过程更加复杂。应用程序将会把系统调用的号码以及参数放在寄存器里面，这样内核将不需要在用户环境的堆栈或指令流中找数据。sysno将会在寄存器eax之中，其他参数将会在edx , ecx , ebx , edi , esi之中。返回时的返回值将会存在eax之中。</p>
<p>首先查看<code>lib/syscall.c</code>，syscall的代码以及对应的汇编代码如下：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/41487023.jpg" alt=""></p>
<p>补充<code>kern/syscall.c</code>以及<code>kern/trap.c</code>，代码如下：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/24297553.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/69032262.jpg" alt=""></p>
<p>这里需要提出的是，在<code>kern/syscall.c</code>中有另一个未完成的函数<code>sys_cput</code>，这个函数要求检查内存是否可以被访问，而在后面的练习中有相关函数的补充，在这里先不贴出代码。</p>
<h3 id="User-mode-startup"><a href="#User-mode-startup" class="headerlink" title="User-mode startup"></a>User-mode startup</h3><p>用户程序开始运行时是在<code>lib/entry.S</code>，随后在<code>lib/libmain.c</code>中call libmain()。<br>在<code>lib/entry.S</code>中可以看到：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/45324538.jpg" alt=""></p>
<p>envs已经被定义了，因此下面进入<code>lib/libmain.c</code>来初始化thisenv。根据提示，查看<code>inc/env.h</code>中的ENVX，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENVX(envid)     ((envid) &amp; (NENV - 1))</span></span><br></pre></td></tr></table></figure>

<p>为了得到当前的进程号，可以调用在<code>kern/syscall.c</code>中的<code>sys_getenvid</code>函数，该函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">envid_t</span></span><br><span class="line">sys_getenvid(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> curenv-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，根据<code>inc/env.h</code>，env_id并不是一个完全的envs中的序号，</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/22708337.jpg" alt=""></p>
<p>根据注释，ENVX(eid)才是真正在envs中的偏移，于是，在libmain中的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thisenv = envs+ENVX(sys_getenvid());</span><br></pre></td></tr></table></figure>

<p>其实，只有在这部分完成之后，才能正确的调用用户函数。这是因为在退出时需要访问thisenv-&gt;env_id，而先前这个变量并没有值。</p>
<p>在用户程序执行完成之后，就会调用<code>sys_env_destory</code>来退出自己。</p>
<h3 id="Page-faults-and-memory-protection"><a href="#Page-faults-and-memory-protection" class="headerlink" title="Page faults and memory protection"></a>Page faults and memory protection</h3><p>内存保护是操作系统的一个重要特性，确保一个程序中的错误不会破坏其他程序或破坏OS本身。OS通常依赖于硬件来保护自己，他知道哪块虚拟地址可用，哪块不可用，如果一个程序想要访问他没有权限访问的地址，会引发错误。如果这个错误可以被解决，OS会试图解决，如果不能解决，犯错的进程就不可以再运行了。</p>
<p>系统调用为内存保护提出了一个有趣的问题。大多数系统调用接口让用户程序将指针传递给内核。这些指针指向要读取或写入的用户缓冲区。内核然后在执行系统调用的时候去引用这些指针。这有两个问题：</p>
<p>1.内核中的页面错误可能比用户程序中的页面错误严重得多。如果内核页面在处理自己的数据结构的时候出错，这是一个内核错误，而且错误处理程序应该让内核（也就是整个系统）崩溃。但是当内核解引用用户程序给它的指针时，它需要一种方法来记住任何页面错误，这些解除引用实际上是代表用户程序。</p>
<p>2.内核通常拥有比用户程序更多的内存权限。用户程序可能会传递一个指向系统调用的指针，指向内核可以读或写的内存，但是程序不能。内核必须小心，不要被欺骗引用这样一个指针，因为这可能会泄露私有信息或破坏内核的完整性。</p>
<p>下面将处理对用户读写指针的访问权限处理，如果用户想要读写的地方表示允许，就允许，否则不允许。而内核，如果出现了page fault，立即崩溃。</p>
<p>在<code>kern/trap.c</code>中添加对内核发生了pagefault的处理，这也是上面提到的尚未完成的操作。<br>根据提示，由于tf_cs中的低位代表特权级，直接查看特权级：如果不是在用户态发生的，就直接panic。<br>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tf-&gt;tf_cs&amp;<span class="number">3</span>) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">"Kernel page fault!"</span>);</span><br></pre></td></tr></table></figure>

<p>接下来对<code>kern/pmap.c</code>中的<code>user_mem_check</code>以及<code>user_mem_assert</code>进行操作：</p>
<p>只需要按照说明检查内存中位置以及PTE_P和PTE_U等即可，直接贴出代码：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/79810310.jpg" alt=""></p>
<p>下面是<code>user_mem_assert</code>的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查进程env是不是允许访问这个区域</span></span><br><span class="line"><span class="comment">//如果可以就return</span></span><br><span class="line"><span class="comment">//不行的话env就死了，如果env是当前运行进程，就不返回了</span></span><br><span class="line"><span class="comment">//user_mem_check</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">user_mem_assert(struct Env *env, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (user_mem_check(env, va, len, perm | PTE_U) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		cprintf(<span class="string">"[%08x] user_mem_check assertion failure for "</span></span><br><span class="line">			<span class="string">"va %08x\n"</span>, env-&gt;env_id, user_mem_check_addr);</span><br><span class="line">		env_destroy(env);	<span class="comment">// may not return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，对在实验1中写过的debuginfo_eip进行更改，使得backtrace可以使用。<br>将代码贴出：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/326256.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/93317967.jpg" alt=""></p>
<p>本实验的基础部分到这里结束。</p>
<p>最终的makegrade：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/36947975.jpg" alt=""></p>
<p>CHALLENGE：</p>
<p>完成了单步执行的challenge。</p>
<p>根据提示，查找EFLAGS信息，得到这样的信息：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/4368506.jpg" alt=""></p>
<p>于是为了能够单步执行，z在monitor中修改如下部分：</p>
<ol>
<li>添加指令si</li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/34291928.jpg" alt=""></p>
<ol start="2">
<li>写函数mon_si并在.h中声明（声明略去）</li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/78360085.jpg" alt=""></p>
<ol start="3">
<li>修改kern/trap.c，使得能够处理debug的中断信息</li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/25025088.jpg" alt=""></p>
<p>运行：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/52901081.jpg" alt=""></p>
<p>类似的，就可以加上c指令使继续运行到下一个breakpoint。</p>
<ol>
<li><p>添加指令c </p>
</li>
<li><p>写函数mon_c</p>
</li>
</ol>
<p>只是，这时需要将TF位置为0。</p>
<p>结果：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/25564738.jpg" alt=""></p>
<p>为了更好地查看si与c的结果，我将breakpoint.c修改为下：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/1130654.jpg" alt=""></p>
<p>最后，再次运行make grade：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/12202433.jpg" alt=""></p>
<p>本实验完成。代码已经提交到git.mobisys.cc。</p>
<p><a href="https://note.youdao.com/share/?id=940fc869a8dc1daa06e9e955495a80c6&type=notebook#/EE533F3CCE0E4E579776693DB25883E1" target="_blank" rel="noopener">点击链接预览lab3工程代码~</a></p>
<p><a href="https://pan.baidu.com/s/1bppVmR9" target="_blank" rel="noopener">如果想要直接下载的话就点这个（这是百度的网盘）</a></p>
<p>yayi2456  &lt;(￣︶￣)↗[GO!]&gt;</p>
<p>最后，列出那些给过我帮助的网站！谢谢！（也便于我以后找到！</p>
<p><a href="https://github.com/Clann24/jos/" target="_blank" rel="noopener">一个学霸的自我修养 clann24</a></p>
<p>clann的实际代码与README代码不一样啊，而且明明clann的自己可以运行，加到我的代码上却不能运行了。<br>对clann的load_icode存疑。</p>
<p><a href="http://blog.csdn.net/woxiaohahaa/article/details/50550208" target="_blank" rel="noopener">朴实中透露着惊喜 mick_seu</a></p>
<p>可以说是很厉害了。代码简单易懂，正确率超高，超适用。</p>
<p><a href="https://www.kancloud.cn/wizardforcel/jos-lab/97520" target="_blank" rel="noopener">学习并快乐着 飞龙</a></p>
<p>飞龙的代码也很简单易懂！而且一看就是自己写的，与网上主流的都不一样。</p>
<p><a href="http://blog.163.com/tianhail@126/blog/static/140395915201021643354880/" target="_blank" rel="noopener">X86 CPU的EFLAGS寄存器各个标识位  伊凡</a></p>
<p><a href="https://stackoverflow.com/questions/1406783/how-to-read-and-write-x86-flags-registers-directly" target="_blank" rel="noopener">How to read and write x86 flags registers directly? stackoverflow</a></p>
<p>我需要BB一句。到了OS课的该是大三了。stackoverflow这个社区真的是强推，无数问题都是在这个社区找到的回答。嗯，强推。</p>
<p><a href="https://markdowntohtml.com/" target="_blank" rel="noopener">markdown to html md转html在线</a></p>
<p>emm其实效果一般…很不好….但是，毕竟在线，不想用的话，自己安装pandoc，费劲费空间。</p>
<p><a href="http://www.atool.org/html2markdown.php" target="_blank" rel="noopener">另外一个html与md</a></p>
<p><a href="http://www.oschina.net/question/100267_75314" target="_blank" rel="noopener">markdown的chrome插件</a></p>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/OS/" rel="tag"># OS</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2017/11/27/OS/%E4%B8%B2%E8%AE%B2%E5%A4%8D%E4%B9%A0/" rel="next" title="串讲复习">
                  <i class="fa fa-chevron-left"></i> 串讲复习
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2017/11/29/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91/" rel="prev" title="编译原理——语法分析">
                  编译原理——语法分析 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Lab3-Document"><span class="nav-number">1.</span> <span class="nav-text">Lab3 Document</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-A：User-Enviornments-and-Exception-Handling"><span class="nav-number">1.1.</span> <span class="nav-text">Part A：User Enviornments and Exception Handling</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Allocating-the-Environments-Array"><span class="nav-number">1.1.1.</span> <span class="nav-text">Allocating the Environments Array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Creating-and-Running-Environments"><span class="nav-number">1.1.2.</span> <span class="nav-text">Creating and Running Environments</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Handling-Interrupts-and-Exceptions"><span class="nav-number">1.1.3.</span> <span class="nav-text">Handling Interrupts and Exceptions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Basics-of-Protected-Control-Transfer"><span class="nav-number">1.1.4.</span> <span class="nav-text">Basics of Protected Control Transfer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Types-of-Exceptions-and-Interrupts"><span class="nav-number">1.1.5.</span> <span class="nav-text">Types of Exceptions and Interrupts</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Setting-Up-the-IDT"><span class="nav-number">1.1.6.</span> <span class="nav-text">Setting Up the IDT</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Page-Faults-Breakpoints-Exceptions-and-System-Calls"><span class="nav-number">1.2.</span> <span class="nav-text">Page Faults, Breakpoints Exceptions, and System Calls</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Handling-Page-Faults"><span class="nav-number">1.2.1.</span> <span class="nav-text">Handling Page Faults</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Breakpoint-Exception"><span class="nav-number">1.2.2.</span> <span class="nav-text">The Breakpoint Exception</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#System-calls"><span class="nav-number">1.2.3.</span> <span class="nav-text">System calls</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#User-mode-startup"><span class="nav-number">1.2.4.</span> <span class="nav-text">User-mode startup</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Page-faults-and-memory-protection"><span class="nav-number">1.2.5.</span> <span class="nav-text">Page faults and memory protection</span></a></li></ol></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/avatar.gif"
      alt="傻瓜日和">
  <p class="site-author-name" itemprop="name">傻瓜日和</p>
  <div class="site-description" itemprop="description">来如春梦不多时 去似朝云无觅处</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/yayi2456" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;yayi2456" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:yangying2456@gmail.com" title="E-Mail &amp;rarr; mailto:yangying2456@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">傻瓜日和</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.2
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.2"></script><script src="/js/motion.js?v=7.4.2"></script>
<script src="/js/schemes/pisces.js?v=7.4.2"></script>

<script src="/js/next-boot.js?v=7.4.2"></script>



  








  <script src="/js/local-search.js?v=7.4.2"></script>










<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'forest',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>




  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":"hijiki","bottom":-30,"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
