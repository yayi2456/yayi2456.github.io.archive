<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">

<script>
    (function(){
        if('yayi'){
            if (prompt('请输入文章密码') !== 'yayi'){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>


  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">




  
  
  <link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3">




<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Linux,OS," />





  <link rel="alternate" href="/atom.xml" title="日和" type="application/atom+xml" />






<meta name="description" content="考试周期间写的。不会很完善。">
<meta name="keywords" content="Linux,OS">
<meta property="og:type" content="article">
<meta property="og:title" content="chap2-进程与线程">
<meta property="og:url" content="http://yoursite.com/2017/11/06/OS/chap2-进程与线程/index.html">
<meta property="og:site_name" content="日和">
<meta property="og:description" content="考试周期间写的。不会很完善。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://oysmkdi7t.bkt.clouddn.com/18-1-14/82449429.jpg">
<meta property="og:image" content="http://oysmkdi7t.bkt.clouddn.com/18-1-14/87376882.jpg">
<meta property="og:image" content="http://oysmkdi7t.bkt.clouddn.com/18-1-14/11990991.jpg">
<meta property="og:image" content="http://oysmkdi7t.bkt.clouddn.com/18-1-14/55177783.jpg">
<meta property="og:image" content="http://oysmkdi7t.bkt.clouddn.com/18-1-14/88783439.jpg">
<meta property="og:image" content="http://oysmkdi7t.bkt.clouddn.com/18-1-14/92773297.jpg">
<meta property="og:image" content="http://oysmkdi7t.bkt.clouddn.com/18-1-14/64758197.jpg">
<meta property="og:image" content="http://oysmkdi7t.bkt.clouddn.com/18-1-14/62249836.jpg">
<meta property="og:image" content="http://oysmkdi7t.bkt.clouddn.com/18-1-14/65249341.jpg">
<meta property="og:image" content="http://oysmkdi7t.bkt.clouddn.com/18-1-15/81651596.jpg">
<meta property="og:image" content="http://oysmkdi7t.bkt.clouddn.com/18-1-15/74457502.jpg">
<meta property="og:image" content="http://oysmkdi7t.bkt.clouddn.com/18-1-15/40601574.jpg">
<meta property="og:image" content="http://oysmkdi7t.bkt.clouddn.com/18-1-15/46110689.jpg">
<meta property="og:image" content="http://oysmkdi7t.bkt.clouddn.com/18-1-15/26479287.jpg">
<meta property="og:image" content="http://oysmkdi7t.bkt.clouddn.com/18-1-15/51773333.jpg">
<meta property="og:image" content="http://oysmkdi7t.bkt.clouddn.com/18-1-15/87331439.jpg">
<meta property="og:image" content="http://oysmkdi7t.bkt.clouddn.com/18-1-15/47608393.jpg">
<meta property="og:image" content="http://oysmkdi7t.bkt.clouddn.com/18-1-15/64321100.jpg">
<meta property="og:image" content="http://oysmkdi7t.bkt.clouddn.com/18-1-15/88550095.jpg">
<meta property="og:image" content="http://oysmkdi7t.bkt.clouddn.com/18-1-15/67570267.jpg">
<meta property="og:image" content="http://oysmkdi7t.bkt.clouddn.com/18-1-15/30861938.jpg">
<meta property="og:image" content="http://oysmkdi7t.bkt.clouddn.com/18-1-15/30861938.jpg">
<meta property="og:image" content="http://oysmkdi7t.bkt.clouddn.com/18-1-15/8720151.jpg">
<meta property="og:image" content="http://oysmkdi7t.bkt.clouddn.com/18-1-15/11688740.jpg">
<meta property="og:image" content="http://oysmkdi7t.bkt.clouddn.com/18-1-15/97276693.jpg">
<meta property="og:image" content="http://oysmkdi7t.bkt.clouddn.com/18-1-15/49329583.jpg">
<meta property="og:image" content="http://oysmkdi7t.bkt.clouddn.com/18-1-15/21915703.jpg">
<meta property="og:image" content="http://oysmkdi7t.bkt.clouddn.com/18-1-15/51508560.jpg">
<meta property="og:updated_time" content="2018-07-20T18:07:05.893Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="chap2-进程与线程">
<meta name="twitter:description" content="考试周期间写的。不会很完善。">
<meta name="twitter:image" content="http://oysmkdi7t.bkt.clouddn.com/18-1-14/82449429.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '61a4cd7c1bed364065c7fe56474ba5df',
      indexName: 'yayiblogsearch',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/11/06/OS/chap2-进程与线程/"/>





  <title>chap2-进程与线程 | 日和</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8214766f6334490a524e10cda5fd72cf";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">日和</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">BE WITH ME</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            日程表
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
			
			<!--增加的代码 start-->

          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/06/OS/chap2-进程与线程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="傻瓜日和">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日和">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">chap2-进程与线程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-06T14:13:37+08:00">
                2017-11-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/课/" itemprop="url" rel="index">
                    <span itemprop="name">课</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

<span>&nbsp; | &nbsp;
<span id="busuanzi_value_page_pv" ></span>次阅读
</span>    

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        <p>考试周期间写的。不会很完善。</p>
<a id="more"></a>
<h1 id="导"><a href="#导" class="headerlink" title="导"></a>导</h1><p>进程模型的进化：</p>
<ol>
<li>第一代：relay , vacuum tubes and plugboards。没有程序与进程的概念</li>
<li>第二代：批处理系统：一个程序完成所有工作。</li>
<li>带三代：mutiprogramming and timesharing。CPU可以切换运行。</li>
<li>第四代：现代OS：进程模型更加成熟，进程调度与相互交流更加成熟，内存保护与管理更加成熟。</li>
</ol>
<p><strong>进程</strong>：计算机上所有可以运行的软件，通常也包括操作系统，被组织成若干顺序进程，简称进程。它包括输入输出程序与状态。</p>
<p>需要区分进程与程序。</p>
<p>进程创建：系统初始化、运行进程的创建进程系统调用被执行、用户请求、批处理作业初始化。</p>
<p>进程终止：正常退出、出错退出（自愿）、严重错误、被杀死（非自愿）</p>
<p>在unix中，每个进程有自己的父进程，有着明显的层次结构，但是在Windows中，虽然也有“句柄”来标识父进程，拥有句柄即可控制及对应的子进程，但是这个“句柄”可以被转让，就不存在明显的层次关系了。</p>
<h2 id="为什么要并发（Cocurrency）？"><a href="#为什么要并发（Cocurrency）？" class="headerlink" title="为什么要并发（Cocurrency）？"></a>为什么要并发（Cocurrency）？</h2><p><strong>whats os?</strong><br>    A special kind of system software that can manage computer in  efficient and reasonable way. It is in charge of managing hardware resource, controlling the running of programs and providing useful services. It is a convenient platform for people to use computer</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h2><ol>
<li>使用cpu的基本数据结构<ol>
<li>逻辑程序：被用户设计实现（envs）</li>
<li>cpu指令序列：</li>
<li>进程：程序与指令之间的数据结构</li>
</ol>
</li>
</ol>
<p><strong>进程</strong>：进程是某一个特定程序的运行实例，包括输入输出程序与状态。在分时操作系统（time-sharing os）中，CPU被多个进程分享，复杂的算法将被用于进程之间的调度。</p>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p>基本状态：</p>
<ol>
<li>running：真正占用CPU</li>
<li>ready：可以运行，等待CPU的使用权</li>
<li>blocked：不能继续运行，等待外部事件（输入输出等）</li>
</ol>
<p>其他状态：</p>
<ol>
<li>new：进程的数据结构已经准备好，但是程序镜像尚未完成装载（env_create到icode_load之前，此时还不可以调用env_run）</li>
<li>exit：程序已经完成了所有工作，但是还没有回收进程的数据结构（exit gracefully之后，free之前）</li>
<li>suspend：运行镜像已经被换到硬盘里面了</li>
</ol>
<blockquote>
<p>为什么block不能直接过渡到running：你都阻塞了，想回来啊？等吧。<br>为什么ready不能直接block？你都没有运行，怎么直到自己要等待一个外部事件去block？</p>
</blockquote>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-14/82449429.jpg" alt=""></p>
<p>那么为什么会<strong>挂起</strong>呢？</p>
<p>挂起是由于：1.等待时间过长 2. 物理地址空间不足。导致该进程所需运行资源被切换到外存。</p>
<p>页面置换是一件很麻烦的事情，需要进行一系列的硬盘操作，硬盘是一个极其慢的设备，那么为什么还要有挂起状态？（废话如果内存也能有120G那么多空间谁会给他换到硬盘啊）</p>
<ol>
<li>提高处理机效率：就绪进程表示空的时候，提交新进程，以提高处理机效率（<em>哈？</em>）</li>
<li>为运行进程提供足够多的内存</li>
<li>便于调试：在调试时，挂起被调试进程对其地址空间进行读写。</li>
</ol>
<p>什么时候会挂起呢？在进程等待外部事件（阻塞）的时候，有可能被挂起。</p>
<p>除此之外的双挂起模型：<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-14/87376882.jpg" alt=""></p>
<p><strong>等待-&gt;等待挂起</strong>：没有进程处于就绪状态或者是就绪进程需要更多的内存资源。(???)<br><strong>就绪-&gt;就绪挂起</strong>：有高优先级的等待进程和低优先级的就绪进程（这是就绪进程被换到外存）<br><strong>运行-&gt;就绪挂起</strong>：对于抢先式分时系统，有高优先级的等待挂起进程因事件出现而进入就绪挂起。<br><strong>等待挂起-&gt;就绪挂起</strong>：等待的事件到了<br><strong>就绪挂起-&gt;就绪</strong>：没有就绪进程或者是就绪挂起进程的优先级比所有就绪进程的优先级都高<br><strong>等待挂起-&gt;等待</strong>：有一个进程释放了内存，一个等待挂起进程的优先级很高</p>
<p>值得一提的是，winxp用的就是上面的双挂起模型。</p>
<p><a href="http://blog.csdn.net/freeelinux/article/details/53562592" target="_blank" rel="external">对挂起的详细分析</a></p>
<blockquote>
<p>为什么要双挂起呢，os真的那么缺内存吗？<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-14/11990991.jpg" alt=""><br><a href="https://github.com/GcsSloop/Note/tree/master/OperatingSystem" target="_blank" rel="external">from:gcssloop/note</a></p>
</blockquote>
<p>linux下使用的进程模型是：</p>
<ol>
<li>TASK_RUNNING</li>
<li>TASK_INTERRUPTIBLE：进程被挂起，直到某些条件变成真。（产生一个中断，在中断中释放一些该进程等待的系统资源，传递唤醒该进程的信号）<br>$$\color{red}{shenme玩意}$$</li>
<li>TASK_UNINTERRUPTIBLE：除了信号不能使它的状态发生变化之外与前一个相同</li>
<li>TASK_STOPED</li>
<li>TASK_TRACED：进程运行被debugger打断</li>
<li>EXIT_ZOMBIE：程序运行已经结束了，但是他的父进程还没有调用一个wait4()或是waitpid()系统调用来返回死掉进程的信息。</li>
<li>EXIT_DEAD</li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-14/55177783.jpg" alt=""></p>
<p>$$\color{red}{so why… kill之后为什么不死}$$</p>
<p>不同的os，其状态设置的差异很大。</p>
<h2 id="进程数据结构"><a href="#进程数据结构" class="headerlink" title="进程数据结构"></a>进程数据结构</h2><p><strong>PCB：进程控制块</strong>：<br>这就是在jos里面的envs那个大数组了，它由操作系统内核维护，也叫进程描述符。（经过了jos的洗礼，其实不用说太多）</p>
<p>所有pcb都在一个特定的内存空间之中。pcb表的size决定了os的并发度。不同状态的进程数据被存在不同的pcb表中。</p>
<p>在一个正经系统中的pcb比env中的项更多，列为：<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-14/88783439.jpg" alt=""></p>
<p>为了将不同运行状态的pcb区分开，可以有两种方法，一种是：<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-14/92773297.jpg" alt=""><br>另一种是：<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-14/64758197.jpg" alt=""></p>
<p>其中第一种是在jos中使用的方式。</p>
<h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><p>进程切换就是我们的sched函数了。<br>切换之前，需要保存在cpu运行程序的山下文（tf内容、pgdir等），切换之后，把新上来的进程的上下文恢复。</p>


<iframe height="363" width="565" src="http://oysmkdi7t.bkt.clouddn.com/%E5%AA%92%E4%BD%932.mp4" frameborder="0" allowfullscreen>
</iframe>


<p>比如说sleep的实现：一个进程运行到了sleep，os去处理这个sleep，此时cpu的掌管权在kernel手里，随后设置一个硬件的时钟中断，然后保护现场，最后os就schedule，把运行权交给了另一个进程，另一个进程运行了一段时间之后硬件的时钟中断raise，打断了另一个进程的运行，于是os处理这个时钟中断保护现场，剥夺了另一个进程的运行权，再一次schedule，进程1开始运行。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-14/62249836.jpg" alt=""></p>
<h2 id="运行镜像（process-image）"><a href="#运行镜像（process-image）" class="headerlink" title="运行镜像（process image）"></a>运行镜像（process image）</h2><p>运行镜像就是☞进程的整个生存周期的描述。</p>
<p><strong>process image的内容</strong>：</p>
<ol>
<li>用户层面：该进程的用户地址空间，比如说程序、堆栈、数据段</li>
<li>寄存器层面：pc、pcw、ir，栈指针其他寄存器</li>
<li>系统层面：pcb等、动态内核指针</li>
</ol>
<p>（emm个人觉得，其实就是pcb里面保存的那些东西，以及那些指针指向的那些空间）</p>
<h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><p>p82</p>
<p>简述：</p>
<p><strong>Q</strong>：什么时候调度？<br>    进程被创建、进程退出<br>    进程阻塞<br>    出现io中断</p>
<p><strong>Q</strong>：为什么要调度？<br>    做更好的选择：优先级、运行时长<br>    保证CPU的效率</p>
<p><strong>Q</strong>：怎么做调度？<br>    使用特定的方式选择一个进程占用CPU<br>    在切换的时候切换上下文</p>
<p><strong>A</strong>：注意：</p>
<ol>
<li>调度的频率是非常重要的</li>
<li>有抢占式调度与非抢占式调度</li>
<li>CPU-bound（计算密集型）与i/o-bound（io密集型）进程</li>
</ol>
<p>CPU资源的时分复用 ：</p>
<ol>
<li>进程切换：CPU资源占用者切换</li>
<li>处理机调度：从就绪队列中挑选进程、从CPU中挑选可使用的CPU</li>
<li>调度程序：调度策略、调度时机</li>
</ol>
<h3 id="when-and-why"><a href="#when-and-why" class="headerlink" title="when and why"></a>when and why</h3><p>上述的调度时间是一个笼统的说法：</p>
<ol>
<li>内核运行调度程序的条件<br> 进程退出<br> 进程从运行态切换到等待</li>
<li>非抢占系统中<br> 当前进程主动放弃CPU</li>
<li>可抢占系统<br> 当前进程时间片用完<br> 中断请求被服务例程响应完成时</li>
</ol>
<p>其实在写完jos的sched函数之后，对何时调度应该有一个认识：无论是何时调度，都是os编写人员决定的（或是用户程序主动放弃）。os为了避免用户程序不自觉，提供了时间中断（timer interrupt），在每一个时间终端的处理中指定schedule。<br>再比如上面提到的io中断，这部分也是os决定的sched，因为trap(jos)是属于kernel部分。</p>
<p>调度的目标：不同的系统中目标是不同的</p>
<ol>
<li><p>在所有系统中：</p>
<ol>
<li>公平性：给每一个进程一个公平使用CPU的机会</li>
<li>策略强制执行:seeing thatstated policy is carried out</li>
<li>平衡：保持整个系统都是有事可干</li>
</ol>
</li>
<li><p>批处理系统：</p>
<ol>
<li>吞吐量：使单位时间的工作量达到最大</li>
<li>周转时间（turnaround time）：在任务提交与任务完成之间时间尽可能小</li>
<li>CPU利用率：让CPU一直有事可干</li>
</ol>
</li>
<li><p>交互系统：</p>
<ol>
<li>响应时间</li>
<li>Proportionality：达到用户期望值</li>
</ol>
</li>
<li><p>实时系统：</p>
<ol>
<li>meet deadline：别丢数据</li>
<li>可预测：在多媒体系统中别有质量上的降低</li>
</ol>
</li>
</ol>
<h3 id="goal"><a href="#goal" class="headerlink" title="goal"></a>goal</h3><p>那么给定一个调度算法，怎么比较他们之间的优劣呢？</p>
<ol>
<li>CPU使用率</li>
<li>吞吐量：单位时间内完成进程的数量</li>
<li>周转时间：进程从初始化到结束绝对时间</li>
<li>等待时间：进程在<strong>就绪</strong>中的时间（不算等待状态的时间，因为这个时间其实是必须花费的）</li>
<li>响应时间：从提交请求到请求响应时间</li>
</ol>
<p><strong>吞吐量与响应时间之间的区别</strong></p>
<p>吞吐量是什么呢？其实就是希望通过合理的调度使规定时间内完成更多的进程，比如说文件传输的时候希望<strong>高带宽</strong>（10M/s与10k/s你想要哪个？）。<br>响应时间是什么呢？就是希望进程对某一个动作尽可能快的作出反应，比如点击按钮搜索之后多久才响应。</p>
<p>吞吐量与响应时间其实是很不同的两个概念，两者我认为在某种情况下是此消彼长的。吞吐量描述的是整体，响应时间描述的特定。</p>
<p><strong>响应时间目标</strong>：</p>
<ol>
<li>减少响应时间 </li>
<li>减少平均响应时间的波动<br>在交互是系统中，减少平均响应时间波动其实更加重要。</li>
</ol>
<p>响应时间是os的计算延时。</p>
<p><strong>吞吐量目标</strong>：</p>
<ol>
<li>增加吞吐量：减少os开销（减少上下文切换）、系统资源的高效利用（CPU、io）</li>
<li>减少等待时间：减少每个进程在就绪呆的时间<br>os需要保证吞吐量的提高不会影响交互体验（os必须不时地进行调度，即使存在许多交互式任务）</li>
</ol>
<p>吞吐量是os的计算带宽</p>
<h3 id="批处理系统中的调度算法"><a href="#批处理系统中的调度算法" class="headerlink" title="批处理系统中的调度算法"></a>批处理系统中的调度算法</h3><p>吞吐量、周转时间、CPU利用率</p>
<ol>
<li>先来先服务：非抢占式<br> 笨蛋算法、简单，某些情况下也合理、io密集型系统中对CPU利用率低到令人发指</li>
<li>最短任务优先：非抢占式<br> 周转时间短、在现实的os中并不会是最优的</li>
<li>最短剩余时间优先：抢占式<br> 将新任务的时间与当前任务的剩余运行时间做对比，如果新任务时间短就让新任务占据CPU、不现实啊</li>
<li>三层调度<br> admission scheduler<br> memory scheduler<br> CPU scheduler</li>
</ol>
<h4 id="先来先服务（FCFS）"><a href="#先来先服务（FCFS）" class="headerlink" title="先来先服务（FCFS）"></a>先来先服务（FCFS）</h4><p>就是先来先运行，也没有抢占，运行到结束就行了。</p>
<p>优点是非常简单，但是缺点更加明显。</p>
<ol>
<li>平均等待时间波动很大，短进程可能会在长进程后面</li>
<li>资源利用率低（一直运行一个你说利用率能高吗），CPU密集型导致io闲置，io密集型导致CPU闲置。</li>
</ol>
<blockquote>
<p>说到这里就想起来一个题外话。上编译课的时候编译老师说他上学那会儿用的编译器是非常老的编译器，性能也不好。一般都是晚上离开实验室的时候把写的东西运行上，第二天回来实验室的时候能出结果都已经很不错了。<br>os课的时候老师说，假如你买了一个服务要去运行自己的程序，本来你就是一个hello world，前面那个人的程序可能特别庞大需要一天来运行，你倒霉催的正好排在那人后面，你可能几秒就完事了，但是那个服务器好巧不巧用的FCFS，那你可就等吧。</p>
</blockquote>
<h4 id="最短时间优先算法（SPN）"><a href="#最短时间优先算法（SPN）" class="headerlink" title="最短时间优先算法（SPN）"></a>最短时间优先算法（SPN）</h4><p>每次选择就绪队列中的运行时间最短的进程来执行，就绪队列按照预期的执行时间来排序。</p>
<p>非常容易就可以想到的是，SPN必定具有<strong>最短平均周转时间</strong>。（如果学过贪心算法，应该很清楚这一点）（吞吐量可不会，SPN是非抢占，只能串行运行的）</p>
<p>缺点也非常明显，你一直运行hello world，人家正儿八经的要运行一天的大程序什么时候才能开始运行啊？<br>可能会导致<strong>饥饿</strong>。</p>
<p>还有一个需要解决的问题是<strong>如何预测程序运行</strong>，不太可能准确预测一个程序需要的执行时间，尤其是当ifelse while等语句十分的情况下，这种运行时间一般都需要在运行时才能确定。<br>不能预测这个算法还有什么好实现的？<br>还有一种方法是问用户，你不能保证用户都是诚实的，但是你可以最多分配用户指定的时间，超出时间就杀死。但是这种方法真的太不友好太不专业了，程序运行中的状况很多，用户也不一定知道运行时间。</p>
<p>所以这种方法其实是不太可行的。</p>
<h4 id="最短剩余时间优先算法（SRT）"><a href="#最短剩余时间优先算法（SRT）" class="headerlink" title="最短剩余时间优先算法（SRT）"></a>最短剩余时间优先算法（SRT）</h4><p>是SPN的可抢占改进版，允许当新进程进入时新进程如果运行时间很短可以代替老进程运行。</p>
<p>其实这才改是真正的最短平均周转时间。（即使是可抢占，也与吞吐量高无缘，又不会在等待的时候调度）。</p>
<p>缺点也差不多与SPN差不多。</p>
<h4 id="最高响应比优先算法（HRRN）"><a href="#最高响应比优先算法（HRRN）" class="headerlink" title="最高响应比优先算法（HRRN）"></a>最高响应比优先算法（HRRN）</h4><p>选择就绪队列中响应比R值最高的进程。不支持抢占。</p>
<p><strong>响应比</strong>：R=(等待时间+执行时间)/执行时间</p>
<p>那也就是等待的时间越长越容易被选中。是在短进程优先算法基础之上的改进，防止无止境地等待。</p>
<h4 id="三层调度"><a href="#三层调度" class="headerlink" title="三层调度"></a>三层调度</h4><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-14/65249341.jpg" alt=""></p>
<h3 id="交互式系统中的调度"><a href="#交互式系统中的调度" class="headerlink" title="交互式系统中的调度"></a>交互式系统中的调度</h3><ol>
<li>时间片轮转：抢占式<br> 时间片耗尽时触发调度、进程等待（阻塞）时触发调度</li>
<li>多级队列：<br> 有多种优先级class，美哟中class存在同一个队列、根据优先级选择进程、高优先级低时间片保证公平</li>
<li>优先级调度：抢占式<br> 每个进程有自己的优先级、CPU选择最高优先级、动态优先级来避免饥饿</li>
</ol>
<p><strong>处理机资源的使用模式</strong>：</p>
<p>进程在CPU计算与io之间进行交替：每次调度决定在下一个CPU计算时将那个工作交给CPU，在时间片机制下，进程可能在结束当前CPU计算之前放弃CPU。</p>
<h4 id="时间片轮转-（RR）"><a href="#时间片轮转-（RR）" class="headerlink" title="时间片轮转 （RR）"></a>时间片轮转 （RR）</h4><p>每当时间片结束，就会引发一个调度，每当进程自己要等待，引发一个调度。每当下去，自觉排在队尾。</p>
<p>时间片轮转的问题是：</p>
<ol>
<li>额外的上下文切换开销</li>
<li>时间片选择问题</li>
</ol>
<p>其实归根结底是时间片选择问题，额外的上下文切换是一定必须的。<br>如果时间片选择太大，就失去了调度的灵活性，等待时间变长，这在交互式系统中可能是不可忍受的。甚至在极限情况下，就退化成了上述的FCFS。<br>如果时间片选择太短，将会浪费大量的时间在上下文切换。比如在linux，上下文切换一次可能需要1ms，如果4ms是时间片长度，那么整个系统中有20%的时间都在做上下文切换。这是没有意义的浪费。<br>经验上，一般将浪费控制在1%，实践篇一般设置在20-50ms。<br>当n（就绪队列长度）比较大的时候，可以把某一些就绪状态的进程给传到就绪挂起。</p>
<h4 id="多级队列调度算法（MQ）"><a href="#多级队列调度算法（MQ）" class="headerlink" title="多级队列调度算法（MQ）"></a>多级队列调度算法（MQ）</h4><p>就绪队列被划分为多个独立的子队列（终端、io、前台交互、后台批处理）<br>每个队列可以有自己的调度策略（前台RR，后台FCFS等）<br>队列之间的调度：</p>
<ol>
<li>固定优先级：可能导致饥饿</li>
<li>时间片轮转：每个队列得到一个确定的能偶用于调度其进程的CPU总时间（比如前台80%后台20%）</li>
</ol>
<h4 id="多级反馈队列算法（MLFQ）"><a href="#多级反馈队列算法（MLFQ）" class="headerlink" title="多级反馈队列算法（MLFQ）"></a>多级反馈队列算法（MLFQ）</h4><p>进程可以在不同队列之间移动的多队列算法。时间片大小可以随着优先级级别增加而减小，如果进程在当前的时间片没有完成，降到下一个优先级。</p>
<p>其特点是：CPU密集型的进程优先级下降很快，而io密集型进程停留在高优先级。</p>
<h4 id="优先级算法（PS）"><a href="#优先级算法（PS）" class="headerlink" title="优先级算法（PS）"></a>优先级算法（PS）</h4><p>是多级队列算法的改进，平衡各进程对响应时间的要求。<br>分为抢占式与非抢占式。<br>通常可以控制其时间片长度。<br>如果io完成，提高优先级，如果时间片用完，将低优先级。</p>
<p><strong>静态优先级</strong>：<br>在创建进程的时候，他的优先级就被确定，直到进程终止之前都不会改变。<br>（系统进程优先级高、io密集型优先级高）</p>
<p><strong>动态优先级</strong>：<br>优先级在创建的时候被赋予，但是在进程运行的过程中可以被改变：</p>
<ol>
<li>在就绪队列中，等待时间延长优先级高。</li>
<li>进程每执行一个时间片就降低这个进程的优先级。</li>
</ol>
<p>对于不同类型的进程：<br><strong>io密集型进程</strong>：他是最高级优先。<br>为什么io密集的优先级比较高呢？这是因为io密集型一般只会占用一小会儿CPU，随后就会等待io外部操作去了。最好的做法是，io一旦就绪就赶紧用一下CPU，然后就可以去等io事件了。如果io密集型进程的优先级比较低，将会浪费很多时间在就绪的等待上。<br>CPU密集型时常需要CPU资源，由于优先级低，可以使用更大的时间片，减少上下文切换的浪费。</p>
<p>动态处理：<br>对于io密集型，尽量别减小优先级。（如果是MLFQ，这是几乎可以保证的，因为io密集，可能在给定的时间片中没有用完时间片就自己进入阻塞状态了）（me）<br>对于cpu密集型，在它的io完成之后，放回io请求时离开的队列，以免每次都回到最高优先级再逐次下降。</p>
<h4 id="最短进程优先"><a href="#最短进程优先" class="headerlink" title="最短进程优先"></a>最短进程优先</h4><h4 id="保证调度"><a href="#保证调度" class="headerlink" title="保证调度"></a>保证调度</h4><p>向用户做出明确的性能保证，然后去实现它。</p>
<p>初始：每个进程同等的share CPU。<br>随后：计算每个进程理应获得的时间与实际获得的时间之比。<br>结果：倾向于运行比率更低的进程，直到它的radio超过他的接近竞争者。</p>
<h4 id="彩票调度"><a href="#彩票调度" class="headerlink" title="彩票调度"></a>彩票调度</h4><p>就是os卖彩票，给每个进程一个彼此不同的彩票，一旦需要调度，就抽彩票，看看谁中奖，中奖的哪个进程获得资源。<br>”所有进程是平等的，但是有一些进程更平等一些“<br>给某些重要的进程额外的彩票，增加他们中奖的几率。</p>
<p>允许进程之间交换彩票，比如客户机进程获得了运行权，然后阻塞等待服务器的响应，这时客户机可以把自己的彩票给服务器机进程，以增加服务器及进程被选中的机会。（实际上，如果没有客户机进程，服务器及进程的存在就是一个错误）</p>
<h3 id="调度实现"><a href="#调度实现" class="headerlink" title="调度实现"></a>调度实现</h3><p>unix：动态优先级算法<br>5.3BSD：MQ<br>Windows：优先级算法<br>Linux：抢占式调度（preemptive scheduling）</p>
<h3 id="调度机制设定"><a href="#调度机制设定" class="headerlink" title="调度机制设定"></a>调度机制设定</h3><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/81651596.jpg" alt=""><br>$$\color{red}{什么鬼这是}$$</p>
<p>在oskernel设计调度算法，就像我们的schedule函数在kernel中完成，并封装用户接口供用户调用。</p>
<p>除了时间片，允许用户也做出调度的决定，完成调度策略设置。</p>
<p><strong>可以参考lab4的文档</strong></p>
<h2 id="进程之间的通信"><a href="#进程之间的通信" class="headerlink" title="进程之间的通信"></a>进程之间的通信</h2><p>消息、管道、消息队列、共享内存</p>
<p>可以参考lab4文档，里面有ipc以及lab5中有共享内存。</p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p><strong>线程</strong>是进程中一个相对独立的、具有可调度特性的<strong>执行单元</strong>。</p>
<p>线程一定不是陌生的，早在大二上学期，就在Java中接触了线程。线程作为实现进程中的并发而存在。</p>
<p>系统提供了线程库Pthread：<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/74457502.jpg" alt=""></p>
<h2 id="线程库"><a href="#线程库" class="headerlink" title="线程库"></a>线程库</h2><p>线程库是针对那些不提供多线程支持的os而设计的在用户态下的库，线程库的处理对这些os是透明的。</p>
<p>即使提供了核心线程支持的os，也有必要提供线程库，可以简化或有利于线程机制的使用。</p>
<p>线程库提供：</p>
<ol>
<li>合适的多线程编程的接口</li>
<li>记录线程状态和调度各个线程的运行机制</li>
</ol>
<p>在系统内部可以使用多种方式实现线程机制：</p>
<ol>
<li>ULT纯用户级线程：线程管理全部由用户程序完成，kernel只管理进程，增加”线程库“概念。</li>
<li>KLT核心级线程：线程有kernel管理，kernel为用户提供系统调用。</li>
</ol>
<p><strong>ULT</strong>：<br>进程表在kernel，线程表在用户空间，使用线程库。线程表由运行时系统管理。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/40601574.jpg" alt=""></p>
<p>ult的优点是：</p>
<ol>
<li>线程切换不需要陷入内核：比陷入内核快一个数量级</li>
<li>允许进程制定自己的调度算法而不会影响os的调度算法程序</li>
<li>ult管理模式可以在任何os下运行，不需要修改内核，只需要线程库。</li>
</ol>
<p>ult的不足是：</p>
<ol>
<li>系统调用会引起进程阻塞</li>
<li>不利于多处理器并行（<strong>why？？？</strong>）</li>
</ol>
<blockquote>
<p>关于系统阻塞的问题：<br>os并不知道进程里还有线程，当一个线程在尚未发生键盘操作的时候读键盘，将会引发阻塞。这时可能整个进程都会被os的调度算法调度下来，整个进程都会阻塞。而要使用线程，应该允许每个线程都能够阻塞调用，而不影响其他线程的运行。现在显然是不行。<br>有两种解决方法，一是修改read在没有外部事件时返回0，但是对read语义的改变休要大量代码的修改。<br>另一种是允许进行阻塞检查，仅在外部事件发生时才进行系统调用，否则先让出使用权给其他线程运行。这种方式一点都不好看，但是也没有其他的方法了。</p>
<p>还有一个问题是进程的无休止运行。没有时间片操作。<br>对ult最大的争论是程序员一般只会在经常发生线程阻塞的程序中才会大量使用线程。</p>
</blockquote>
<p><strong>klt</strong>：<br>线程与进程都在用户空间完成（what？）<br>进程表与线程表都在kernel</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/46110689.jpg" alt=""></p>
<p>优点：<br>线程在kernel中有信息，系统调用基于线程（不存在上述的阻塞）<br>可以克服ult的阻塞与并行度差的缺点，并且kernel也可以使用多线程。</p>
<p>缺点：<br>每次进行线程调度都需要陷入内核</p>
<h2 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h2><p><strong>线程</strong>使劲蹭的一部分，描述指令流执行状态，是进程中的指令执行最小单元，是CPU调度的基本单位。</p>
<p>在进程与线程机制中，进程作为<strong>资源分配</strong>角色，包括地址空间、打开文件等；线程作为<strong>处理机调度</strong>角色，描述进程资源环境中的指令执行序列状态。</p>
<p>进程的表叫做<strong>TCB</strong>。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/26479287.jpg" alt=""></p>
<p>为什么进程有自己独立的栈？<br>进程描述了指令执行状态，而栈中数据与之前执行的指令有关，因此每一个线程都应该有自己的栈。保证执行指令的独立性。</p>
<ol>
<li>调用函数返回</li>
<li>errorno</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">进程中内容</th>
<th style="text-align:center">线程中内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">地址空间</td>
<td style="text-align:center">程序计数器</td>
</tr>
<tr>
<td style="text-align:center">全局变量</td>
<td style="text-align:center">寄存器</td>
</tr>
<tr>
<td style="text-align:center">打开文件</td>
<td style="text-align:center">堆栈</td>
</tr>
<tr>
<td style="text-align:center">子进程</td>
<td style="text-align:center">状态</td>
</tr>
<tr>
<td style="text-align:center">即将发生的报警</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">信号与信号处理程序</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">账户信息</td>
</tr>
</tbody>
</table>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/51773333.jpg" alt=""></p>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>|进程|线程|<br>|资源分配单位|CPU调度单位|<br>|有完整的资源平台|只独享指令执行的必要资源|<br>|基本状态与其他状态与转换|就绪等待运行状态与转换|</p>
<p>线程：减少并发执行的时间与空间开销</p>
<ol>
<li>创建时间比进程短（why）</li>
<li>终止时间比进程短</li>
<li>同一进层内的线程切换时间更短</li>
<li>同一进程之间的线程共享内存与文件，不需要通过内核进行通信。</li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/87331439.jpg" alt=""></p>
<p><strong>what is 多对多</strong></p>
<h2 id="轻权进程"><a href="#轻权进程" class="headerlink" title="轻权进程"></a>轻权进程</h2><p>内核支持的用户线程。</p>
<p>一个进程可以有一个或者多个轻量级进程，每个轻权进程由一个单独的内核线程支持。<br>太过复杂，最后被抛弃。<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/47608393.jpg" alt=""></p>
<h1 id="经典IPC问题"><a href="#经典IPC问题" class="headerlink" title="经典IPC问题"></a>经典IPC问题</h1><p>进程之间的通信，可以参见lab4ipc。</p>
<h2 id="进程之间通信"><a href="#进程之间通信" class="headerlink" title="进程之间通信"></a>进程之间通信</h2><ol>
<li><p>进程之间通信将产生什么问题？</p>
<ol>
<li>异步：从一个进程传递信息到另一个</li>
<li>排外：与其他进程争夺资源</li>
<li>同步：维护适当的运行序列</li>
</ol>
</li>
<li><p>进程之间通信的难处：</p>
<ol>
<li>信息的格式：signal、switch、message</li>
<li>排外与同步：合作问题</li>
</ol>
</li>
<li><p>金字塔规则</p>
</li>
</ol>
<p><strong>竞争条件</strong>：两个或多个进程读写某些共享数据，而最后的果取决于进程运行的精确时序。</p>
<p>书上有一个打印机的例子， 就是说A与B都需要使用打印机，打印机维护in与out指针，供所有进程去访问。假设某一时刻A想打印东西，于是去查找out指针的值，存在临时变量next_free里面，这时时间片来了B上来了，B也要打印东西，于是正常的完成了将东西放在out的位置，out++。这时A回来了，他发现自己next_free是原out值，于是覆盖了B的文件数据，然后把next_free加一，存到out里面。</p>
<h2 id="生产者与消费者问题"><a href="#生产者与消费者问题" class="headerlink" title="生产者与消费者问题"></a>生产者与消费者问题</h2><p>固定大小buffer，生产者加数据，消费者拿数据，更新count，当count是0的时候，消费者休眠，是N的时候生产者休眠。每个进程检查唤醒。</p>
<p>——在数据更新的过程中访问了数据！</p>
<p>概念：<br><strong>race condition</strong>：两个或更多进程竞争同一项资源，在一个进程占用资源的时候其他进程不应该访问。<br><strong>critical region</strong>：对共享内存进行访问的程序片段<br><strong>优秀结果标准</strong>：</p>
<ol>
<li>不可以有两个进程同时处于临界区</li>
<li>不应对CPU的数量与速度有要求</li>
<li>临界区外运行的进程不能阻塞其他进程</li>
<li>进入临界区时不能无限等待</li>
</ol>
<p>《甘特图：临界区》</p>
<p>实际程序中，可以将所有代码根据是否访问共享区域分为四个部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">entry section</div><div class="line">    critical section</div><div class="line">exit section</div><div class="line">    remainder section</div></pre></td></tr></table></figure>
<h3 id="家庭采购协调问题"><a href="#家庭采购协调问题" class="headerlink" title="家庭采购协调问题"></a>家庭采购协调问题</h3><table>
<thead>
<tr>
<th style="text-align:center">时间</th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">3:00</td>
<td style="text-align:center">看冰箱 没面包</td>
<td style="text-align:center">–</td>
</tr>
<tr>
<td style="text-align:center">3:05</td>
<td style="text-align:center">离开家去商店</td>
<td style="text-align:center">–</td>
</tr>
<tr>
<td style="text-align:center">3:10</td>
<td style="text-align:center">到达商店买面包</td>
<td style="text-align:center">看冰箱 没面包</td>
</tr>
<tr>
<td style="text-align:center">3:20</td>
<td style="text-align:center">到家，放面包</td>
<td style="text-align:center">去商店</td>
</tr>
<tr>
<td style="text-align:center">3:25</td>
<td style="text-align:center">–</td>
<td style="text-align:center">到商店买面包</td>
</tr>
<tr>
<td style="text-align:center">3:30</td>
<td style="text-align:center">–</td>
<td style="text-align:center">到家，放面包</td>
</tr>
</tbody>
</table>
<p>我们分析这个问题：</p>
<ol>
<li>如何保证买面包动作的成功与高效：有且仅有一个人去买</li>
<li>可能的解决：加锁 导致的问题：无法取到冰箱中其他东西<br>（具体查看PPT，时间有限）</li>
</ol>
<p>关于临界与外部事件发生：可以将等待临界空闲的进程转到阻塞态。</p>
<h3 id="忙等待"><a href="#忙等待" class="headerlink" title="忙等待"></a>忙等待</h3><p>设计思路：通过全局变量保存临界区状态供进程参考</p>
<h4 id="屏蔽中断（disabling-interrupts）"><a href="#屏蔽中断（disabling-interrupts）" class="headerlink" title="屏蔽中断（disabling interrupts）"></a>屏蔽中断（disabling interrupts）</h4><p>基本思想是在进入临界区之前关中断，这就导致时钟中断也会被关闭，从而没有进程可以打断它。</p>
<p>问题：</p>
<ol>
<li>不支持多CPU</li>
<li>把关中断权限交给用户是不明智的选择</li>
</ol>
<p>但是对于内核来说，关中断是一种很好的方法，可以用来维护多线程（如果支持）或者多CPU之间对就绪队列等的访问<br>（别都选到一个进程就尴尬了，在jos里这会发生错误）（话说，在jos里面实现多CPU的时候可有内核锁机制，下面来看一看锁都加在了哪里）</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/64321100.jpg" alt=""></p>
<h4 id="锁变量（Lock-variable）"><a href="#锁变量（Lock-variable）" class="headerlink" title="锁变量（Lock variable）"></a>锁变量（Lock variable）</h4><p>保存一个名为lock之类的全局变量供各个进程进行检查，实际上无济于事——这不也是临界区吗</p>
<h4 id="严格轮换法（Strict-alertnation）"><a href="#严格轮换法（Strict-alertnation）" class="headerlink" title="严格轮换法（Strict alertnation）"></a>严格轮换法（Strict alertnation）</h4><p>要求进程轮流进入临界区。看了代码就会明白：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">    <span class="keyword">while</span>(trun!=<span class="number">0</span>);<span class="comment">//A进程必须等待turn是0的时候才能进去</span></div><div class="line">    critical_region();</div><div class="line">    turn=<span class="number">1</span>;</div><div class="line">    noncritical_region();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">    <span class="keyword">while</span>(turn!=<span class="number">1</span>);<span class="comment">//B进程必须等到turn是1</span></div><div class="line">    critical_region();</div><div class="line">    turn=<span class="number">0</span>;</div><div class="line">    nocritcal_region();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不是一个很好的方案。</p>
<p>缺点：</p>
<ol>
<li>违反了“进程不应该被处于非临界区的进程阻塞”</li>
<li>浪费CPU时间：忙等待时间</li>
</ol>
<p>很明显啊，他们在轮转的时候，如果A这时需要进入临界区但是B在运行非临界区的程序，A可以被放到阻塞态，这时违反了规则3<br>A可以继续循环，这时每次A上去CPU都会浪费时间空循环，还不如去阻塞态。</p>
<p>还有，如果A需要多次进入临界区，而B主要时间在非临界区，A的效率就变得非常低，绝大多数时间都是在空转。</p>
<p><strong>自旋锁</strong>：用于忙等待的锁。</p>
<p>PPT另有两种，都是失败的方法。暂且不提。</p>
<h4 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h4><p>1981-满足线程之间互斥的经典基于软件的解法</p>
<p>似乎仅用于两个进程：<br><a href="https://zh.wikipedia.org/wiki/Peterson%E7%AE%97%E6%B3%95" target="_blank" rel="external">wiki</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></div><div class="line"><span class="meta">#deine N 2 <span class="comment">//进程数量</span></span></div><div class="line"></div><div class="line"><span class="keyword">int</span> turn;<span class="comment">//轮到进程编号</span></div><div class="line"><span class="keyword">int</span> interested[N];个各进程是不是想去临界区，是不是已经在临界区</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">enter_region</span><span class="params">(<span class="keyword">int</span> process)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> other;<span class="comment">//在临界区的</span></div><div class="line">    other=<span class="number">1</span>-process;</div><div class="line">    interested[process]=TRUE;<span class="comment">//我想进去l临界区</span></div><div class="line">    turn=other;<span class="comment">//</span></div><div class="line">    <span class="keyword">while</span>(turn==other &amp;&amp; interested[other]==TRUE);<span class="comment">//</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">leave_region</span><span class="params">(<span class="keyword">int</span> process)</span></span>&#123;</div><div class="line">    interested[process]=FALSE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行到while处可能会挂起。</p>
<p>怎么使用呢？在每个进程进入临界区之前调用critical_region，退出之后调用leave_region。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/88550095.jpg" alt=""></p>
<p><strong>扩展到N个线程的互斥filter算法</strong>：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/67570267.jpg" alt=""></p>
<h4 id="TSL"><a href="#TSL" class="headerlink" title="TSL"></a>TSL</h4><p>指令：TSL RX LOCK</p>
<p>将lock给rx然后往lock中存一个非0值：保证原子操作，锁内存总线。</p>
<p>代码：<br>    enter_region:<br>        TSL REGISTER , LOCK//原值在寄存器，新值在内存<br>        CMP REGISTER,#0<br>        JNE enter_region<br>        RET//原来是0，可以进去了<br>    leave_region:<br>        MOVE LOCK , #0<br>        RET</p>
<p>一个可以代替tsl的是xchg（是不是很眼熟！）<br>xchg完成的操作是交换两个位置的内容。</p>
<pre><code>enter_region:
    MOVE REGISTER,#1
    XCHG REGISTER,LOCK
    CMP REGISTER,#0
    JNE enter_region
    RET
leave_region:
    MOVE LOCK, #0
    RET
</code></pre><p>锁是一个抽象的数据结构，有方法Acquire与Release。</p>
<p>在获取所的时候，如果锁目前被别人拥有，就等待。<br>释放锁的时候，通知那些等待的进程你们等的锁到了。</p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>使用TSL实现自旋锁：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Lock::Acquire()&#123;</div><div class="line">    <span class="keyword">while</span>(test-<span class="keyword">and</span>-<span class="built_in">set</span>(value));</div><div class="line">&#125;</div><div class="line">Lock::Release()&#123;</div><div class="line">    value=<span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Acquire:不停地区获取锁的值并将锁的值赋为1，直到锁的值变为0。（说明有进程从临界区出来了）</p>
<p>忙等待确实可以解决2个进程之间互斥运行的问题，但是缺点也很多，浪费CPU时间，编程困难，可能会造成优先级错乱。</p>
<h4 id="无忙等待锁"><a href="#无忙等待锁" class="headerlink" title="无忙等待锁"></a>无忙等待锁</h4><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/30861938.jpg" alt=""></p>
<h3 id="睡眠与唤醒"><a href="#睡眠与唤醒" class="headerlink" title="睡眠与唤醒"></a>睡眠与唤醒</h3><p>进程间通信<strong>原语</strong>，在无法进入临界区的时候进入阻塞状态而不是忙等待。</p>
<p>当一个进程发现自己不能进入临界区的时候，就系统调用sleep，阻塞去。另一个进程要离开临界区，就调用wakeup将她唤醒。<br>sleep\wakeup(pid);</p>
<h4 id="简单睡眠唤醒机制"><a href="#简单睡眠唤醒机制" class="headerlink" title="简单睡眠唤醒机制"></a>简单睡眠唤醒机制</h4><p>正如上述。</p>
<p>悲惨的是，假如wakeup信号丢失了，没有被唤醒的进程还在阻塞，假如剩余一个进程进入临界区需要该进程的作用，就都阻塞。</p>
<p>对MCPU不支持：使用进程号。</p>
<p>终于，现在可以考虑一下生产者消费者的解决了：</p>
<p>略。可见书或PPT</p>
<p>这是失败的解决，可能会导致wakeup信号丢失结果二人都去阻塞。</p>
<h3 id="信号量解决"><a href="#信号量解决" class="headerlink" title="信号量解决"></a>信号量解决</h3><p>P-&gt;down V-&gt;up</p>
<p><strong>信号量</strong>：一种新的变量类型，表示唤醒操作剩余次数。（所有相关线程引起的总竞争条件检查次数）<br><strong>信号</strong>是一个抽象数据类型，由一个整形变量与两个原子操作组成。</p>
<p>down：对某个信号量down是检查他的value，如果不是0，就减一，如果是0就去sleep。<br>up：对某个信号量的值加1。如果睡眠，就唤醒。</p>
<p>信号量是被保护的，在初始化完成之后，只能通过pv修改，而pv操作是被保证的原子操作。</p>
<p>通常嘉定信号量是公平的，也就是说不会一直被阻塞在p操作。（假设先进先出）</p>
<p>信号量的实现与前面说到的无忙等待锁很像：<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/30861938.jpg" alt=""><br>其实block也相当于被调度了。<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/8720151.jpg" alt=""></p>
<p>区别在于前面说的无忙等待锁并不是原子性的。</p>
<p><strong>解决方案</strong>：<br>每一个临界区设置一个信号量对象，初值是1代表初始时可以进入一个到临界区去。<br>p在进入之前，v在进入之后。必须成对出现。</p>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>同步可能会被调度序列打乱。（？）</p>
<p>同步与互斥的区别：</p>
<ol>
<li>互斥值放值其他进程进入cr</li>
<li>同步是指实现一个合理的逻辑序列</li>
</ol>
<p>whats this<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/11688740.jpg" alt=""></p>
<h4 id="ipc问题分析——使用信号量解决生产者消费者问题"><a href="#ipc问题分析——使用信号量解决生产者消费者问题" class="headerlink" title="ipc问题分析——使用信号量解决生产者消费者问题"></a>ipc问题分析——使用信号量解决生产者消费者问题</h4><p>1.ipc问题产生 原因：</p>
<ol>
<li>物理序列依赖于调度</li>
<li>逻辑序列依赖应用层需的意愿</li>
<li>竞争条件排斥资源获取</li>
</ol>
<p>在内核态以及用户态都有ipc问题，在内核态是io设备的管理，在用户态是网络应用、数据库等的管理。</p>
<p>ipc问题的关键在于：</p>
<ol>
<li>理解逻辑与物理序列  </li>
<li>逻辑序列依赖于调度</li>
<li>逻辑序列可以被用户控制</li>
</ol>
<p>whats that…..</p>
<p>使用信号量可以实现条件同步。</p>
<p><strong>生产者消费者问题</strong>：<br>一共需要三个信号量：mutex\full\empty。<br>首先，buffer是一个临界区，无论核心进入临界区出来临界区都需要一个信号量，其次，当buffer满的时候（N），生产者不可以进去buffer，需要消费者消费之后up才能进，消费者同理。<br>我认为，后两者实际上是在利用信号量的特点完成程序的逻辑部分，而不仅仅是对临界区的进入控制。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/97276693.jpg" alt=""></p>
<h4 id="monitor-solution"><a href="#monitor-solution" class="headerlink" title="monitor solution"></a>monitor solution</h4><p>信号量的一个缺点是对编程者来说不好写出代码。</p>
<p>monitor（管程）是一对过程、变量、数据结构的集合，（可以被看作是编译器），他们组成一个特殊的模块或软件包</p>
<p>应用：任意时刻管程中只能有一个活跃进程（有效完成互斥）<br>wait and signal：就像pv、du一样<br>不足：只有很少的语言支持。</p>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>组成：一个锁（管程代码互斥）、0或多个条件变量（管理共享数据的并发访问）</p>
<p>进入管程时的互斥由编译器完成</p>
<p><strong>条件变量</strong>：（像是信号量一样的东西）是管程内的的等待机制，允许在进程无法继续运行的时候被阻塞。<br><strong>wait</strong>：无法继续运行时调用，将自己阻塞并掉一个互斥访问进管程<br><strong>signal</strong>：指示一个呼哧进程开始运行，自己退出管程。</p>
<p>wait与signal很像是在之前的sleep与wakeup。但是关键的区别是，这里管程保证了互斥，不允许在wait之前切换进程进入管程。（其实存疑）</p>
<h4 id="条件变量实现"><a href="#条件变量实现" class="headerlink" title="条件变量实现"></a>条件变量实现</h4><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/49329583.jpg" alt=""></p>
<h4 id="管程解决生产者-消费者问题"><a href="#管程解决生产者-消费者问题" class="headerlink" title="管程解决生产者-消费者问题"></a>管程解决生产者-消费者问题</h4><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/21915703.jpg" alt=""></p>
<h4 id="hansen与hoare"><a href="#hansen与hoare" class="headerlink" title="hansen与hoare"></a>hansen与hoare</h4><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/51508560.jpg" alt=""></p>
<p>hansen主张signal只能是管程过程最后一个语句，二hoare则认为不一定，主张signal之后就应该自己阻塞让新的进程进入管程运行。</p>
<p>也是因为这样，，hansen的判断方式使用while而hoare判断使用if。</p>
<p><a href="http://www.cnblogs.com/xybaby/p/6516387.html" target="_blank" rel="external">并发与同步-xybaby</a></p>
<blockquote>
<p>同步互斥，就是在并发的前提下保证一些操作的原子性。</p>
</blockquote>
<h2 id="IPC问题：哲学家就餐"><a href="#IPC问题：哲学家就餐" class="headerlink" title="IPC问题：哲学家就餐"></a>IPC问题：哲学家就餐</h2><p><strong>对互斥访问有限资源的竞争建模</strong></p>
<blockquote>
<p>进程同步也是进程之间直接的制约关系，是为完成某种任务而建立的两个或多个线程，这个线程需要在某些位置上协调他们的工作次序而等待、传递信息所产生的制约关系。进程间的直接制约关系来源于他们之间的合作。</p>
<p>from：<a href="http://www.cnblogs.com/CareySon/archive/2012/04/14/Process-SynAndmutex.html" target="_blank" rel="external">浅谈进程同步与互斥的概念-宋沄剑</a></p>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>互斥：相邻哲学家只有一个人可以使用筷子</p>
<p>同步：</p>
<ol>
<li>想要进餐的哲学家应该拿到两个筷子</li>
<li>同一时刻至多有两个哲学家一同进餐</li>
<li>死锁与饥饿避免</li>
</ol>
<p>ppt</p>
<h2 id="IPC问题：读者与写者"><a href="#IPC问题：读者与写者" class="headerlink" title="IPC问题：读者与写者"></a>IPC问题：读者与写者</h2><p><strong>为数据库访问建模</strong></p>
<p>（会不会产生问题：在不是writer想要放弃的时候强迫writer放弃）——理解错误，<br>P：可不可以得到资源？可以，OK继续执行：不可以OK我去阻塞<br>这个“我”指的是“调用P的那个过程。</p>
<p>保证公平这个，concur是什么？是</p>
<p>##IPC问题：睡觉的理发师</p>
<h2 id="猴子过索桥"><a href="#猴子过索桥" class="headerlink" title="猴子过索桥"></a>猴子过索桥</h2><h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3>
      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    傻瓜日和
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://yoursite.com/2017/11/06/OS/chap2-进程与线程/" title="chap2-进程与线程">http://yoursite.com/2017/11/06/OS/chap2-进程与线程/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
            <a href="/tags/OS/" rel="tag"># OS</a>
          
        </div>
      
<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------结束啦 <i class="fa fa-paw"></i> 留下你的爪印叭~-------------</div>
    
</div>
  
</div>

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/11/06/OS/chap3-内存管理/" rel="next" title="chap3-内存管理">
                <i class="fa fa-chevron-left"></i> chap3-内存管理
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/11/09/编译原理/编译原理——词法分析/" rel="prev" title="编译原理——词法分析">
                编译原理——词法分析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.gif"
                alt="傻瓜日和" />
            
              <p class="site-author-name" itemprop="name">傻瓜日和</p>
              <p class="site-description motion-element" itemprop="description">来如春梦不多时 去似朝云无觅处</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">58</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/yayi2456" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:yourname@gmail.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://stackoverflow.com/yourname" target="_blank" title="StackOverflow">
                    
                      <i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://weibo.com/2723381840/" target="_blank" title="Weibo">
                    
                      <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#导"><span class="nav-number">1.</span> <span class="nav-text">导</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么要并发（Cocurrency）？"><span class="nav-number">1.1.</span> <span class="nav-text">为什么要并发（Cocurrency）？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程"><span class="nav-number">2.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程概念"><span class="nav-number">2.1.</span> <span class="nav-text">进程概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程状态"><span class="nav-number">2.2.</span> <span class="nav-text">进程状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程数据结构"><span class="nav-number">2.3.</span> <span class="nav-text">进程数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程切换"><span class="nav-number">2.4.</span> <span class="nav-text">进程切换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运行镜像（process-image）"><span class="nav-number">2.5.</span> <span class="nav-text">运行镜像（process image）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程调度算法"><span class="nav-number">2.6.</span> <span class="nav-text">进程调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#when-and-why"><span class="nav-number">2.6.1.</span> <span class="nav-text">when and why</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#goal"><span class="nav-number">2.6.2.</span> <span class="nav-text">goal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#批处理系统中的调度算法"><span class="nav-number">2.6.3.</span> <span class="nav-text">批处理系统中的调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#先来先服务（FCFS）"><span class="nav-number">2.6.3.1.</span> <span class="nav-text">先来先服务（FCFS）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最短时间优先算法（SPN）"><span class="nav-number">2.6.3.2.</span> <span class="nav-text">最短时间优先算法（SPN）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最短剩余时间优先算法（SRT）"><span class="nav-number">2.6.3.3.</span> <span class="nav-text">最短剩余时间优先算法（SRT）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最高响应比优先算法（HRRN）"><span class="nav-number">2.6.3.4.</span> <span class="nav-text">最高响应比优先算法（HRRN）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三层调度"><span class="nav-number">2.6.3.5.</span> <span class="nav-text">三层调度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#交互式系统中的调度"><span class="nav-number">2.6.4.</span> <span class="nav-text">交互式系统中的调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#时间片轮转-（RR）"><span class="nav-number">2.6.4.1.</span> <span class="nav-text">时间片轮转 （RR）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多级队列调度算法（MQ）"><span class="nav-number">2.6.4.2.</span> <span class="nav-text">多级队列调度算法（MQ）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多级反馈队列算法（MLFQ）"><span class="nav-number">2.6.4.3.</span> <span class="nav-text">多级反馈队列算法（MLFQ）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优先级算法（PS）"><span class="nav-number">2.6.4.4.</span> <span class="nav-text">优先级算法（PS）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最短进程优先"><span class="nav-number">2.6.4.5.</span> <span class="nav-text">最短进程优先</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#保证调度"><span class="nav-number">2.6.4.6.</span> <span class="nav-text">保证调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#彩票调度"><span class="nav-number">2.6.4.7.</span> <span class="nav-text">彩票调度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调度实现"><span class="nav-number">2.6.5.</span> <span class="nav-text">调度实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调度机制设定"><span class="nav-number">2.6.6.</span> <span class="nav-text">调度机制设定</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程之间的通信"><span class="nav-number">2.7.</span> <span class="nav-text">进程之间的通信</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程"><span class="nav-number">3.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线程库"><span class="nav-number">3.1.</span> <span class="nav-text">线程库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的概念"><span class="nav-number">3.2.</span> <span class="nav-text">线程的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程与线程"><span class="nav-number">3.3.</span> <span class="nav-text">进程与线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#轻权进程"><span class="nav-number">3.4.</span> <span class="nav-text">轻权进程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#经典IPC问题"><span class="nav-number">4.</span> <span class="nav-text">经典IPC问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程之间通信"><span class="nav-number">4.1.</span> <span class="nav-text">进程之间通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生产者与消费者问题"><span class="nav-number">4.2.</span> <span class="nav-text">生产者与消费者问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#家庭采购协调问题"><span class="nav-number">4.2.1.</span> <span class="nav-text">家庭采购协调问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#忙等待"><span class="nav-number">4.2.2.</span> <span class="nav-text">忙等待</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#屏蔽中断（disabling-interrupts）"><span class="nav-number">4.2.2.1.</span> <span class="nav-text">屏蔽中断（disabling interrupts）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#锁变量（Lock-variable）"><span class="nav-number">4.2.2.2.</span> <span class="nav-text">锁变量（Lock variable）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#严格轮换法（Strict-alertnation）"><span class="nav-number">4.2.2.3.</span> <span class="nav-text">严格轮换法（Strict alertnation）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Peterson算法"><span class="nav-number">4.2.2.4.</span> <span class="nav-text">Peterson算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TSL"><span class="nav-number">4.2.2.5.</span> <span class="nav-text">TSL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自旋锁"><span class="nav-number">4.2.2.6.</span> <span class="nav-text">自旋锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#无忙等待锁"><span class="nav-number">4.2.2.7.</span> <span class="nav-text">无忙等待锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#睡眠与唤醒"><span class="nav-number">4.2.3.</span> <span class="nav-text">睡眠与唤醒</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简单睡眠唤醒机制"><span class="nav-number">4.2.3.1.</span> <span class="nav-text">简单睡眠唤醒机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号量解决"><span class="nav-number">4.2.4.</span> <span class="nav-text">信号量解决</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#同步"><span class="nav-number">4.2.4.1.</span> <span class="nav-text">同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ipc问题分析——使用信号量解决生产者消费者问题"><span class="nav-number">4.2.4.2.</span> <span class="nav-text">ipc问题分析——使用信号量解决生产者消费者问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#monitor-solution"><span class="nav-number">4.2.4.3.</span> <span class="nav-text">monitor solution</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管程"><span class="nav-number">4.2.5.</span> <span class="nav-text">管程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#条件变量实现"><span class="nav-number">4.2.5.1.</span> <span class="nav-text">条件变量实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#管程解决生产者-消费者问题"><span class="nav-number">4.2.5.2.</span> <span class="nav-text">管程解决生产者-消费者问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hansen与hoare"><span class="nav-number">4.2.5.3.</span> <span class="nav-text">hansen与hoare</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IPC问题：哲学家就餐"><span class="nav-number">4.3.</span> <span class="nav-text">IPC问题：哲学家就餐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分析"><span class="nav-number">4.3.1.</span> <span class="nav-text">分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IPC问题：读者与写者"><span class="nav-number">4.4.</span> <span class="nav-text">IPC问题：读者与写者</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#猴子过索桥"><span class="nav-number">4.5.</span> <span class="nav-text">猴子过索桥</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#消息传递"><span class="nav-number">4.5.1.</span> <span class="nav-text">消息传递</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">傻瓜日和</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>





  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>


	<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
本站总访问量 <span id="busuanzi_value_site_pv"></span> &nbsp&nbsp&nbsp
您是第<span id="busuanzi_value_site_uv"></span>个来到的小伙伴



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共126.3k字</span>
</div>



        




  <script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=64002140";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

  
  
<div id="hexo-helper-live2d">
  <canvas id="live2dcanvas" width="150" height="300"></canvas>
</div>
<style>
  #live2dcanvas{
    position: fixed;
    width: 150px;
    height: 300px;
    opacity:0.7;
    right: 0px;
    z-index: 999;
    pointer-events: none;
    bottom: -20px;
  }
</style>
<script type="text/javascript" src="/live2d/device.min.js"></script>
<script type="text/javascript">
const loadScript = function loadScript(c,b){var a=document.createElement("script");a.type="text/javascript";"undefined"!=typeof b&&(a.readyState?a.onreadystatechange=function(){if("loaded"==a.readyState||"complete"==a.readyState)a.onreadystatechange=null,b()}:a.onload=function(){b()});a.src=c;document.body.appendChild(a)};
(function(){
  if((typeof(device) != 'undefined') && (device.mobile())){
    document.getElementById("live2dcanvas").style.width = '75px';
    document.getElementById("live2dcanvas").style.height = '150px';
  }else
    if (typeof(device) === 'undefined') console.error('Cannot find current-device script.');
  loadScript("/live2d/script.js", function(){loadlive2d("live2dcanvas", "/live2d/assets/hijiki.model.json", 0.5);});
})();
</script>

</body>
</html>
