<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[OS-Lab3]]></title>
      <url>/2017/11/14/OS-Lab3/</url>
      <content type="html"><![CDATA[<h1 id="Lab3：User-Environment"><a href="#Lab3：User-Environment" class="headerlink" title="Lab3：User Environment"></a>Lab3：User Environment</h1><h2 id="Pre：实验准备知识"><a href="#Pre：实验准备知识" class="headerlink" title="Pre：实验准备知识"></a>Pre：实验准备知识</h2><h3 id="GCC内联汇编"><a href="#GCC内联汇编" class="headerlink" title="GCC内联汇编"></a>GCC内联汇编</h3><h3 id="特权降级"><a href="#特权降级" class="headerlink" title="特权降级"></a>特权降级</h3><h4 id="基础知识准备"><a href="#基础知识准备" class="headerlink" title="基础知识准备"></a>基础知识准备</h4><p>切换到保护模式之后就会有不同的特权等级，这时默认在最高的特权等级上。这个时候为内核建立了页表结构，接下来将会跳转到用户程序。进行跳转的时候，应该注意：不可以再留着这个高级的运行权限了，因此需要进行特权级的降级。</p>
<p>系统在以上电时，各个资源管理都还没有建立，这个时候处于特权管理模式，在特权模式建立完毕所有的资源映射之后，再降级到通用模式，运行。</p>
<p>因此，一上电运行的指令一旦被不安全的程序接管，将不会降级，保护措施将形同虚设。因此，在智能手机等终端上都有一个叫做trustdo(?)的硬件，它是一个加密的模块，这个模块是系统上电之后运行的第一段代码，作用是验证将要运行的这段代码是不是被授权的，数字签名是否通过，若通过才会运行。trustdo会被做到CPU的芯片中，保证了即使上电后处于特权模式的代码是安全可靠的。</p>
<hr>
<p><strong>iret</strong>：系统指令，从中断中返回。<br><strong>ret</strong>：从函数中返回<br><strong>retf</strong>：与ret基本一样，从函数中返回。（弹出栈，拿出返回地址（就是下一条语句）返回值，丢掉压栈参数）</p>
<p>中断是一个硬件的事件，中断返回与函数返回不同。当一个中断来了，不管你当时在干嘛，就乖乖地保存一下现场去响应中断。这个<strong>保存现场</strong>，包括了硬件将会自动帮你保存的一些现场，比如CS、SS、Flag等等，这些是自动存下的，iret的作用就是自动地将这些东西都弹出。但是这些现场保存并不够，通用寄存器是不会帮你保存的。</p>
<p>ret、iret等等在汇编之中可以随意调用，并不需要其他约束。如果当你在汇编中不是函数（中断）的里面调用了这些，它会干些什么呢？<br>他会把自己认为的自己保存进去的那些东西弹出来，一个是返回地址给PC，一个是返回值给保存返回值的东西。即使没有调用函数，ret的行为也是固定的：<strong>从栈顶弹出两个值，一个给PC，一个给存储返回值的东西</strong>，iret的行为也是固定的，就是从栈顶弹出东西给那些变量。<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-14/87170051.jpg" alt=""><br>这就是保护现场之后的栈。<br>ret是弹出到eip，retf弹出到CS，iret弹出到CS（代码段）、EFLAGS，根据是否改变特权等级，iret会连下面的SS以及esp一起弹出来。</p>
<p>这样，如果一个程序在栈中事先在栈中存了一些数据，然后调用了iret，iret不管栈中究竟是什么，就会弹出5（3）个元素，给对应的寄存器。ret和retf也类似。因此，在汇编中ret们与高级语言的return们的作用不同，汇编中的ret们只是<strong>提供了一个批量修改寄存器的方法</strong>。</p>
<p>系统中有两种中断。中断可能在任意时间发生。在用户模式下与在特权模式下中断发生后系统的动作是不相同的。</p>
<p>在用户模式下，系统会保存这些东西：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-14/4474675.jpg" alt=""><br>还记得在“内存管理”的lab里面讲过的<strong>段选择子</strong>，其中有两个bit标识自己处在什么特权模式下的特权位。这里面有两个段选择子，一个是栈的，一个是代码段的，由于在用户模式下，可以看到CS代码段选择子与SS栈选择子的特权位RPL都是3。</p>
<p>在特权模式下，一旦发生中断：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-14/84089468.jpg" alt=""><br>这时保存的东西比较少。</p>
<p>无论在哪种模式下一旦调用iret，就把这些东西（其实不一定是这些东西，只是对应栈顶的几个数据）弹出去给对应的寄存器。</p>
<h3 id="正题：特权降级"><a href="#正题：特权降级" class="headerlink" title="正题：特权降级"></a>正题：特权降级</h3><p>考虑做完lab2，系统在特权级是0的模式下，这是需要现将自己降级成为特权3的模式，再去运行用户程序。怎么降？</p>
<p>要伪造一个场景：刚刚一个用户程序产生了一个中断所以我升级了，现在我要中断返回。于是我去伪造了一个栈，在栈里头存上了iret希望的那5个数据，每一个是32位。然后调用iret，这些就会从栈中弹出来到达对应的寄存器，然后我就回到了用户模式，那两个段选择子的特权级值就被改为了3。<br>这里需要注意的是，系统原来使用的特权级是0的栈，iret之后这个栈空掉了，但是系统不再使用这个栈，而是重新为用户态开避了一个新的栈，这个栈不再是以前的那个栈了，这个栈放在用户空间的数据段里，它的权限也是3。</p>
<blockquote>
<p>为什么要这样设计呢？在特权模式下，系统并不想和特权级更低的用户态共用一个特权级更高的栈。另一个方面从安全考虑，为了防止用户态随意弹出数据随意插入数据破坏内核运行。</p>
</blockquote>
<p>从特权模式到达用户模式，新创建了一个栈给用户程序使用，这是在刚上电的时候，还没有用户程序运行。用户程序运行过程中可能会有系统调用回到特权模式下，这是将会使用前面提到的系统用的那个栈，系统调用完成之后，不会再为用户程序创建新的栈了，一是占空间，一是以前的运行态不能就这样丢掉。就还让它回到自己原来的栈。</p>
<h2 id="特权级提升"><a href="#特权级提升" class="headerlink" title="特权级提升"></a>特权级提升</h2><p>中断、异常、系统调用：我需要更高特权的东西帮帮我。</p>
<p>在80386中，系统调用就是一个中断。异常是需要紧急处理的中断。</p>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>在32位机器上的中断是一个很复杂的机制，因为那时保护模式已经建立了起来，整个运行在虚拟地址空间上。所以当中段发生的时候，系统使用<strong>中断描述符表</strong>，写着自己所有的中断号。<br>中断描述符寄存器（IDTR）中存的就是中断描述符表（IDT）在内存中的位置以及大小。表按照中断号排序，每一个中断描述符在80386中被叫做一个门，<strong>中断门</strong>（中断），<strong>陷阱门</strong>（异常）。会根z中断发生的编号从表中取出对应的描述符（门），<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-15/43120327.jpg" alt=""><br>取回的描述符是这样的：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-15/96785647.jpg" alt=""><br>segment selector与offset用来描述在段机制下自己的中断响应函数的位置。segment selector负责在GDT里面找到对应的段，offset负责找对应的偏移量。找到函数之后，保存现场并执行响应函数。</p>
<p>在终端发生的时候，系统将会看一下产生中断的程序的特权级，决定应该怎样保护现场。如果在特权状态，不用换栈，只需要保存更少的东西，而处于用户状态下的程序在执行完中断响应函数之后还要从（？）退回到自己的用户栈，保存了更多的东西。</p>
<h3 id="正题：特权级提升"><a href="#正题：特权级提升" class="headerlink" title="正题：特权级提升"></a>正题：特权级提升</h3><p>从特权模式3切换到特权模式0，实际上就是响应一个中断，这就是上面图中的trap。</p>
<p>对于用户程序，os并不信任。当trap发生时，当前用户程序的运行状态会被存入到<strong>内核栈</strong>中，而用户栈并没有变化。这也是中断与普通函数调用的不同。<br>现在已经进入了特权模式，如果不作任何操作，只是调用一个iret，前面讲到的CS，SS特权级3又会被写入到寄存器里面，就又回到了用户态。为了能留在特权模式下，对栈进行伪造，假装在进入终端之前就是一个特权模式：也就是把上面提到的用户态发生中断的栈信息修改成特权模式发生中断的栈信息。这时iret，就可以留在特权模式下。</p>
<p>但是：在伪造的时候，SS被扔掉了。怎么回去呢？80386提供了一个<strong>TSS任务状态段</strong>，它几乎可以存下CPU上所有的寄存器的不止一份拷贝。TSS每个进程一个，会存下一个进程在切换特权状态的时候原特权状态下的SS的值。系统将会自己对TSS进行维护，以确保切换模式时栈的跳转。</p>
<p>TSS存在于哪里呢？在GDT里面有一个TSS的描述符：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-15/80552651.jpg" alt=""></p>
<p>80386中有4个特权模式，目前在虚拟化技术下只是用了3个。</p>
<p>有一个叫做TSR的寄存器，存着selector、base addr以及segment limit。便于直接找到TSS。</p>
<p>如果想要回到用户模式，进入trap，伪造一个从用户态过来的栈，iret即可。</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>用户程序可以通过系统调用访问内核服务，这个过程需要指定中断号，使用tarp或者特殊指令（SYSENTER/SYSEXIT）实现。</p>
<h2 id="关于这次实验"><a href="#关于这次实验" class="headerlink" title="关于这次实验"></a>关于这次实验</h2><p>这里的env就是课上讲的pcb。<br>父子进程的一个作用是父进程要为子进程收尸。</p>
<p>elf格式：linux下的可执行。<br>创建进程并执行elf：没有文件系统怎么办？<br>把指定的文件链接进目标文件，骗bootloader把程序也搬进内存。</p>
<p>-b binary path:-b帮我搬进来。binary这是个可执行程序。<br>然后重生成一个符号表。<br>把这个文件作为一个大数组缀到最后，然后直接使用这个数组。</p>
<p>编码的时候，这个数组还没有，链接的时候才有，怎么办？定义一个外部变量extern。<br>只需知道生成符号表的规则，然后按规则命名即可。</p>
<p>进来之后还只是一个大数组，还需要经过链接之后映射要对应的虚拟地址才能执行。</p>
]]></content>
      
        <categories>
            
            <category> OS </category>
            
            <category> MIT Lab </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2017/11/13/OS4+Memory%20and%20Process/</url>
      <content type="html"><![CDATA[<hr>
<hr>
<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p><strong>例：STL的实现</strong><br>printf：<br>对屏幕：</p>
<ol>
<li>在每一个像素有一种颜色</li>
<li>文本模式</li>
</ol>
<h2 id="系统调用与函数调用"><a href="#系统调用与函数调用" class="headerlink" title="系统调用与函数调用"></a>系统调用与函数调用</h2><p>系统调用是中断，相当于在用户程序执行的过程中嵌入一段由OS完成的代码，完成后再返回用户程序。其中，包括特权级的升降。在进行系统调用的过程中，进入之后首先会检查用户传参是否有危险，随后再执行系统调用。这将在一个新的页完成，存在于<strong>内核态独立地址空间</strong>，将会带来包括TLB，Cache等的一系列问题。因此，系统调用的代价比函数调用的代价大得多。</p>
<h1 id="进程间的通信"><a href="#进程间的通信" class="headerlink" title="进程间的通信"></a>进程间的通信</h1><h2 id="直接通信与间接通信"><a href="#直接通信与间接通信" class="headerlink" title="直接通信与间接通信"></a>直接通信与间接通信</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">send(A,)</div></pre></td></tr></table></figure>
<h2 id="阻塞通信与非阻塞通信"><a href="#阻塞通信与非阻塞通信" class="headerlink" title="阻塞通信与非阻塞通信"></a>阻塞通信与非阻塞通信</h2><p>像网络中那样，阻塞通信就是//</p>
<h2 id="通信链路缓冲"><a href="#通信链路缓冲" class="headerlink" title="通信链路缓冲"></a>通信链路缓冲</h2><p><strong>0容量</strong>：发送方需要等待接收方<br><strong>有限容量</strong>：<br><strong>无限容量</strong>：</p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号类似于中段，</p>
<p>是最原始、最简单的一个进程间交互的模式。在关机时，系统将会用这种方式通知各各进程。</p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>父子之间传递信息</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>类似于电子邮件系统。</p>
<p>得到一个队列，使用队列号来标识。此后消息的send与recv都通过这个队列。</p>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>创建共享段<code>shmget(key,size,flags)</code>。其中key是其他人希望与你共享内存的话必须知道的值。<code>shmat(shmid,*shmaddr,flags)</code>把共享段映射到进程地址空间。</p>
<p>在这里，将又会遇到在“哲学家就餐”那部分的问题。另外，还将会有在cache还是内存的问题。cache作为在读写操作时第一个碰到的硬件，是否可以保证进程A写的时候吧东西写进了共享区的物理内存？在B不能使用的时候它的Cache的正确性哈能不能保证？—？</p>
<p>由一个“可否使用cache”的位</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[哈希]]></title>
      <url>/2017/11/12/%E5%93%88%E5%B8%8C/</url>
      <content type="html"><![CDATA[<hr>
<p>emmm…大二的时候DS只考了80，出来混的，总是要还的。</p>
<h2 id="不希望文件太多都小于512k，会占我的空间。"><a href="#不希望文件太多都小于512k，会占我的空间。" class="headerlink" title="不希望文件太多都小于512k，会占我的空间。"></a>不希望文件太多都小于512k，会占我的空间。</h2><h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><p>哈希其实没什么神秘的，不过是一群贪心的人的产物。</p>
<p>散列函数，将key转化为对应的value值得到索引。这个有诸如<strong>取模</strong>，<strong>ASCII平均</strong>，等等方法。橙皮书上有一种sfold，似乎性能会更好一些。</p>
<h2 id="开哈希"><a href="#开哈希" class="headerlink" title="开哈希"></a>开哈希</h2><p>开哈希类似于静态链表，每一个value对应一个链表，成为挂着的桶。</p>
<h2 id="闭哈希"><a href="#闭哈希" class="headerlink" title="闭哈希"></a>闭哈希</h2><p>闭哈希将node存储在给定的一个数组中。这个数组的下标将作为value的索引值，由于value可能重复，需要探查方式，有很多方式，比如线性探查与二次探查。</p>
<p>关于闭哈希的删除，其实不必真的每次都向前挪，而是增加一个“墓碑”，它代表这里没有数据可以被插入，但是又不是真的空因为需要继续向前探查。<br>当次数多了性能就会下降，一种解决方式是向前挪，另一种是重新散列。</p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[语言们的输出格式控制]]></title>
      <url>/2017/11/12/%E8%AF%AD%E8%A8%80%E4%BB%AC%E7%9A%84%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F%E6%8E%A7%E5%88%B6/</url>
      <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/leewiki/archive/2011/12/13/2286168.html" target="_blank" rel="external">待整理</a></p>
]]></content>
      
        <categories>
            
            <category> 语言 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 语言 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[张爱玲——出名要趁早]]></title>
      <url>/2017/11/10/Untitled-1/</url>
      <content type="html"><![CDATA[<p>张爱玲对“成名”二字</p>
]]></content>
      
        <categories>
            
            <category> 我的精神 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 我的精神 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[编译原理——词法分析]]></title>
      <url>/2017/11/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>我有罪….我先是用学编译的时间逛了淘宝….然后又用学编译的时间逛了六维…..我有罪….\infty</p>
<blockquote>
<p>时间：1012cp3 3:15开始 词法分析器介绍</p>
<p>编译并不是一件轻松的事情，对于较大的系统，编译的速度并不理想，这也是为什么我们需要优化编译技术。</p>
</blockquote>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>词法单元（单词）</strong>：由一个词法单元名以及一个可选的属性值组成。名即是语法分析器的输入符号token。<br><strong>模式</strong>：一个词法单元的词素可能具有的形式。一个词素不能与两个或多个词法单元进行匹配（二义性）。<br><strong>词素</strong>：源程序中的字符序列，是程序中实际出现的字符串。</p>
<blockquote>
<p>在lex与yacc中，有时会有一个全局变量。他保存了当前词素（词法单元：关于这里，龙书里面的和wg写的不一样呢？）的属性值，这个属性值可以被记录在语法树上。</p>
</blockquote>
<h2 id="词法分析器要干些什么？"><a href="#词法分析器要干些什么？" class="headerlink" title="词法分析器要干些什么？"></a>词法分析器要干些什么？</h2><p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-12/6339247.jpg" alt=""></p>
<ol>
<li>读入源程序字符，生成词素，确定词法单元序列</li>
<li>与符号表进行交互</li>
<li>过滤掉源程序中的<strong>注释</strong>与<strong>空白</strong></li>
<li>将编译器生成的错误信息与位置联系</li>
<li>预处理：扫描阶段完成不需要生成词法单元的简单处理；词法分析阶段处理扫描阶段的输出并生成词法单元</li>
</ol>
<blockquote>
<p>跳过了一些东西</p>
</blockquote>
<h1 id="正则表达式（正规表达式、正规式）"><a href="#正则表达式（正规表达式、正规式）" class="headerlink" title="正则表达式（正规表达式、正规式）"></a>正则表达式（正规表达式、正规式）</h1><p>为什么需要正则表达式来描述字符串序列呢？<br>像在上下文无关文法中所描述的那样，因为字符们所组成的可能的字符串是<strong>无穷</strong>的。</p>
<p>单词是什么？单词的本质就是<strong>符号串的集合</strong>。正则表达式就是代替了自然语言对特定符号串集合的描述。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>符号表</strong>：符号的有穷集合<br><strong>符号串</strong>：字母表中符号构成的有穷序列。也成<strong>句子</strong>，<strong>字</strong>。<strong>|s|</strong>代表<strong>字符串s的长度</strong>，$\epsilon$是空字符串。<br><strong>语言</strong>：是一个给定符号表上的特定的符号串的集合。</p>
<p>比如：给定符号表{1,0}，有符号串01100010，一种语言是{0，1，00，11，000，111….}即串中只含一种字符的字符串集合。</p>
<p>特例：$\varnothing$是<strong>空语言</strong>。{$\epsilon$}是只含空串的语言。</p>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="符号串的运算"><a href="#符号串的运算" class="headerlink" title="符号串的运算"></a>符号串的运算</h3><p><strong>连接</strong>：x=hou y=se xy=house    s$\epsilon$=$\epsilon$s=s  (emmmm说好的不能这样写呢？)<br><strong>幂</strong>：$s^n=s^(n-1) * s^1$</p>
<h3 id="语言的运算"><a href="#语言的运算" class="headerlink" title="语言的运算"></a>语言的运算</h3><p>下表中运算符的优先级由低到高</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算</th>
<th style="text-align:center">定义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">并</td>
<td style="text-align:center">$L\cup M={ s \ s\in L 或 s\in M} $</td>
</tr>
<tr>
<td style="text-align:center">交</td>
<td style="text-align:center">$LM={ st \ s\in L 且 t\in M} $</td>
</tr>
<tr>
<td style="text-align:center">Kleen闭包</td>
<td style="text-align:center">$L^*=\cup_{i=0}^\infty L^i$</td>
</tr>
<tr>
<td style="text-align:center">正则闭包</td>
<td style="text-align:center">$L^*=\cup_{i=1}^\infty L^i$</td>
</tr>
</tbody>
</table>
<p>$$\color{red}{正则表达式&lt;-&gt;语言运算的简洁描述}$$</p>
<h2 id="正则表达式定义"><a href="#正则表达式定义" class="headerlink" title="正则表达式定义"></a>正则表达式定义</h2><p>字母表$\sum$上的正规式r的定义规则，以及r所表示语言L(r)定义：</p>
<ol>
<li>$\epsilon$是正规式，表示语言{$\epsilon$}</li>
<li>若$a\in \sum$则a是正规式，表示语言{a}</li>
<li>r , s是正规式，表示语言L(r)与L(s)，则：<ol>
<li>(r)|(s)是正规式，表示语言L(r)$\cup$L(s)</li>
<li>(r)(s)是正规式，表示语言L(r)L(s)</li>
<li>$(r)^*$是正规式，表示语言$(L(r))^*$</li>
<li>(r)是正规式，表示语言L(r)</li>
</ol>
</li>
</ol>
<p>第三条的四条，优先级从上到下依次升高。</p>
<blockquote>
<p>$(a|b)^*$={所有由a、b组成的符号串}</p>
</blockquote>
<p>正规式<strong>等价</strong>：r=s &lt;-&gt; L(r)=L(s)</p>
<p>正则运算的特性:<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-12/3363060.jpg" alt=""></p>
<p>可以像产生式那样，为正规式指定名字：</p>
<blockquote>
<p>num -&gt; r1<br>其实，上下文无关文法的描述能力包含了正则表达式的描述能力。所有可以被正则表达式描述的都可以被上下文无关文法描述，但是正则表达式并不能描述某些上下文无关文法可以描述的东西。<br>那么为什么需要正则表达式来实现词法分析器？</p>
<ol>
<li>简化编译器的设计：使每一阶段需要做的事情更加简单清晰</li>
<li>提高编译器的效率：使用专门的字符缓冲技术提高编译速度</li>
<li>增强编译器的可移植性：输入设备相关的特殊性被限制在词法阶段</li>
</ol>
</blockquote>
<p>下面举一个例子：</p>
<blockquote>
<p>无符号整数：<br>digit -&gt; 0|1|2|…|9<br>digits -&gt; digit digit*  其实也可以是$digit^+$<br>optional_fraction -&gt; .digits | $\epsilon$<br>optional_exponent -&gt; (E(+|-|$\epsilon$)digits)|$\epsilon<br>num -&gt; digits optional_fraction optional_exponent</p>
</blockquote>
<p><strong>符号简写：</strong></p>
<p><strong>+</strong>:一个或多个实例<br><strong>?</strong>:0或1个实例：$r?=r|\epsilon$$\rightarrow$$L(r)\cup {\epsilon}$<br><strong>[]字符集</strong>:[abc]=&gt;a|b|c、[a-z0-9]=&gt;a|b|..|z|0|1..|9</p>
<h2 id="非正规集"><a href="#非正规集" class="headerlink" title="非正规集"></a>非正规集</h2><p><strong>正规式无法描述的语言</strong>：{wcw|w是a、b组成的字符串}正规式无法描述平衡或嵌套的结构<br><strong>正规式只能表示</strong>：有限的重复、一个给定结构的无限重复</p>
<p>关于正规式的练习，参考<a href="http://blank" target="_blank" rel="external">第三章练习</a></p>
<h1 id="Lex"><a href="#Lex" class="headerlink" title="Lex"></a>Lex</h1><p>使用流程与yacc类似。</p>
<p>$\color{red}{ATTENTION!</p>
<p>在使用project wizard建立lex的时候你写的那个词法分析器的名字就是那个名字，</p>
<p>你最好别自己再修改，否则在VS里面运行不出来！！！}$</p>
<p>给的是字符流，出来的是单词流。</p>
<p>规则段放正则表达式与语义动作。</p>
<p>第四次作业词法分析器设计将会上传。<a href="http://blank" target="_blank" rel="external">click here to get</a></p>
<h1 id="有限自动机"><a href="#有限自动机" class="headerlink" title="有限自动机"></a>有限自动机</h1><p>有限自动机可以直接转换成程序。</p>
<h2 id="NFA"><a href="#NFA" class="headerlink" title="NFA"></a>NFA</h2><h1 id="从正则表达式到自动机"><a href="#从正则表达式到自动机" class="headerlink" title="从正则表达式到自动机"></a>从正则表达式到自动机</h1><p>从这之后，正是lex所做的事情。</p>
<p>在这一节里，将介绍两个过程：一个是正则表达式到NFA，另一个是NFA到DFA。之所以让NFA做一个过渡，是因为正则表达式直接到DFA的算法很复杂。本次更新掠过。</p>
<p>NFA与DFA的性能差别很大：NFA占用空间比较少，但是使用NFA进行词法分析需要在错误态停止，可能需要花费$O(2^n)$的时间复杂度；DFA占用空间很大（最坏情况下$O(2^n)$），但是使用它进行词法分析的时候接近线性时间。</p>
<h2 id="正则-gt-NFA"><a href="#正则-gt-NFA" class="headerlink" title="正则 -&gt; NFA"></a>正则 -&gt; NFA</h2><p>正则表达式构造NFA使用<strong>MacMaughton-Yamada-Thompson算法</strong>。简称<strong>Thompson算法</strong>。这个算法描述如下：</p>
<p><strong>基本规则：</strong></p>
<h2 id="自动机运转"><a href="#自动机运转" class="headerlink" title="自动机运转"></a>自动机运转</h2><blockquote>
<p>s $\leftarrow$ e -closure({s0});<br>c $\leftarrow$ nextchar;<br>while c $\neq$ eof do<br> s $\leftarrow$ e -closure(d(s,c));<br> c $\leftarrow$ nextchar;<br>end;<br>if S$\cap$F$\neq$ $\varnothing$ then return “yes”<br>         else return “no”</p>
</blockquote>
<hr>
<blockquote>
<p>s $\leftarrow$ s0;<br>c $\leftarrow$ nextchar;<br>while c $\neq$ eof do<br> s $\leftarrow$ d(s,c);<br> c $\leftarrow$ nextchar;<br>end;<br>if s is in F then return “yes”<br>            else return “no”</p>
</blockquote>
<p>前面提到了，NFA占空间更少，DFA识别字符串更快，贪心的人类啊希望能糅合这两者的优点。看前面的NFA代码，其实在第四行那句，实际上就是前面提到的构造DFA的过程。人们想到使用Cache。使用NFA，当NFA构造出DFA的一个状态时，就把这个状态构造的条件以及状态本身存到cache里面。当while进一个c的时候，首先看一看现今状态加上c到达的态是不是已经存在cache，如果存在里面，最耗时间的那一部分就不用运行了。cache的管理仍然是程序局限性原则。占用空间不会太大以期望达到折衷的效果。</p>
<p>如果要构造出一个Lax，需要将所有的正则表达式得到的NFA进行一个并操作（保留各自的终态以区分）。然后构造它的DFA。</p>
<p>值得注意的是，这样不能在一个终态停止，而是在错误态终止并退回到最近经过的那个终态（每经过一个终态，记录当前的<strong>输入指针</strong>以及<strong>匹配模式</strong>）。以防止找到前缀，产生错误。这种方法是<strong>最长前缀法</strong>，在前面已经提到过。</p>
<h1 id="DFA优化"><a href="#DFA优化" class="headerlink" title="DFA优化"></a>DFA优化</h1><p>DFA状态数其实不会太多的影响时间复杂度，当状态变少的时候，将会减少存储空间的消耗。</p>
<p><strong>区分：</strong>一个符号串可区分两个状态：这一个串<strong>从这两个状态出发</strong>在DFA上得到的结果一个是accept，一个是reject。在做区分的时候，其实可以看到：最终字符串得到的终态在不同集合，则他们是可区分的。</p>
<blockquote>
<p>Ex<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-9/60487283.jpg" alt=""><br>a不能区分状态A与B。而且还可以看到，以a开头的所有字符串都不可能区分A与B了。再进一步看到，a不可能区分任意两个，因为所有状态在经过a的状态迁移之后都到达了状态B。<br>同理，b不可能区分ACE，以b开头的都不能区分ACE。但是b却可以区分BD。<br>不要忘记，$\epsilon$可是可以区分的。而且他的区分应该被放在最前面，那是因为$\epsilon$区分了终态与其他状态。</p>
</blockquote>
<p>在区分的过程中发现了这样一个规律：如果对于串s，A状态与B状态经过了s都到达同一个状态C，那么以s做前缀的字符串都不可能区分A与B了。当所有字符串都不能区分A与B的时候，可以把A与B合并成同一个状态。但是对于无穷的字符串，怎么确定 “所有都不行” 呢？ 在前面，我们已经提出了一个解决方案——当前缀s不行的时候，所有的sx都不行了。但是，即使是有了这个规律，使用“不行”的这种方法解决问题仍会显得繁琐。</p>
<p>真正在执行的时候，实行的是<strong>分裂</strong>，这样，通过有顺序地枚举字符串，将能被区分开的状态分开。这样对于前面的<strong>不同集合</strong>的说法，也能更好地理解。</p>
<p><strong>算法描述：</strong>首先使用$\epsilon$区分终态与非终态，将它们分为两个集合。随后，像子集构造法那样，有顺序地枚举输入字符串，将那些经过状态迁移能到达终态（不同集合）的状态剔除出去组成一个新的集合（如果两者到达同一个集合，这两者是不能区分的，应该在同一个集合），对于那些含有多个元素的集合，如果经过一系列不同的状态迁移到达不同的集合，仍需要继续分开。直到不再产生新的集合。</p>
<blockquote>
<p>仍然使用上面的例子，进行分裂的过程：</p>
<ol>
<li>$\epsilon$ -&gt; {A,B,C,D}、{E}</li>
<li>a -&gt; {A,B,C,D}  ({B,B,B,B})-&gt;全部一样，以a打头的不用再试</li>
<li>b -&gt; {A,B,C}{D}  ({C,D,C,E})</li>
<li>b -&gt; {A,C}{B}{D}  ({C,C,D})  -&gt; 不同集合</li>
</ol>
<p>最终得到的最小DFA：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/65136532.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/4345780.jpg" alt=""></p>
</blockquote>
<p>最后使用新的状态进行迁移的时候，一定不会出现问题。</p>
<h1 id="补充：从自动机到正则表达式"><a href="#补充：从自动机到正则表达式" class="headerlink" title="补充：从自动机到正则表达式"></a>补充：从自动机到正则表达式</h1><p>可以从一个DFA或NFA得到对应的正则表达式。但是这种方式并不是总是简单的，他只是提供了一个模糊的思路，当一个DFA很复杂的时候，还是需要有聪明才智才行。<br>这里只是简单的给出这个方法，具体可查看<a href="http://note.youdao.com/noteshare?id=9fa52c6fcb1a6637fbdb36f669852abe&amp;sub=9A6AEF1D34C044E68D8BD1AD2057996E" target="_blank" rel="external">这个文件</a>。</p>
<p>为了使讨论更加简单，我们强制一个DFA/NFA应该有下列特性：</p>
<ol>
<li>初态可以到达任意其他状态，没有状态可以通过状态迁移到达初态</li>
<li>只有一个终态，终态不能通过状态迁移到达非终态</li>
<li>初态不能是终态</li>
<li>除了初态与终态，其他状态彼此相连</li>
</ol>
<p>这四个条件看起来很可怕，其实当我们引入了$\varnothing$并根据情况添加初态终态之后，很容易可以把一个DFA/NFA转为一个符合要求的有限自动机。</p>
<p>以一个例子来说明：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/17062978.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/80510309.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/99180281.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/86068172.jpg" alt=""></p>
<p>为了不让自己沾沾自喜，必须指出上面给出的例子很简单，看下面这个：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/70925658.jpg" alt=""></p>
<p>由于生成initstate的一个要求是，不能有进入initstate的箭头，好，像上面一样加一个init，加一个Ac，随即，在删除A的时候就会发现问题。这尼玛转来转去的究竟怎么写边上的正则表达式啊？！</p>
<h1 id="能不能与好不好"><a href="#能不能与好不好" class="headerlink" title="能不能与好不好"></a>能不能与好不好</h1><p>在龙书的第九章。</p>
<ol>
<li><p>流程可否更加简洁？ 正则 -&gt; DFA：本质上还是做子集构造法-吧正则的某些位置对应NFA里面状态，位置集对应NFA的状态集</p>
</li>
<li><p>优化结果？ 最小DFA</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 编译原理 </category>
            
            <category> 听课 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OS:内存管理]]></title>
      <url>/2017/11/06/OS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<p>#</p>
]]></content>
      
        <categories>
            
            <category> OS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OS </tag>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JUnit之一]]></title>
      <url>/2017/11/05/JUnit%E4%B9%8B%E4%B8%80/</url>
      <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/ai92/article/details/302844" target="_blank" rel="external">这是一个简单的JUnit入门介绍</a>。</p>
<p>junit是一个测试框架，把一个java工程按照JUnit运行的时候会启动这些检测，但是这并不影响这个项目作为一个JAVA程序的本质。这个程序仍然可以以Java Application来运行。</p>
<h2 id="在eclipse中使用Junit4进行单元测试"><a href="#在eclipse中使用Junit4进行单元测试" class="headerlink" title="在eclipse中使用Junit4进行单元测试"></a>在eclipse中使用Junit4进行单元测试</h2><p>安装eclipse的时候，应该已经有了junit的jar包，如果没有，可以自己去<strong>maven仓库</strong>搜索下载。</p>
<p><a href="http://tech.sina.com.cn/s/2010-01-18/14081218926.shtml" target="_blank" rel="external">在eclipse中使用Junit4进行单元测试</a></p>
<p>为了方便，我会把上述的方法自己实践并写在下面：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/17569873.jpg" alt=""></p>
<p>不要直接finish。点击next，你将可以选择对哪些方法进行测试，eclipse就会自动帮你命名（which is very essential）</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/14409795.jpg" alt=""><br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/45619270.jpg" alt=""></p>
<p>看！</p>
]]></content>
      
        <categories>
            
            <category> 计算机网络 </category>
            
            <category> 实验室 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 实验室 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 模拟器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机网络应用层之番外二]]></title>
      <url>/2017/11/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82%E7%95%AA%E5%A4%96%E4%BA%8C/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>其实这里该是运输层番外….但是这是应用层作业啦。</p>
<p>多用户并发访问与可靠文件传输，不能有下载大小的限制。</p>
<p>为了用UDP实现多用户并发访问，一定是需要使用多个socket。仿照FTP的协议设计：使用一个UDP的socket在master进行监听，这个socket绑定一个确定的端口号，用户客户机连接服务器发请求使用。</p>
<p>考虑的请求比较小，可以使用一个包传送完成：</p>
<p>Server在端口号X进行监听。</p>
<p>将有一个N。<br>一个client要求连接，发送请求之后立即fork一个子进程，仍然使用这个socket，立即进入准备接收的状态。Server收到了，立即fork一个子线程，master继续监听，确保其他client的请求能被接收到。子线程新建一个UDP的socket，准备进行接收。由于UDP的不可靠，希望在传输数据的时候，Server应该首先，在fork出子线程之后立即对命令请求进行分析，告诉client一共要穿多少个包。（因为在n结束之后，client的子线程就会结束。如果不采用n结束子线程就结束，肯定需要有一个例如，里最后一个包recv之后多久end。这样应该是不太可靠的…对于server，需要有超时重传。emmmm</p>
<p>其实这样也行：</p>
<p>client子线程立即等待server传回的数据。同时启动一个定时器，如果超过了一定时间，反正也是同一个socket，就再重传，然后去等。</p>
<p>server呢，在子线程fork出之后就去分析命令，然后开始传包。每一个包有一个序列号。采用选择重传的机制进行文件信息的传输。当发送端的所有发出的包已经发送完毕并且所有的一发送包都得到回执确认之后，向接收端发送最终的发送完毕包。这个包在发送完之后，client接受到之后必须给ACK。server收到ACK之后才能关闭。</p>
<p>有状况：<br>如果client没接到信息或者信息错了，按照选择重传，不会有动作，server重传没毛病；如果client给的ACK丢了，server不能确定client已经收到，也会重传，所以client不可能在发送完ACK就关闭，而是影该等待server的回执，让server知道我已经知道我拿到完整的包了。一旦等到，立即关闭。<br>所以client这边对于最后一个包的动作是：recv-&gt;收到错报，不动，等重传/收到对的包，回复ACK同时启动一个超时重传机制，开始接收server的回执，不管接受到了什么，关闭。（因为这个时候server只要收到了client的东西就证明client肯定已经知道包已经传完了）<br>因为server最终只发送一次，如果client连着很多次超时重传都没有收到回应，很大可能已经server关闭了，为了不陷入无休止的重传，client关闭。</p>
<p>server的动作是-&gt;发送最后一个结束包-&gt;超时重传/接收到client的信息-&gt;发送一个ACK，关闭。</p>
<p>server也知道client这时server也已经关闭</p>
<h1 id="最终交付"><a href="#最终交付" class="headerlink" title="最终交付"></a>最终交付</h1><h2 id="计算机网络书面作业：网络协议设计"><a href="#计算机网络书面作业：网络协议设计" class="headerlink" title="  计算机网络书面作业：网络协议设计 "></a><center>  计算机网络书面作业：网络协议设计 </center></h2><center>yayi2456</center>

<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;本协议仿照了FTP协议以允许多客户机的并行操作，使用选择重传的方法在UDP的基础上进行一定程度的可靠性的保证与效率的保证，加入其他机制保证大文件的可靠传输。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;server端的主socket绑定一个端口号，进行对客户请求的监听。一旦监听到客户机的请求，立即fork一个子线程，在子线程中重新绑定一个socket，由这个socket与客户机进行通信。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;client端根据程序并行度可选择是否需要在子线程发出请求，这取决于不同的应用程序的动作，不做讨论。提到client的动作时，并不指定是在哪个进程。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>将该协议描述如下：</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;server监听端口A，一旦监听到client的请求，立即fork子线程。在子线程中对该请求进行分析，并决定需要发送给client的数据。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;client向server发送请求，并启动一个定时器，当超过一定时间仍未收到server传回的第一个包，client重新发送请求信息。使recvbase为0，收到第一个数据包之后，<code>recv=(recv+1)%(2*N)</code>，该定时器关闭。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>注</strong>：在server收到请求之后，并没有立即发送ACK通知client自己已经收到了请求。原因在于server最终一定会发送数据给client，只需要把第一个数据包作为server收到的确认信息即可，同时也减少了可靠性保证所花费的额外的时间。但是由于server对准备发送的数据需要做一定的处理，这个时延可能会稍长。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;server开始向client发送包。采用选择重传机制，server为每一个包附上一个<strong>序号</strong>，同时利用UDP头本身具有的checksum字段进行一定程度的检错判断。server每次最多传送N个报文段，协议中具有2*N个序号。初始时，发送缓冲区中的sendbase是0，server每传送一个报文段就会启动一个对应于该报文段的定时器，当某个报文段的定时器超时之后，server对该报文段进行重传；当server收到了某个序号的报文段的ACK之后，将该序号置为“已确认”，如果该序号是sendbase，那么将<code>sendbase=(sendbase+1)%(2*N)</code>，如果sendbase是“已确认”，再将<code>sendbase=(sendbase+1)%(2*N)</code>，直到sendbase是“已发送但未确认”或是“可用”。同时，当sendbase改变时，如果包尚未发送完，则可以使用新的“可用”来发送新的报文段。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;client接受到第一个数据包之后关闭第一个定时器，并向服务器发送对第一个数据包对应的序号的ACK，随后开始接收其他数据包，每接收到一个检验和没有错的数据包，返回一个对应该数据包序号的ACK包。无论是不是server端没有接收到上一个对应该序号的ACK，返回一个ACK，对于最大为2*N的空间来说，是没有问题的。对于在[recvbase,recvbase+N-1]空间中的序号对应的包加以解析送给应用层使用或者是缓存之后将对应的序号标为“接收已确认”，而另外的序号对应的数据包只返回ACK，对数据包直接丢弃。每次接收到一个被“接收已确认”的数据包，如果该数据包的序号是recvbase，<code>recv=(recv+1)%(2*N)</code>，如果这时recvbase对应序号仍是“接收已确认”，<code>recv=(recv+1)%(2*N)</code>，直到recvbase对应序号是“期待但未收到”或是“可用”。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在所有的有用数据包传送完成之后，server需要告知client，有用的数据已经传送完了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;场景分析如下：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;当server的所有发出的包已经发送完毕并且所有的已发送包都得到回执ACK之后，向client发送最终的发送完毕包。这个包在发送完之后，client接收到之后必须给ACK。server收到ACK之后才能关闭，否则可能导致client不知道自己已经拿到完整的数据而陷入空转。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;如果client没接到最终包信息或者信息错了，按照选择重传，client不会有动作，server等待超时之后重传；如果client回复的ACK丢了，server不能确定client已经收到，必须重传来确认client已经知道自己可以关闭连接了，所以client不可能在发送完ACK就关闭，而是该等待server的回执，让server知道client已经知道client拿到完整的包了，否则可能会使server陷入无尽的重传。一旦等到server的回执，client立即关闭。若许久都未等到回执，关闭。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;下面对最后的动作进行描述：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;server的动作是：发送最后一个结束包，启动定时器，若超时则进行重传；直到接收到client的信息之后，关闭定时器，server发送一个ACK，立即关闭。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;client最终的动作是：等待接收数据，如果收到错误的包，等重传；如果收到对的包，回复ACK同时启动一个定时器，启动超时重传机制，并开始接收server的回执，不管接受到了什么，关闭。若超时一定次数之后仍未接收到server的回执，因为server最终只发送一次，如果client连着很多次超时重传都没有收到回应，很大可能已经server关闭了，为了不陷入无休止的重传，client关闭。</p>
<p>从宏观的角度来看，客户机与服务器的交互是：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-5/15535425.jpg" alt=""></p>
<p><strong>扩展FSM：</strong></p>
<p><strong>server：</strong></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-5/73814791.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-5/41957911.jpg" alt=""></p>
<p><strong>client：</strong></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-5/90929804.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 计算机网络 </category>
            
            <category> 大三的课 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络课 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机网络运输层之二]]></title>
      <url>/2017/11/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82%E4%B9%8B%E5%BE%AA%E5%BA%8F%E6%B8%90%E8%BF%9B/</url>
      <content type="html"><![CDATA[<h1 id="UDP概述"><a href="#UDP概述" class="headerlink" title="UDP概述"></a>UDP概述</h1><p>UDP很弱，除了上一节提到的复用分解机制以及少量的差错检验之外，基本没有功能了，如果程序员选择了UDP，那基本上就是在与IP打交道了。</p>
<blockquote>
<p>以一个DNS查询为例：应用层给出了一个查询报文交给运输层，UDP加了首部段，交给网络层，网络层将他封装进一个IP数据报，发送给一个名字服务器。DNS如果没有收到对方的回应，要么向另一个服务器发送请求，要么告知调用它的应用程序没有响应。</p>
</blockquote>
<h2 id="1-UDP特点"><a href="#1-UDP特点" class="headerlink" title="1. UDP特点"></a>1. UDP特点</h2><ul>
<li><p>无连接：</p>
<ol>
<li>两个UDP之间没有握手；</li>
<li>UDP报文段彼此独立</li>
</ol>
</li>
<li><p>不可靠：</p>
<ol>
<li>没有确认接收；</li>
<li>没有重传；</li>
<li>没有检查包丢失与包失序</li>
<li>检验和只覆盖部分信息</li>
<li>没有拥塞控制</li>
</ol>
</li>
</ul>
<p>UDP很弱，为什么不使用更加可靠的TCP呢？</p>
<ol>
<li><p>关于何时发送什么样的数据的控制更为精细。UDP是只要应用层交付，UDP就立即给网络层，而TCP有一个拥塞控制机制，可能会遏制发送方，是数据传输变得缓慢。</p>
</li>
<li><p>无需建立连接，减少时延。</p>
</li>
<li><p>无连接状态，不需要维护连接状态。连接状态包括接收和发送数据缓存、拥塞控制参数、序号以及确认号的参数等。某些应用程序运行在UDP之上可以支持更多的活跃用户。</p>
</li>
<li><p>分组首部开销小</p>
</li>
</ol>
<p>UDP的这些特点使得：</p>
<ol>
<li>DNS简单查询；</li>
<li>流媒体应用；</li>
<li>P2P应用</li>
<li>网络管理应用：通产工作在高压状态之下；</li>
<li>路由转换协议</li>
</ol>
<p>等将有更佳的适用度。</p>
<blockquote>
<p>现今，由于出于安全考虑，某些机构阻塞UDP流量，而且当丢包率低时，TCP将更多的用于流媒体应用。</p>
<p>然而，由于UDP没有拥塞控制机制，当网络繁忙时，路由器会有大量的分组溢出，几乎没有UDP分组能够成功通过路由器到达目的地。而且，具有拥塞控制机制的TCP发送方会减慢自己的速率。UDP没有拥塞控制机制不仅造成了UDP会话之间的高丢包率，也挤垮了TCP会话。很多研究人员已经提出了新的机制，使所有数据源执行自适应的拥塞控制。</p>
<p>希望使用UDP实现可靠传输的话需要在应用层协议上加上可靠性保证。这种方法既可以保证可靠传输，又可以拒绝拥塞控制的影响。</p>
</blockquote>
<p>表1：流行的因特网应用及其下协议</p>
<table>
<thead>
<tr>
<th>应用</th>
<th>应用层协议</th>
<th>下层运输协议</th>
</tr>
</thead>
<tbody>
<tr>
<td>电子邮件</td>
<td>SMTP</td>
<td>TCP</td>
</tr>
<tr>
<td>远程终端访问</td>
<td>Talnet</td>
<td>TCP</td>
</tr>
<tr>
<td>Web</td>
<td>HTTP</td>
<td>TCP</td>
</tr>
<tr>
<td>文件传输</td>
<td>FTP</td>
<td>TCP</td>
</tr>
<tr>
<td>远程文件服务器</td>
<td>NFS</td>
<td>通常UDP</td>
</tr>
<tr>
<td>流式多媒体</td>
<td>通常专用</td>
<td>UDP或TCP</td>
</tr>
<tr>
<td>因特网电话</td>
<td>通常专用</td>
<td>UDP或TCP</td>
</tr>
<tr>
<td>网络管理</td>
<td>SNMP</td>
<td>通常UDP</td>
</tr>
<tr>
<td>路由选择协议</td>
<td>RIP</td>
<td>通常UDP</td>
</tr>
<tr>
<td>名字转换</td>
<td>DNS</td>
<td>通常UDP</td>
</tr>
</tbody>
</table>
<h2 id="2-UDP报文"><a href="#2-UDP报文" class="headerlink" title="2. UDP报文"></a>2. UDP报文</h2><p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/9685377.jpg" alt="UDP头信息"></p>
<p>长度：指明了包括首部信息在内的UDP报文段长度（单位：字节：Byte）；</p>
<p>下面重点说<strong>检验和</strong>：</p>
<p>在计组里面就学了几个检错方法，对于一个检错机制：数据=冗余位  实际数据。决定检错能力的是冗余位数与算法。对于UDP，他提供的是一个很简单的检错机制，而且只能检错，不能修改错误。</p>
<h3 id="Persudo-Header"><a href="#Persudo-Header" class="headerlink" title="Persudo Header"></a>Persudo Header</h3><p>persudo header结构是这样的：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/92376358.jpg" alt=""></p>
<p>在发送端，首先会将报文段中的checksum清零，然后把报文段与persudo header的数据当作16bit的很多数据，对他们进行求和运算，将得出的16bit结果求反给checksum字段。</p>
<p>在接收端，产生新的伪首部，然后只需要将这些数据全部求和，最终如果是16个1，说明<strong>可能</strong>是没错的，但是也可能<strong>发生的错误已经超出了检错能力</strong>，如果不是16个1，那说明一定是错了。</p>
<p>checksum有什么用呢？对于明确错误的信息，UDP会要么丢弃；要么把数据给应用层，但是给应用层警告说数据是错的。</p>
<blockquote>
<p>其实伪首部破坏了分层结构，在运输层产生了网络层的信息。</p>
<p>UDP校验和覆盖的范围超出了UDP数据报本身，使用伪首部的目的是检验UDP数据报是否真正到达目的地，正确的目的地包括了特定的主机和该主机上特定的端口</p>
<p>checksum机制在ipv4下是可选的，但是在ipv6下是必须的。</p>
</blockquote>
<p>在checksum中看到了<strong>端对端原则</strong>。端对端原则是一个被受赞扬的原则，该原则表述为某种功能必须基于端对端实现：”与在较高级别提供这些功能的代价相比，在较低级别上设置的功能可能是冗余或几乎没有价值的。“<br>在这里，由于不能保证从网络到物理到链路都有有效的检错机制，甚至在某些路由器的内存中也可能引入比特差错，实现端对端的错误检测机制是有必要的。</p>
<h1 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h1><p>在这一节里，将所有的底层数据传输视为不可靠的，可能会发生数据的丢失、差错、失序等。</p>
<p>这里讨论的是普遍的计算机网络使用的理论，将以<strong>分组</strong>代替<strong>报文段</strong>被使用。同时，只考虑<strong>单向数据传输</strong>，其实<strong>双向数据传输</strong>并不会更难。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/10707246.jpg" alt=""></p>
<h2 id="构造可靠数据传输协议"><a href="#构造可靠数据传输协议" class="headerlink" title="构造可靠数据传输协议"></a>构造可靠数据传输协议</h2><h3 id="rdt1-0：信道完全可靠"><a href="#rdt1-0：信道完全可靠" class="headerlink" title="rdt1.0：信道完全可靠"></a>rdt1.0：信道完全可靠</h3><p>假如信道完全可靠，UDP完全可靠。发送方只要接收到rdt_send就做处理并调用udp_send，接收方只要接收到rdt_rcv就处理。有限状态机（FSM）图如下：</p>
<p>发送端：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/67644025.jpg" alt=""></p>
<p>接收端：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/29594625.jpg" alt=""></p>
<h3 id="rdt2-0：信道具有比特差错"><a href="#rdt2-0：信道具有比特差错" class="headerlink" title="rdt2.0：信道具有比特差错"></a>rdt2.0：信道具有比特差错</h3><p><strong>自动重传请求</strong>（Automatic Repeat reQuest）：在接收方确认接收到正确的报文之后给出<strong>肯定确认</strong>，接受到不正确的报文之后给出<strong>否定确认</strong>。</p>
<p>实际上，这种机制需要其他的支持：</p>
<ol>
<li>差错检测</li>
<li>接收方反馈：如果正确，返回ACK，不正确返回NAK。</li>
<li>重传：发送方在接收到NAK时重传。</li>
</ol>
<p>FSM：</p>
<p>发送方：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/62528979.jpg" alt=""></p>
<p>接收方：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/18789362.jpg" alt=""></p>
<p>但是，如果ACK或者NCK的包错误了怎么办呢？<br>一般有三种解决方法：</p>
<ol>
<li>发送请求，询问上一个差错包的内容。这样很容易陷入询问的死循环。</li>
<li>增加足够的检错纠错能力。导致冗余数据过多。</li>
<li>直接重传。可能会引入冗余分组，使得接收方不知道这个包是新包还是重传包。</li>
</ol>
<p>对于第三种方法，可以引入<strong>序列号</strong>的概念来解决问题。对于我们现在讨论的停等协议，只需要两个序号即1bit即可。</p>
<p>这个版本是<strong>rdt2.1</strong>，新的FSM是这样的：</p>
<p>发送方：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/35627137.jpg" alt=""></p>
<p>接收方：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/21016547.jpg" alt=""></p>
<p>其实，如果不使用NAK，而是对上次的接收再发送一个ACK，也能起到同样的效果，这样，有了<strong>rdt2.2</strong>版本：</p>
<p>发送方：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/79622017.jpg" alt=""></p>
<p>接收方：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/43136886.jpg" alt=""></p>
<h3 id="比特交替协议——rdt3-0：信道可能丢包、产生比特差错"><a href="#比特交替协议——rdt3-0：信道可能丢包、产生比特差错" class="headerlink" title="比特交替协议——rdt3.0：信道可能丢包、产生比特差错"></a>比特交替协议——rdt3.0：信道可能丢包、产生比特差错</h3><p>如果产生了丢包，接收端是不会知道的，只能在发送端处理这个问题。一个是发送端主动发送的数据丢失，和接收端没有关系，一个是接收端已经收到了包，但是发送的确认信息丢失。</p>
<p>发送方需要<strong>重传</strong>，应该做到：</p>
<ol>
<li>每次发送数据之后启动一个定时器</li>
<li>响应定时器中断</li>
<li>停止定时器</li>
</ol>
<p>在重传中，延时时间的设置是很重要的。过长的延迟时间将影响应用层的体验，果断的延迟时间将会引入<strong>冗余数据分组</strong>。rdt2.2已经有能力处理冗余数据分组：当在等待1的时候又传来了0，接收端会直接丢弃这些数据。而对于停等协议，不会有在等1的时候正好发送了1的冗余包的情况。</p>
<p>发送方：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/29153183.jpg" alt=""></p>
<h2 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h2><p>rdt3.0对于错误处理已经比较完善了，但是他的问题在于他是一个停等协议。停等协议对链路的利用率低到令人发指！</p>
<blockquote>
<p>对于一个速度是1Gbps的链路，发送一个大小1000Byte的包：</p>
<p>进入所需时间：$$t=\frac{L}{R}=\frac{8000bit/pkt}{10^9bit/s}=8us/pkt$$</p>
<p>假设传输所需时间是15ms，那么信道的利用率是：</p>
<p>$$U_sender=\frac{\frac{L}{R}}{RTT+\frac{L}{R}}=\frac{0.008}{30.008}=0.00027$$</p>
</blockquote>
<p>为了提高传输效率，停等协议需要被摒弃。现在使用的技术被称为<strong>流水线</strong>。<br>使用流水线技术，1个bit的序号是不够用的，在后面我们将讲到对于n个同时发出的包，需要2*n个序列号。而且，在发送端和接收端都需要有缓存机制来暂时存储：发送端需要存储已经发送但是没有确认接收的数据，接收端需要存储已经正确接收的数据。</p>
<p>这一节并没有完整的讨论流水线机制下的协议，从下一小节开始，对缓存的处理、序列号的处理进行讨论。</p>
<h2 id="回退N步：GBN"><a href="#回退N步：GBN" class="headerlink" title="回退N步：GBN"></a>回退N步：GBN</h2><p>允许发送方连续发送N个数据包，接收方按序接收数据包，失序的包会被丢弃。（这时由于没有考虑双向传输，而且接收端的机制，在接收端的结构暂且不提）</p>
<p>在发送方将会有一个缓冲区，把结构抽象成这样：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/82326531.jpg" alt=""></p>
<p>在这次传输的过程中只能使用[send_base,sendbase+N-1]之间的序号。扩展FSM如图：</p>
<p>发送端：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/56361901.jpg" alt=""></p>
<p>接收端：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/32672336.jpg" alt=""></p>
<p>在这个FSM中存在变量，初始化是需要的。<br>在发送端，当上层请求发送数据时，有一个判断：如果还可以继续发送（nextseqnum&lt; base+N），就继续发送，如果在发送这个之前所有的包都已经被确认过了，就需要开一个定时器，<strong>从这里可以看出：计时器以最左边界启动</strong>。如果不能再发送了，拒绝发送数据。这时可能有三种处理方式：将该数据返回给上层，隐含地表示已经不能再传了；缓存这些数据；使用同步机制只允许上层在窗口不满的时候才能调用rdt_send。<br>数据发送出去之后，如果按时接收到了一个ACK，比如说是ACK(i)，那么说明从base到i都已经被确认了。假如这时已经没有未确认包了，计时器停止，否则，重新为新的最左包启动一个定时器。<br>如果ACK损坏了，什么也不做。因为有定时装置，只需等待重传。这与rdt3.0的机制是相同的。<br>好了，timeout了，将现在所有的未确认全部重传，然后重启定时器。</p>
<p>在接收端，同样初始化。<br>接收端只会等待需要等待的按序的包，如果不是按序的，不予接收，并将上一个确认信息给发送方。类似于rdt2.0的处理方式。发送方收到的这个包并不会对发送方有什么影响，只是由于timer不能被停止或重启，一定时间之后便会触发重传。但是对于那些ACK丢失的包有重大意义：推动sendbase向前。<br>如果接受端收到了一个按序的、在检错能力之内没有错误的包，才对他进行处理，更新自己的期望包序号，并向发送方发出自己的确认信息。</p>
<p>这种方式的弊端在于失序数据的丢弃。</p>
<p>假如发送方一口气发送了N个包，恰巧第一个包坏了，其他都好的，由于接收端拒绝接受第一个坏的包，其他包也被丢弃了，只能重传所有的N个包。<br><del>或者，其实这N个包都好好的到了接收端，接收端返回了N个确认包。</del> emmm其实这里做的比较好，因为反回了N就代表N以及以前的都已经收到了。</p>
<h2 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h2><p>对上一小节最后提出的回退N步的弊端，在选择重传之中得到了解决。但是应该知道，功能的增强需要结构的复杂作为代价。</p>
<p>允许失序，接收方会对一些失序的包进行缓存。这样，确认接收的机制也需要进行修改、接收方也需要拥有一个缓存区来实现。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/94806677.jpg" alt=""></p>
<p>在这种方式中，其实在上一节最后说的那点优点是不可能存在了，因为需要选择重传，必然是选择确认。而且，每个分组都必须有自己的定时器，而不能像上面一样按最左来做定时器。</p>
<p>在发送端，base只能移动到没有已发送但未确认的最右。对于上图，发送端的绿色必定对应接收端的粉色或者无色，接收端的灰色必定对应发送端的黄色，在sendbase右边不可能有对应接收端灰色的色块。</p>
<p>发送方的动作与前面类似，只是需要将确认机制修改成单独确认，接收方的动作如下：</p>
<ol>
<li>如果收到了[recvbase,recvbase+N-1]内的包，是正常的，把收到的包的对应序号ACK，如果在这之内的某个包出了问题不用管，丢掉。如果等于recvbase了，就更新recvbase。（这也使得2.是必要的）</li>
<li>收到了[recvbase-N,recvbase-1]之内的包，可能是这之内的包已经被接收端ACK了，但是没有被发送端ACK，一定需要传一个ACK包给发送端，否则会使得sendbase无法前进。</li>
<li>其他情况忽略即可。</li>
</ol>
<p>情况2.也说明了为什么需要2*N个序号：</p>
<p>尴尬的情况：究竟是重复包还是新包？<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/59249922.jpg" alt=""></p>
<blockquote>
<p>在书中提到了<strong>分组重排</strong>，我不是十分理解：</p>
<p>分组重拍的一个表现是具有确认号x的旧副本可能会在网络中出现，即使现在发送端与接收端的窗口中可能都包含x。对于分组重排，信道可被基本看成是在缓存分组，并在将来的任意时刻自然地释放这些分组。因为序列号要被重用，所以这种情况要十分小心。<br>实际采用的一个方法是直到发送方确认网络中不会在存在x分组。这通过设置一个分组在网络中的最大存活时间来限定。<br>在高速网络的TCP扩展中，一般是3min。<br>[sunshine 1978]描述了一种使用序号的方法，可以使重新排序问题完全被避免。</p>
</blockquote>
<h1 id="端口与进程"><a href="#端口与进程" class="headerlink" title="端口与进程"></a>端口与进程</h1><p>最后，我需要补充一下端口号与进程之间的关系：</p>
<p>首先：缓冲区对应的是谁？在上一篇中就应该明确，是socket。</p>
<p><strong>端口号是什么？</strong></p>
<p>在网络技术中，端口大致有两种意思：一是物理意义上的端口，比如，ADSL Modem、集线器、交换机、路由器用 于连接其他网络设备的接口，如RJ-45端口、SC端口等等。二是逻辑意义上的端口，一般是指TCP/IP协议中的端口，端口号的范围从0到65535，比如用于浏览网页服务的80端口，用于FTP服务的21端口等等。我们这里将要介绍的就是逻辑意义上的端口。</p>
<p>服务器一般通过知名端口号来识别。例如，对于每个TCP/IP实现来说，FTP服务器的TCP端口号都是21，每个Telnet服务器的TCP端口号都是23，每个TFTP(简单文件传送协议)服务器的UDP端口号都是69。任何TCP/IP实现所提供的服务都用知名的1～1023之间的端口号。这些知名端口号由Internet号分配机构（InternetAssignedNumbersAuthority,IANA）来管理。</p>
<p>端口号的作用正是为了区分不同的网络服务。</p>
<p>上面的比较官方，下面将由我自己写的程序来——</p>
<p>TCP里面，一个端口号可以被多个socket绑定。而UDP不行，我的理解是数据不知道要给谁。</p>
<p>已经被绑定之后，再次要求绑定：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/88853868.jpg" alt=""></p>
<p>这是再次运行，也就是说，其实这个并不是一个进程不能绑定同一个端口号，而是两个UDP的socket不能绑定同一个端口。跟进程没有什么关系。fork子线程的时候，也可以使用其他的socket绑定其他的端口号。</p>
<p>端口这个概念就是计算机网络领域的概念，有网友直言说进程与端口号没有什么关系，其实是对的。</p>
<p><a href="http://wps.pearsoned.com/ecs_kurose_compnetw_6/216/55463/14198700.cw/index.html" target="_blank" rel="external">在本书配套的网站上有十分精致的动画介绍</a></p>
<p>这些都搞清楚了之后，<strong>TCP</strong>隆重登场~</p>
<p>thanks for ur help!</p>
<p>[1] <a href="http://www.cnblogs.com/BoyXiao/archive/2012/02/20/2359273.html" target="_blank" rel="external">进程与端口映射</a></p>
<p>[2] <a href="https://baike.1688.com/doc/view-d2361261.html" target="_blank" rel="external">端口号是什么？</a></p>
<p>[3]<a href="https://www.ibm.com/support/knowledgecenter/zh/SSGMGV_3.2.0/com.ibm.cics.ts.internet.doc/topics/dfhtl2d.html" target="_blank" rel="external">IBM Knowledge Center</a>  这个有很多东西，不止端口号</p>
]]></content>
      
        <categories>
            
            <category> 计算机网络 </category>
            
            <category> 大三的课 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络课 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[覆千秋1]]></title>
      <url>/2017/11/03/%E8%A6%86%E5%8D%83%E7%A7%8B1/</url>
      <content type="html"><![CDATA[<h1 id="夜色凉"><a href="#夜色凉" class="headerlink" title="夜色凉"></a>夜色凉</h1><p>将军府的海棠开了。</p>
<p>粉粉嫩嫩，一簇一簇的，细风吹来，花朵轻轻落在地上，把这个小园衬出几分诗意。</p>
<p>只是府上光景却不如这海棠繁盛。</p>
<a id="more"></a>
<p>前日里前线传回来消息，说是这宅院的主人被俘了。被俘了，是不要紧，要紧的是他帮着敌军截断了己方粮草，杀了一名副将。</p>
<p>皇帝知道之后龙颜大怒，直接下令封了将军府。<br>管你是真降还是假意。</p>
<p>大臣们都以为，功高盖主，老将军即使不降，回来也风光不了几日了，没差。</p>
<p>平民慷慨激昂，市面上的书里，茶馆里，甚至风月里都是对老将军叛国的不耻，这些模糊的面孔在舌灿莲花的时候，选择性的忘记了老将军当年战绩的辉煌。</p>
<hr>
<h2 id="当街月色应如水"><a href="#当街月色应如水" class="headerlink" title="当街月色应如水"></a>当街月色应如水</h2><p>“千霜——”，打扮精致的女人独自从廊中走来，在几步之外站定，唤。</p>
<p>坐在小亭中的女孩循着声音忽地回头，抬着脸叫：“娘——”。</p>
]]></content>
      
        <categories>
            
            <category> 我的故事 </category>
            
            <category> 枯骨流沙 </category>
            
            <category> 覆千秋 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 千霜 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机网络运输层之一]]></title>
      <url>/2017/11/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82%E5%B1%82%E4%B9%8B%E5%88%9D%E6%B6%89%E6%B1%9F%E6%B9%96/</url>
      <content type="html"><![CDATA[<blockquote>
<p>这些东西是很简单，可是想来想去还是决定记录一下，以免以后遇到像C++语法不知道一样的尴尬。</p>
</blockquote>
<h1 id="概述与运输层服务"><a href="#概述与运输层服务" class="headerlink" title="概述与运输层服务"></a>概述与运输层服务</h1><p>运输层的协议提供的是<strong>逻辑通信</strong>，并不是直接相连的。</p>
<p>现在我们聊的是<strong>对等层通信</strong>，本机的运输层发数据给其他机器的运输层。运输层协议在端系统里面，并不是在路由器里。</p>
<p>实际上，当应用程序希望能与其他设备进行通信，调用运输层，给运输层一堆信息。运输层可能会把这些信息分段，然后加上头部信息成为<strong>报文段</strong>。报文段交给网络层，网络层再封装成<strong>数据报</strong>再向目的地发送。到了目的地之后做一个相反的动作，送给应用层使用。需要区分清楚的是，制定目的地、决定报文段怎么产生、决定报文段如何合并都是运输层的工作，网络层相当于送信的邮差，只负责传输。但是话又说回来了，网络层更加底层，网络层提供了怎样的服务、有多大的带宽都限制了运输层的服务。</p>
<p>现在<strong>因特网</strong>的运输层主要有两个协议：UDP、TCP。UDP是不可靠的、多目的地的、无序的传输；TCP是面向连接的可靠的传输。具体特性将在后面讲到。</p>
<p>因特网的网络层协议是IP协议（网际协议）。IP非常不可靠，他是<strong>尽力而为交付服务</strong>，一不确保报文段的交付，二不保证报文段交付的按序，三不保证报文段交付的完整性，被称为<strong>不可靠服务</strong>。</p>
<p>TCP与UDP的基本职责是将两个端系统之间的IP交付服务扩展为运行在两个端系统之上的两个进程之间的信息交付服务。将主机之间的交付扩展为进程之间的交付就是<strong>运输层的多路复用与多路分解</strong>。</p>
<h1 id="运输层的多路复用与多路分解"><a href="#运输层的多路复用与多路分解" class="headerlink" title="运输层的多路复用与多路分解"></a>运输层的多路复用与多路分解</h1><p>多路复用与多路分解服务是所有计算机网络都需要的。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/43018259.jpg" alt="复用与分解机制"></p>
<p>我们知道，实现运输层的服务需要借助于socket，一个进程可以对应一个或几个socket（？）。在send端，运输层在报文段中加了首部信息之后，把各进程产生的数据无差别的交给网络层；在rev端，运输层从网络层那里拿出数据，解析报文段的首部信息从而==定位socket==，把<strong>分解后的</strong>报文段信息给对应的socket。</p>
<p>为了实现这种服务，在首部信息里面一定封装有<strong>端口号</strong>。<br>端口号是一个16bit的数，在0-65535之间，其中0-1023的端口号是周知端口号，他们被保留给周知应用层协议来使用。一般来说，服务器端都是一个固定的端口号，而客户端则是随机分配。<br>关于端口号的更多信息，可以访问<a href="http://www.iana.org" target="_blank" rel="external">RFC 3232</a>获得。</p>
<h2 id="1-无连接的"><a href="#1-无连接的" class="headerlink" title="1. 无连接的"></a>1. 无连接的</h2><p>首先了解UDP的套接字标志方法：UDP的socket以一个二元组(dstaddr,dstport)来标识，与源信息无关。也就是说，虽与一个机器无论是从什么地方发送过来的数据，只要给的是同一个port，都将被同一个socket处理。这样，容易理解，在UDP中，每一个port会对应一个自己的缓冲区。</p>
<p>关于这个缓冲区，<del>UDP不可靠也会体现在这里</del>，在发送UDP包的时候不能过大，也是出于对缓冲区大小的考虑。如果新到来的包太大了、不能塞进缓冲区了，这个包会被直接抛弃。app层不会知道，只有通过发送端的超时重传机制对包进行重传。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/79842537.jpg" alt="UDP复用与分解机制"></p>
<h2 id="2-面向连接的"><a href="#2-面向连接的" class="headerlink" title="2. 面向连接的"></a>2. 面向连接的</h2><p>TCP的套接字标志方法与UDP不同，TCO使用(srcaddr,srcport,dstaddr,dstport)，这样，只有四个值都相同才会被定向到同一个socket，放到同一个缓冲区。</p>
<p>![<a href="http://oysmkdi7t.bkt.clouddn.com/17-11-4/6848958.jpg" target="_blank" rel="external">TCP复用与分解机制</a></p>
<blockquote>
<p>这里只是简单一提：关于安全性的问题。攻击者可以利用在某个端口监听的有缺陷的应用程序攻陷目的主机。我不了解安全，这里只是复述了《自顶向下方法》中的解释。</p>
<p>使用<a href="http://nmap.org" target="_blank" rel="external">nmap</a>既可以扫描到<strong>因特网</strong>中任一台主机，顺序的扫描主机的各个端口，对TCP/UDP，寻找能接收TCP连接/能对UDP报文段进行处理的端口号，并返回打开的、关闭的、不可达的端口号列表。</p>
</blockquote>
<h2 id="3-Web-Server与TCP"><a href="#3-Web-Server与TCP" class="headerlink" title="3. Web Server与TCP"></a>3. Web Server与TCP</h2><p>其实没什么新东西，列举：</p>
<ol>
<li><p>连接套接字与进程之间并非一一对应的关系。先进的高性能Web server只有一个进程，但是为每一个连接的<strong>新客户</strong>（不是客户机喔）创建一个新的线程。</p>
</li>
<li><p>非持续HTTP会严重影响web server的性能。（在应用层中涉及），有些OS技巧可以减轻这个问题的影响。（参见[Nielsen 1997,Nahum 2002]）</p>
</li>
</ol>
<p>他的复用与分解是这样的：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/41975538.jpg" alt="Web"></p>
]]></content>
      
        <categories>
            
            <category> 计算机网络 </category>
            
            <category> 大三的课 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络课 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[the One使用记录]]></title>
      <url>/2017/11/01/the%20One%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%951/</url>
      <content type="html"><![CDATA[<blockquote>
<p>一个小tip：使用linux命令行进入带空格的文件，如果直接cd filename进入的话是不行的，那应该怎么进入呢？</p>
<p><strong>cd “filename”就好啦</strong>！</p>
<p>又一个小tip：不下心关掉了eclipse的项目工程目录怎么办？</p>
<p><strong>Window-&gt;Show View-&gt;Others-&gt;General-&gt;Project Explorer</strong></p>
<p>emmm，markdown行内代码形式：``包起来就行</p>
</blockquote>
<h1 id="从github下载the-one"><a href="#从github下载the-one" class="headerlink" title="从github下载the-one"></a>从github下载the-one</h1><p>犹记我初学git的时候也是傻傻的，这里就放出来具体操作方法了！</p>
<p>首先需要一个GitBash。在gitbash里使用cd命令进入想存放the one的文件夹，然后输入命令：<code>git clone https://github.com/akeranen/the-one.wiki.git</code>，前面两个是命令，最后一个是参数，代表的是这个仓库的地址。这个下载下来的是master….应该是不行的….下载v1.6吧。</p>
<p>等到完成之后就会发现在这个文件夹下面多了好多东西呀！</p>
<p>done！</p>
<h1 id="将项目import进Eclipse并运行"><a href="#将项目import进Eclipse并运行" class="headerlink" title="将项目import进Eclipse并运行"></a>将项目import进Eclipse并运行</h1><p>eclipse，使用java的孩子应该没有不知道的吧。哦对，the one是java代码编写。</p>
<p>到了这一步就出了一点小问题…一直是使用eclipse的File-&gt;import功能向workspace导入外部的项目的，导入the one的时候竟然告诉我未找到项目文件！<br>我尝试使用File-&gt;Open Project From FileSystem来，这次可以了。the one 成功出现在了project explorer里面！但是！有错误！</p>
<p>这个应该在说明文档里面说了，1.1以后版本的java要编译theone需要添加一些liabrary到项目的build path，但是我看了我的build path，已经添加了呀？怎么还有错？</p>
<p><a href="https://stackoverflow.com/questions/1089904/access-restriction-on-class-due-to-restriction-on-required-library" target="_blank" rel="external">click here</a></p>
<p>在上述网站，第二个回答解决了这个问题。由于JUnit3.0与4.0都在，我就都删除了，然后重新添加了JUnit4.0.done！</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-5/63641143.jpg" alt=""></p>
<p>如图，现在整个项目都已经没有错误了！</p>
<p>选择整个项目，右击Run As-&gt;JUnit Test成功！</p>
<p>the one涉及到了JUnit，如果不了解JUnit，需要先了解一下~</p>
<p><a href="">click here~ JUnit之一</a></p>
<p>在我以JUnit Test来运行时，theone出现了两个fail。这表明….可能是有bug的啊….<strong>mark</strong></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-5/23371918.jpg" alt=""></p>
<p><del>好吧，我先忽略了，</del> 然后 run了下（主类是core.DNTSim），发现其实可以出来东西。由于可能需要命令行参数，我又使用cmd来编译运行，结果…<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-5/5185150.jpg" alt=""></p>
<p>但是eclipse成功了呀？我找到了一个在eclipse设置命令行参数的方法，企图先跳过jdk版本带来的（？）编译问题。</p>
<p><a href="https://www.netlab.tkk.fi/tutkimus/dtn/theone/javadoc_v11/core/DTNSim.html" target="_blank" rel="external">DTNSim的API</a></p>
<p>Run-&gt;Run Configurations-&gt;DTNSim-&gt;Argumets:加上你想要的参数。即可：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-5/68381775.jpg" alt=""></p>
<p>好了，至此，程序初步可以运行使用了。</p>
<h1 id="解决问题时间"><a href="#解决问题时间" class="headerlink" title="解决问题时间"></a>解决问题时间</h1><hr>
<p>好的，现在是解决问题时间啊。</p>
<p>询问了老师，老师说这个可能是JUnit包加载不正确。但是我重新写了一个工程，使用一样的方法，那个是没错的。</p>
<p>所以我想是不是版本问题。</p>
<p>于是我下载了v1.6。使用同样的方法import进来，这次错误更多！<br>但是我发现这次最初是没有添加README里面说要自己添加的2个jar包的，所有感觉有希望！</p>
<p>添加jar包：</p>
<blockquote>
<p>Project右键-&gt; build path -&gt; configure build path-&gt;libraries-&gt;add jars-&gt;the-one-1.6.0-&gt;lib</p>
<p>好了，把这两个jar都添进来。</p>
<p>JUnit的添加方法还与上面一样，记得要添加的是4.0</p>
</blockquote>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/51953772.jpg" alt=""></p>
<p>没错了。</p>
<p>然后来测试一下。<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/45497488.jpg" alt=""></p>
<p>还有错:-)。</p>
<p>既然是有错的，那就只能一点一点分析是怎么回事了。</p>
<ol>
<li>首先，我又运行了1.6的compile，还是不行，这次我决定把电脑里面的jdk换成8。</li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/36756939.jpg" alt=""></p>
<p>如图，配置好的环境变量在cmd竟然没有更换！<br>这也是导致javac不能用的一个原因。<br>如果你确认自己配的环境变量肯定是对的，关掉cmd重新打开，就可以了。</p>
<p>环境变量配置应如下：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/16489027.jpg" alt=""><br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/44100075.jpg" alt=""><br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/61239558.jpg" alt=""><br>这次compile的结果。（jdk9不支持那个选项了？<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/64651101.jpg" alt=""><br>好了，这次使用one.bat也可以运行了。（jdk9：exm？？？</p>
<p>but….eclipse测试还是没过….<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/11070078.jpg" alt=""></p>
<hr>
<p>C:\ProgramData\Oracle\Java\javapath</p>
<h1 id="了解运行方法与配置信息"><a href="#了解运行方法与配置信息" class="headerlink" title="了解运行方法与配置信息"></a>了解运行方法与配置信息</h1><p>将参数设置为：[-b times] [ur conf_files]</p>
<p>-b后必须跟一个数字，这个数字表示simulation将会在batch mode（批处理）下运行，不会出现可视化界面，而是打印信息。后面的数字代表运行次数或者是num1:num2的形式来确定一个范围。</p>
<p>conf_files是一系列你自己写的conf file的文件名，数量任意。如果没有这个参数，会使用default_setting.txt。需要注意的是，如果多个conf设计同一个属性，那么在后面的设定将会覆盖前面的设定。</p>
<h2 id="Conf文件"><a href="#Conf文件" class="headerlink" title="Conf文件"></a>Conf文件</h2><blockquote>
<p>以下译自<a href="https://github.com/akeranen/the-one/wiki/README" target="_blank" rel="external">README</a></p>
</blockquote>
<p>所有的模拟参数都是通过cond文件给出的。conf文件就是普通的txt文件，在文件里有一些ket-value对。大多数变量的语法都是：<code>Namespace.key = value</code><br>例如：key的前缀是namespace命名空间，然后加一个.点，然后是key的名字。key和value被等于号=隔开。命名空间需要以<strong>大写字母</strong>开头，而且namespace和key都以CamelCase方式命名，大小写敏感。namespace宽松地定义了设置影响的某部分模拟环境simulation environment。许多（并非所有）namespace的名字与正在读的class的名字一样。特别是动作模块(movement models)，报告模块(report modules)以及路由模块(routing modules)遵照了这个习惯。有时namespace被用户定义，eg：使用网络接口，用户可以选择任何标识符，在该名称空间中定义特定于接口的设置，并在配置每个组应使用的接口时给出名称空间的名称。</p>
<p>数字可以使用.作为小数点，可以使用kilo(k)，mega(m)，giga(G)作为后缀。bool接受”true”,”false”,”0”,”1”。</p>
<p>许多设置确定了寻找外部文件的路径。路径可以是绝对路径也可以是相对路径，但是路径的分隔符必须是”/“。Unix与Windows都是。</p>
<p>有些变量包含以逗号隔开的值，对他们来说，语法是：<code>Namespace.key = value1,value2,etc.</code></p>
<p>对于运行索引（run-indexed）值，语法是：<code>Namespace.key=[runvalue;run2value;run3value;etc]</code>。每一个runvalue可以是一个被逗号分隔的值。</p>
<p>设置文件可以有注释，以#开头。</p>
<p>一些值（scenario and report names at the moment）支持”value filling”。有这个特性做支撑，可以从设置的值动态地构造，例如，scenario name。这在使用run-indexing的时候非常有用。Just put setting key names in the value part prefixed and suffixed by two percent (%) signs. These placeholders are replaces by the current setting value from the configuration file. See the included snw_comparison_settings.txt for an example. 这个机制像是：<br>比如，完善java的环境变量的时候：<br>JAVA_HOME=C:/Program Files/Java/<br>path=%JAVA_HOME%jre/…”</p>
<p>default_settings.txt这个文件，如果它存在，在运行的时候一定会被read。此后给的文件可以在此基础上设置更多的东西，也可以覆盖掉默认设置的一些定西。</p>
<h2 id="Run-indexing"><a href="#Run-indexing" class="headerlink" title="Run indexing"></a>Run indexing</h2><p>run index可以让你只使用一个conf文件就能运行很多个不同的配置configuration，方法是，你提供一个setting的数组，为在不同的conf文件之间需要改变的变量。例如：如果想用5个不一样的随机数生成器种子来生成movment models来运行模拟器，那么你可以这样define设置文件：<br><code>MovementModel.rngSeed = [1;2;3;4;5]</code><br>现在，你使用参数-b 5 my_config.txt运行。</p>
<p>warp-around：类似于OS里面的。也就是说：used values is the value at index (runIndex%arrayLength)。这样，就可以很轻易的运行很多排列。</p>
<h1 id="模块们"><a href="#模块们" class="headerlink" title="模块们"></a>模块们</h1><h2 id="Movement-models"><a href="#Movement-models" class="headerlink" title="Movement models"></a>Movement models</h2><p>在模拟中，运动模型控制着节点的运动。运动模型提供了coordinates坐标、速度、停顿时间。基本的安装包括：random waypoint,map based movement,shorest path map based movement,map route movement,external movement。除了external的所有这些运动模型，都有可控的速度以及停顿时间分布。可以给出最大值以及最小值，运动模型使得值在给定返回之间uniformly distributed均匀分布。在external里面，速度以及停顿时间都由文件中的给定值解释执行（interpreted）。</p>
<p>如果一个节点使用了随机航点运行模型（random waypoint:RandomWaypoint），这个节点在模拟区中被给予一个随机的坐标。节点直接以恒定的速度到达给定的目的地，然后停顿一段时间，然后获得新的目的地。这个过程在整个模拟的过程中持续进行，节点在这些zig-zag（蜿蜒的）路径上走</p>
<p>基于地图的运动模型将节点的运动限制在预先定义好的路径上。可以定义不一样的路径，可以定义对全体节点都有效的路径。这样的话，比如说，汽车才不会直接开进门里或者是开到人行道上。</p>
<p>基本的基于地图的运动模型（map-based:MapBasedMovement）初始时把节点们分布在两个相邻的地图节点之间，然后节点们开始运动，从一个adjacent map node到另一个。当节点到达下一个地图节点的时候，他随机选择下一个节点。但是只有当这是唯一的选项（即，避免回到它来自的地方）时才选择它来自的地图节点。一旦节点移动了10-100个地图节点，它暂停一段时间，然后再次开始移动。 </p>
<p>更加复杂的版本的基于地图的运动(ShortestPathMapBasedMovement)使用了Dijkstra的最短路径算法来寻找他在整个地图范围内的路径。一旦一个节点到达了他的目的地，他等一段时间，选择下一个随机的地图节点，用最短路径走过去。<br>（这个算法只对valid map nodes起作用）</p>
<p>对于基于最短路径的运动模型，地图的数据信息还包括POIs（point of interests）。instead of为下一个目的地选择任意随机地图节点，移动模型可以被配置为以可配置的概率给出属于某个POI组的POI。可以有无限数量的POI组，并且所有组可以包含任何数量的POI。所有节点组对于所有POI组可能具有不同的概率。<br>POI可以用来模拟例如商店，餐馆和旅游景点。</p>
<p>基于路线的运动模型（MapRouteMovement）可以用于对遵循特定路线的节点建模。（例如，公共汽车或电车线路。）只需要定义路线上的停靠点，然后使用该路线的节点就会经由最短路径，从一个站点到另一个站点，并在每一个stop停留设置好的时间。</p>
<p>所有的运动模型都可以决定什么时候节点是活跃的（他运动，可以被连接），什么时候不活跃。所有模型，除了external，可以给出多个时间间隔（time interval），在那个组的节点只会在那些时候比较活跃。</p>
<p>所有基于地图的运动模型都通过（WKT）格式的一个子集所规范的文件中获取输入信息。映射路径数据的解析器支持WKT文件的LINESTRING和MULTILINESTRING指令。对于点数据（例如POI），也支持POINT指令。 （MULTI）LINESTRING中的相邻节点被认为形成一个路径，并且如果某些行包含一些具有完全相同坐标的顶点，<br>路径从这些地方加入（这是如何创建交叉点）。 WKT文件可以使用任何合适的地理信息系统（GIS）程序从现实世界的地图数据进行编辑和生成。包含在模拟器发行版中的地图数据使用免费的基于Java的OpenJUMP GIS程序进行转换和编辑。</p>
<p>不一样的地图可以通过在不同的文件中存储属于不同类型的路径来定义。POIs简单的用WTK POINT定义，而POI组通过将所有的属于同一个组的POIs存储在同一个文件中来定义。所有的POI也必须是地图数据的一部分，所以他们可以使用路径进行访问。用LINESTRING定义路线的停靠点，停靠点按照它们在LINESTRING中出现的顺序进行遍历。一个WKT文件可以包含多个路由，并按照它们在文件中出现的顺序将它们提供给节点。</p>
<p>使用外部移动数据（ExternalMovement）的实验移动模型从文件读取时间戳节点位置，并相应地移动模拟中的节点。有关格式的详细信息，请参阅输入包中的ExternalMovementReader类的javadocs。一个合适的实验转换器脚本（transimsParser。<br>pl）的TRANSIMS数据包含在toolkit文件夹中。</p>
<p>要使用的运动模型是使用“movementModel”设置为每个节点组定义的。设置的值必须是movement包中的有效运动模型类别名称。<br>在MovementModel类中读取所有运动模型通用的设置，并在相应的类中读取运动模型特定的设置。有关详细信息，请参阅javadoc文档和示例配置文件。</p>
<h2 id="路由模块以及消息的创建"><a href="#路由模块以及消息的创建" class="headerlink" title="路由模块以及消息的创建"></a>路由模块以及消息的创建</h2><p>路由模块定义了在模拟中消息如何被处理。6个基本主动路由模块（First Contact,Spray and Wait,Direct delivery, PRoPHET and MaxProp），一个被动路由用于外部路由的模拟。主动路由模块是用于DTN路由的众所周知的路由算法的实现。也有这些模型的变体和包含在最新版本中的几个不同的模型。有关详细信息，请参阅路由程序包中的类。</p>
<p>被动路由器专门用于与其他（DTN）路由仿真器交互或运行仿真，而不需要任何路由功能。路由器除非由外部事件命令，否则不执行任何操作。这些外部事件由实现EventQueue接口的类提供给模拟器。</p>
<p>有两个基本的类可以用作消息事件的来源：ExternalEventsQueue和MessageEventGenerator。前者可以用一个合适的脚本（例如，toolkit文件夹中的createCreates.pl脚本）或通过将例如dtnsim2的输出转换成合适的形式来从手动创建的文件中读取事件。<br>有关格式的详细信息，请参阅输入包中的StandardEventsReader类。 MessageEventGenerator是一个简单的消息生成器类，它创建具有可配置消息创建间隔，消息大小和源/目标主机范围的均匀分布的消息创建模式。<br>可以使用MessageBurstGenerator和One {From，To} EachMessageGenerator类创建更具体的消息传递场景。有关详细信息，请参阅javadocs。</p>
<p>该toolkit文件夹包含一个用于dtnsim2输出的实验解析器脚本（dtnsim2parser.pl）（曾经是一个更强大的基于Java的解析器，但是由于这个更容易扩展的脚本而被丢弃）。该脚本需要dtnsim2的代码的一些补丁，可以从toolkit / dtnsim2patches文件夹中找到。<br>要使用的路由模块是按设置“路由器”的每个节点组定义的。所有路由器都不能正常交互（例如，PRoPHET路由器只能与其他PRoPHET路由器一起工作），所以通常对所有组使用相同（或兼容）路由器是有意义的。</p>
<h1 id="报告"><a href="#报告" class="headerlink" title="报告"></a>报告</h1><p>可以使用<strong>报告</strong>创建模拟运行的摘要数据，连接和消息的详细数据，适合使用例如Graphviz进行后处理的文件（创建图表）以及与其他程序接口。有关详细信息，请参阅报告包类的javadocs。</p>
<p>对于任何模拟运行可以有任意数量的报告，并且使用“Report.nrofReports”设置来定义要加载的报告的数量。报告类别名称使用“Report.reportN”设置定义，其中N是从1开始的整数值。设置的值必须是来自报告包的有效报告类别名称。<br>所有报告的输出目录（可以使用“输出”设置对每个报告类别重写）必须使用Report.reportDir -setting进行定义。如果报告类别未提供“输出”设置，则生成的报告文件名称为“ReportClassName_ScenarioName.txt”。</p>
<p>所有报告都有许多可配置的设置，可以使用ReportClassName.settingKey -syntax来定义。有关详细信息，请参阅Report类的javadocs和特定报告类（查找“设置id”定义）。</p>
<h1 id="主机组"><a href="#主机组" class="headerlink" title="主机组"></a>主机组</h1><p>一个host group是一组分享同样的运动和路由设置的主机。不同的组的设置值不一样，这样的话，它们可以表示不同类型的节点。可以在“组”（Group）命名空间中定义基本设置，不同的节点组可以覆盖这些设置或在其特定的命名空间（组1，组2等）中定义新的设置。</p>
<h1 id="the-settings"><a href="#the-settings" class="headerlink" title="the settings"></a>the settings</h1><p>有很多设置可以被设置。非常多，这里不提了。有关详细信息，请参阅类，尤其是report，routing和movement class的javadoc。另请参阅包含设置文件的示例。也许最重要的设置如下。</p>
<h2 id="脚本设置（Scenario-setting）"><a href="#脚本设置（Scenario-setting）" class="headerlink" title="脚本设置（Scenario setting）"></a>脚本设置（Scenario setting）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Scenario.name</div><div class="line"></div><div class="line"> <span class="comment">//脚本的名字，所有报告默认以此为前缀</span></div><div class="line"></div><div class="line">Scenario.simulateConnections </div><div class="line"></div><div class="line"><span class="comment">//connection是否应该被模拟。如果只对运动模型感兴趣，这个可以被disable，以获得更快的模拟速度。通常情况下，是enable的。</span></div><div class="line"></div><div class="line">Scenario.updateInterval </div><div class="line"></div><div class="line"><span class="comment">//每次更新时需要几秒。增加数值使模拟更快，但是可能以精度损失为代价。0.1-2 are good</span></div><div class="line"></div><div class="line">Scenario.endTime </div><div class="line"></div><div class="line"><span class="comment">//How many simulated seconds to simulate.</span></div><div class="line"></div><div class="line">Scenario.nrofHostGroups </div><div class="line"></div><div class="line"><span class="comment">//现在在模拟中有几个hosts group</span></div><div class="line"></div></pre></td></tr></table></figure>
<h2 id="接口设置（用来定义node可能会使用到的接口）"><a href="#接口设置（用来定义node可能会使用到的接口）" class="headerlink" title="接口设置（用来定义node可能会使用到的接口）"></a>接口设置（用来定义node可能会使用到的接口）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">type <span class="comment">//这个接口使用了什么类（来自接口目录）</span></div><div class="line"></div><div class="line"><span class="comment">//其余设置是特定于类的。可以是例如：</span></div><div class="line"></div><div class="line">transmitRange <span class="comment">//接口范围（meters）</span></div><div class="line"></div><div class="line">transmitSpeed <span class="comment">//接口的传输速度（bytes per second）</span></div></pre></td></tr></table></figure>
<h2 id="主机组设置（在Group或GroupN的命名空间使用）"><a href="#主机组设置（在Group或GroupN的命名空间使用）" class="headerlink" title="主机组设置（在Group或GroupN的命名空间使用）"></a>主机组设置（在Group或GroupN的命名空间使用）</h2>]]></content>
      
        <categories>
            
            <category> 计算机网络 </category>
            
            <category> 实验室 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 实验室 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 模拟器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[实验室心情全记录]]></title>
      <url>/2017/11/01/CN1/</url>
      <content type="html"><![CDATA[<p>又一个小时过去了呢。</p>
<p>第一个看到的文档是：《移动P2P网络中协同缓存的研究》，这个比较浅显比较傻，不是我需要的，主要讲的是一些显而易见的理想化的缓存策略，并没有涉及到一个复杂网络。主要讲的是缓存的接入控制策略：什么东四能进缓存？缓存替换策略以及缓存的一致性。</p>
]]></content>
      
        <categories>
            
            <category> 计算机网络 </category>
            
            <category> 实验室 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 实验室 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2017/11/01/Cloud%20RAN%20for%20Mobile%20Networks%E2%80%94%E2%80%94A%20Technology%20Overview/</url>
      <content type="html"><![CDATA[<hr>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>移动数据的传输容量正在连续增加。根据Cisco的预测，在智能手机与穿戴设备的推动下，从2012到2017年容量将增长13-fold。因此，移动网络运营商需要增加网络的capacity来满足日益增长的用户需求。当LTE（long term evolution）的spectral efficiency标准正逼近Shanon极限，增加网络capacity的最好方法要么是增加基站覆盖区域，创建一个结构复杂的多元小基站网络（HetSNets）要么是使用像多用户多输入多输出（MIMO）或是Massive MIMO这样的多根天线在同一频率时段服务于多个用户的技术。然而，这将导致更大的的小基站区间干扰水平（Growing inter-cell interference levels）以及更多的花费。</p>
<p>移动网络的TCO（total cost of ownership）包括了CAPEX（CAPital Expenditure）和OPEX（OPerating EXpenditure）。capex主要指关于网络构建的花费，网络构建可能会从网络规划一直到网址需求，RF硬件，baseband硬件（基带），软件许可，leased line连接（专用网络连接），安装，civil cost（民用花费），网站支持，像供电或者是冷却（cooling）。OPEX包括需要去操纵网络的花费，比如，站点出租，专用网络，电力，运营与保持，升级。CAPEX与OPEX在更多base station被部署之后都显著增加了。更具体地说（more specifically），CAPEX增加是因为基站是无线网络infrastructure基础设施中最昂贵的组成成分，而OPEX增加是因为基站覆盖区需要相当多的电力去驱动，比如，中国移动估计有72%的电力花费在基站覆盖区域（cell sites）。移动网络运营商需要支付网络建造，运营，保持和升级的费用；同时人均收入（ARPU）随之时间的增长保持不变甚至有所下降，因为典型的用户对数据的需求越来越多却希望为移动流量付更少的费用。像图1中所示，如果补救措施，移动网络运营商将有可能面对入不敷出的局面。 因此，在移动网络领域，优化了花费和能源消耗的新型建构方式变得必需。</p>
<p>C-RAN是一种新型的移动网络结构，有着接受上述所有挑战的能力。这个概念最初在论文9中被提出并且在6中被详细描述。在C-RAN中，baseband processing（基带处理）被中心化，被被放在一个虚拟的BBU pool中被诸多site分享。这意味着它可能能够适应nonuniform traffic非均匀流量并更加有效率地利用一些资源，比如，基站。由于这个特性在C-RAN结构中将用到比传统结构更少的BBU，而且C-RAN还有降低网络运营费用的潜能，这是因为电力与能量的消耗相较于传统的RAN结构已经被减少了。新的BBU可以更轻易地被添加被升级，从而改善网络的稳定性并使得网络更容易被维护。虚拟化的BBU pool可以被多个不同的网络运营商所分享，允许他们通过云服务来租RAN。由于多个网站的BBU在同一个pool中co-located（协作），他们彼此之间可以以更小的延迟时间进行通信，这样，被介绍给LTE-Advanced来增加spectral efficiency和throughput吞吐量的机械装置，比如说增强版的ICIC与CoMP都被facilitated，在两个基站覆盖区内实行的负载平衡方法也被facilitated。而且，网络的表现也被改善，例如通过减少BBU pool内部的移交操作的延时。<br>据China MObile Research Institute的猜想，C-RAN结构被移动网络运营商设为了目标，例如IBM、Alcatel-Lucent、华为、ZYTE、诺基亚西门子网络、Intel和Texas instruments。而且，在2020年的水平上来看，C-RAN被视为是典型的在5G中支持soft and green technologies的实现。然而，C-RAN并不是唯一可以对抗上述运营商们面临的挑战的选手，其他解决方式，包括small cells、being part of HetSNets and Massive MIMO。small cells的部署是户外hot spot闹区和室内coverage scenarios平均方案 。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[树莓派解析域名失败导致apt-get update不可用]]></title>
      <url>/2017/10/31/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%A7%A3%E6%9E%90%E5%9F%9F%E5%90%8D%E5%A4%B1%E8%B4%A5%E5%AF%BC%E8%87%B4apt-get%20update%E4%B8%8D%E5%8F%AF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>捣鼓了一下午，查了n多网站。从删除文件到修改源，终于发现一直提示解析域名失败的原因是树莓派没有连上网orz…<br>没有HDMI，我是通过树莓派的WiFi和电脑连上，电脑插了网线。<br>后来把网线给了树莓派，电脑连树莓派的WiFi，电脑直接跳出了学校网络的登录界面，在电脑上面登录之后，这次开始更新软件源。</p>
<a id="more"></a>
<p>除了这个，我还按照网上各路大神的说法，改了好几个地方，这里一一记下来，以便以后查找。</p>
<ol>
<li>删除某个目录的内容，只记得是/ect/apt/…/partial什么的</li>
<li>修改/etc/apt/resolv.conf的内容，数字改成8.8.8.8</li>
<li>修改源。据说给的源是国外源，速度慢。国内有很多源可用，网址如下：<a href="http://shumeipai.nxez.com/2013/08/31/raspbian-chinese-software-source.html" target="_blank" rel="external">http://shumeipai.nxez.com/2013/08/31/raspbian-chinese-software-source.html</a></li>
</ol>
<hr>
<p>除此之外，倒是了解了一些些关于远程与vnc。<br>实现这两者需要安装东西，并不是装了系统就可以连远程的。这个百度一下很多教程。</p>
<hr>
<p>另外是在Linux命令行下的vi(vim)与nano编辑器。<br>相较而言当然是nano好用。<br>用nano编辑/etc/apt/s文件命令：sudo nano /etc/apt/s<br>用vi编辑只需将nano改为vi<br>nano内有提示，只需按照提示来就好，而vi就比较复杂。<br><a href="http://shumeipai.nxez.com/2013/12/26/linux-on-vim-editor-tutorials.html" target="_blank" rel="external">http://shumeipai.nxez.com/2013/12/26/linux-on-vim-editor-tutorials.html</a><br>该网址内容详尽。注意的是，vi命令模式不是命令行界面，按下esc并不会有界面上的变化，并不是教程错了。</p>
<hr>
<p>Linux下的文件相关命令</p>
]]></content>
      
        
        <tags>
            
            <tag> OS </tag>
            
            <tag> 物联网 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[背包问题初涉]]></title>
      <url>/2017/10/31/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<hr>
<p>算法上机考试，怎么说，虽然没做出来但是收获很多？好吧也只能这么安慰自己了</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="comment">//硬币。存储硬币的价值及其对应个数</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coins</span>&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">true<span class="keyword">int</span> value;</div><div class="line">true<span class="keyword">int</span> num;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//更小值函数。若值为0，代表不可能，返回另一个值，否则返回更小值</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mini</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">true<span class="keyword">if</span> (a == <span class="number">0</span>)<span class="keyword">return</span> b;</div><div class="line">true<span class="keyword">if</span> (b == <span class="number">0</span>)<span class="keyword">return</span> a;</div><div class="line">true<span class="keyword">if</span> (a &gt; b)<span class="keyword">return</span> b;</div><div class="line">true<span class="keyword">else</span> <span class="keyword">return</span> a;</div><div class="line">&#125;</div><div class="line"><span class="comment">//int max(int a,int b)&#123;</span></div><div class="line"><span class="comment">//	if(a&gt;b)return a;</span></div><div class="line"><span class="comment">//	else return b;</span></div><div class="line"><span class="comment">//&#125;</span></div><div class="line"><span class="comment">//int comp(const void *a,const void *b)&#123;</span></div><div class="line"><span class="comment">//	Coins* A=(Coins*)a,*B=(Coins*)b;</span></div><div class="line"><span class="comment">//	if(A-&gt;value&gt;B-&gt;value)return -1;</span></div><div class="line"><span class="comment">//	else if (A-&gt;value&lt;B-&gt;value)return 1;</span></div><div class="line"><span class="comment">//	else return 0;</span></div><div class="line"><span class="comment">//&#125;</span></div><div class="line"><span class="comment">//找零钱的函数，coins存储了各种硬币的面值与个数，n是硬币种数（coins的长度），m是找零的钱数。</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetCoin</span><span class="params">(Coins*coins, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</div><div class="line"></div><div class="line">true<span class="comment">//新建一个二维数组用于存储在每一个要找的钱数下用i种硬币最少用几个硬币</span></div><div class="line"></div><div class="line">true<span class="keyword">int</span>**M = <span class="keyword">new</span> <span class="keyword">int</span>*[<span class="number">2</span>]; </div><div class="line">trueM[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span> [m + <span class="number">1</span>];</div><div class="line">trueM[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span> [m + <span class="number">1</span>];</div><div class="line"></div><div class="line">true<span class="comment">//初始时，用0个硬币找除0以外的钱数，不可能。</span></div><div class="line">true<span class="comment">//且用0作为初始值便于后续计算。</span></div><div class="line"></div><div class="line">true<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</div><div class="line">truetrueM[<span class="number">0</span>][i] = <span class="number">0</span>; M[<span class="number">1</span>][i] = <span class="number">0</span>;</div><div class="line">true&#125;</div><div class="line">true<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;	<span class="comment">//对前i种硬币</span></div><div class="line">truetrue<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;	<span class="comment">//要找j的零钱</span></div><div class="line">truetruetrue<span class="keyword">int</span> dola = M[<span class="number">0</span>][j];	<span class="comment">//保存未更新之前的值</span></div><div class="line">truetruetrue<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= coins[i].num; k++) &#123;	<span class="comment">//对这种硬币的每个数量</span></div><div class="line">truetruetruetrue<span class="keyword">if</span> ((j - k*(coins[i].value) &lt; <span class="number">0</span>)) &#123;	<span class="comment">//若k个硬币总钱数大于j，不可能。break</span></div><div class="line">truetruetruetruetrueM[<span class="number">0</span>][j] = M[<span class="number">0</span>][j]; M[<span class="number">1</span>][j] = M[<span class="number">0</span>][j]; <span class="keyword">break</span>;</div><div class="line">truetruetruetrue&#125;</div><div class="line"></div><div class="line">truetruetruetrue<span class="keyword">if</span> ((M[<span class="number">0</span>][j - k*(coins[i].value)] != <span class="number">0</span>))</div><div class="line"></div><div class="line">truetruetruetrue<span class="comment">//否则。若满足条件，说明在M[0][j-k*(coins[i].value)]处有满足条件的解，与M[0][j]计算更好的值。此时这里一定有非0解</span></div><div class="line"></div><div class="line">truetruetruetruetrueM[<span class="number">0</span>][j] = mini(M[<span class="number">0</span>][j], k + M[<span class="number">0</span>][j - k*(coins[i].value)]);</div><div class="line">truetruetruetrue<span class="keyword">else</span> <span class="keyword">if</span> ((M[<span class="number">0</span>][j - k*(coins[i].value)] == <span class="number">0</span>)) &#123;<span class="comment">//否则，不一定存在非0解</span></div><div class="line">truetruetruetruetrue<span class="keyword">if</span> (k*(coins[i].value) == j) &#123;<span class="comment">//若存在k个硬币正好找j元，更新解</span></div><div class="line">truetruetruetruetruetrueM[<span class="number">0</span>][j] = mini(M[<span class="number">0</span>][j], k);</div><div class="line">truetruetruetruetruetrue<span class="comment">//M[1][j] = M[0][j];</span></div><div class="line">truetruetruetruetruetrue<span class="comment">//M[0][j] = dola;</span></div><div class="line">truetruetruetruetruetrue<span class="comment">//break;不行！</span></div><div class="line">truetruetruetruetrue&#125;</div><div class="line">truetruetruetruetrue<span class="keyword">else</span> M[<span class="number">0</span>][j] = M[<span class="number">0</span>][j];<span class="comment">//否则，不更新解</span></div><div class="line">truetruetruetrue&#125;</div><div class="line">truetruetruetrue</div><div class="line">truetrue&#125;</div><div class="line">truetruetrue<span class="comment">//将M[0]转移到M[1]，M[0]恢复原值继续下一轮计算。这样可以防止对硬币i使用的数目多于现有数目的情况</span></div><div class="line"></div><div class="line">truetruetrueM[<span class="number">1</span>][j] = M[<span class="number">0</span>][j];</div><div class="line">truetruetrueM[<span class="number">0</span>][j] = dola;</div><div class="line"><span class="comment">//			cout &lt;&lt; M[1][j] &lt;&lt; " ,";</span></div><div class="line">truetrue&#125;</div><div class="line">truetrue<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++)M[<span class="number">0</span>][j] = M[<span class="number">1</span>][j];<span class="comment">//把新值给M[0]，进行对下一种硬币的分析。</span></div><div class="line">true<span class="comment">//	cout &lt;&lt; endl;</span></div><div class="line">true&#125;</div><div class="line"></div><div class="line">true<span class="keyword">return</span> M[<span class="number">0</span>][m];<span class="comment">//返回最优解</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//int Getcoin(int*coins,int m,int n,int**M,int**N)&#123;</span></div><div class="line"><span class="comment">//	int*resu = new int[n], *resunum = new int[n];</span></div><div class="line"><span class="comment">//	for(int i=0;i&lt;=m;i++)&#123;N[0][i]=0;</span></div><div class="line"><span class="comment">//	M[0][i]=0;&#125;</span></div><div class="line"><span class="comment">//	for(int i=0;i&lt;2;i++)&#123;N[i][0]=0;</span></div><div class="line"><span class="comment">//	M[i][0]=0;&#125;</span></div><div class="line"><span class="comment">//	for(int i=1;i&lt;=n;i++)&#123;</span></div><div class="line"><span class="comment">//		for(int j=1;j&lt;=m;j++)&#123;</span></div><div class="line"><span class="comment">//			//cout &lt;&lt; "the j" &lt;&lt; j &lt;&lt; endl;</span></div><div class="line"><span class="comment">//			if (coins[i - 1] &gt; j) &#123; M[1][j] = M[0][j]; N[1][j] = N[0][j];  &#125;</span></div><div class="line"><span class="comment">//			else&#123;</span></div><div class="line"><span class="comment">//				M[1][j]=max(M[0][j],coins[i-1]+M[0][j-coins[i-1]]);</span></div><div class="line"><span class="comment">//				if(M[1][j]==M[0][j])N[1][j]=N[0][j];</span></div><div class="line"><span class="comment">//				else if(M[1][j]==coins[i-1]+M[0][j-coins[i-1]]) N[1][j]=1+N[0][j-coins[i-1]];</span></div><div class="line"><span class="comment">//				else N[1][j] = N[0][j] &lt; N[0][j - coins[i - 1]] ? N[0][j] : 1+N[0][j - coins[i - 1]];</span></div><div class="line"><span class="comment">//		&#125;</span></div><div class="line"><span class="comment">//	&#125;</span></div><div class="line"><span class="comment">//		for (int j = 0; j &lt;= m; j++) &#123;</span></div><div class="line"><span class="comment">//			M[0][j] = M[1][j];</span></div><div class="line"><span class="comment">//			N[0][j] = N[1][j];</span></div><div class="line"><span class="comment">//			cout &lt;&lt; "(" &lt;&lt; M[0][j] &lt;&lt; "," &lt;&lt; N[0][j] &lt;&lt; ")";</span></div><div class="line"><span class="comment">//		&#125;</span></div><div class="line"><span class="comment">//		cout &lt;&lt;i&lt;&lt;" , "&lt;&lt;coins[i-1]&lt;&lt; endl;</span></div><div class="line"><span class="comment">//		resu[i - 1] = M[0][m];</span></div><div class="line"><span class="comment">//		resunum[i - 1] = N[0][m];</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//	&#125;</span></div><div class="line"><span class="comment">//	int min=-1;</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//	for (int i = 0; i &lt; n; i++) &#123;</span></div><div class="line"><span class="comment">////		cout &lt;&lt; "(" &lt;&lt; resu[i] &lt;&lt; "," &lt;&lt; resunum[i] &lt;&lt; ")";</span></div><div class="line"><span class="comment">//		if (resu[i] == m) &#123;</span></div><div class="line"><span class="comment">//			if (min == -1)min = resunum[i];</span></div><div class="line"><span class="comment">//			if (resunum[i] &lt; min)min = resunum[i];</span></div><div class="line"><span class="comment">//		&#125;</span></div><div class="line"><span class="comment">//	&#125;</span></div><div class="line"><span class="comment">//	return min;</span></div><div class="line"><span class="comment">//	</span></div><div class="line"><span class="comment">//&#125;</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">truetrue<span class="keyword">int</span> n;</div><div class="line">truetrue<span class="built_in">cin</span> &gt;&gt; n;</div><div class="line">truetrueCoins*coins = <span class="keyword">new</span> Coins[n];</div><div class="line">truetrue<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">truetruetrue<span class="built_in">cin</span> &gt;&gt; coins[i].value &gt;&gt; coins[i].num;</div><div class="line">truetrue&#125;</div><div class="line">truetrue<span class="keyword">int</span> m;</div><div class="line">truetrue<span class="built_in">cin</span> &gt;&gt; m;</div><div class="line"></div><div class="line">truetrue<span class="comment">//如果要找的钱数是0，最少需要0个硬币</span></div><div class="line">truetrue<span class="keyword">if</span> (m == <span class="number">0</span>) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>; <span class="keyword">return</span> <span class="number">0</span>; &#125;</div><div class="line">truetrue<span class="comment">//	qsort(coins,n,sizeof(coins[0]),comp);</span></div><div class="line">truetrue<span class="comment">//	int sum=0;</span></div><div class="line">truetrue<span class="comment">//	for(int i=0;i&lt;n;i++)</span></div><div class="line">truetrue<span class="comment">//		sum+=coins[i].num;</span></div><div class="line">truetrue<span class="comment">//	int*Mycoin=new int[sum];</span></div><div class="line">truetrue<span class="comment">//	int soum=sum;</span></div><div class="line">truetrue<span class="comment">//	sum=coins[0].num;</span></div><div class="line">truetrue<span class="comment">///*	for(int i=0,j=0;i&lt;soum;i++)&#123;</span></div><div class="line">truetrue<span class="comment">//		if(i==sum)&#123;sum+=coins[j+1].num;j++;&#125;</span></div><div class="line">truetrue<span class="comment">//		Mycoin[i]=coins[j].value;</span></div><div class="line">truetrue<span class="comment">//		cout &lt;&lt; Mycoin[i] &lt;&lt; " ";</span></div><div class="line">truetrue<span class="comment">//	&#125;*/</span></div><div class="line">truetrue<span class="comment">//		int k = 0;</span></div><div class="line">truetrue<span class="comment">//		for (int i = 0; i&lt;n; i++) &#123;</span></div><div class="line">truetrue<span class="comment">//			for (int j = 0; j &lt; coins[i].num;j++) &#123;</span></div><div class="line">truetrue<span class="comment">//				Mycoin[k] = coins[i].value;</span></div><div class="line">truetrue<span class="comment">//				cout &lt;&lt; Mycoin[k] &lt;&lt; " ";</span></div><div class="line">truetrue<span class="comment">//				k++;</span></div><div class="line">truetrue<span class="comment">//			&#125;</span></div><div class="line">truetrue<span class="comment">//		&#125;</span></div><div class="line">truetrue<span class="comment">//		cout &lt;&lt; "totally" &lt;&lt; soum &lt;&lt; endl;</span></div><div class="line">truetrue<span class="comment">//		int**M=new int*[2];</span></div><div class="line">truetrue<span class="comment">//		for(int i=0;i&lt;2;i++)M[i]=new int[m+1];</span></div><div class="line">truetrue<span class="comment">//		int**N=new int*[2];</span></div><div class="line">truetrue<span class="comment">//		for(int i=0;i&lt;2;i++)N[i]=new int[m+1];</span></div><div class="line">truetrue</div><div class="line">truetruetrue<span class="comment">// pp=Getcoin(Mycoin,m,soum,M,N);</span></div><div class="line">truetruetrue<span class="comment">//cout &lt;&lt; pp &lt;&lt; endl;</span></div><div class="line"></div><div class="line">truetrue<span class="keyword">int</span> pp;</div><div class="line">truetruepp = GetCoin(coins, n, m);</div><div class="line">truetrue<span class="comment">//若最终返回0即为不可能，输出-1。</span></div><div class="line">truetrue<span class="keyword">if</span> (pp != <span class="number">0</span>)<span class="built_in">cout</span> &lt;&lt; pp;</div><div class="line">truetrue<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[归并、快排、堆排序]]></title>
      <url>/2017/10/31/%E5%BD%92%E5%B9%B6%E3%80%81%E5%BF%AB%E6%8E%92%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<hr>
<p>归并排序算法是分治策略的一种体现。所谓分治策略就是把一个大问题分解成几个较小的部分，通过递归分别解决几个小问题，然后再在线性时间内将几个小问题的解合并成一个完整的解。</p>
<hr>
<h2 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h2><p>归并排序也是一种排序算法。<br>问题：将n个数由从小到大地排序。<br>归并提出的解决是：</p>
<ol>
<li>将这列数分成两半</li>
<li>递归地将每一半排序</li>
<li>将两个有序列合并成一整列</li>
</ol>
<p>归并排序在做串的切分时不考虑大小因素，只从中间切分。于是在合并时便需要对两个有序串做一定处理才能保证结果串的有序性。<br>为此，一个容易想到的方法是创建一个临时的数组存储有序列。如图：</p>
<p><img src="http://img.blog.csdn.net/20170409215800372?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXVndXN0eV8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>每次都比较1串与2串当前位置元素大小，将较小的那一个输出到TMP数组中当前位置并加一，将输出串的当前位置加一。直到两个串都输出完毕。<br>这种方式所用的额外空间是O(n)，只需要O(n)次比较。</p>
<p>实际上，归并排序一般是递归进行一直到每个串的长度是1，主要运算过程全部落在合并上面。下面由递归式分析归并排序算法的时间复杂度。</p>
<p><strong>归并时间空间复杂度分析：</strong></p>
<p>设T(n)表示该算法在规模为n的输入实例上最坏的运行时间，假设n是2的整数次幂，可以得到递推公式如下：</p>
<p><img src="http://img.blog.csdn.net/20170409221537744?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXVndXN0eV8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="公式"></p>
<p>则有递推关系：</p>
<p><img src="http://img.blog.csdn.net/20170409222307354?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXVndXN0eV8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>将这些时间都加在一起即为nlog2N。即归并的时间复杂度是O(nlogn)级别。</p>
<p>下面将严格证明这个命题：</p>
<p>——————这个过程线省略————</p>
<p><strong>归并的代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Array.prototype.mergeSort=function(s,e,b)&#123;  </div><div class="line">  <span class="comment">//start,end,temp</span></div><div class="line">   <span class="keyword">if</span>(s==<span class="keyword">null</span>)s=<span class="number">0</span>;</div><div class="line">   <span class="keyword">if</span>(e==<span class="keyword">null</span>)e=<span class="keyword">this</span>.length-<span class="number">1</span>;</div><div class="line">   <span class="keyword">if</span>(b==<span class="keyword">null</span>)b=<span class="keyword">new</span> Array(<span class="keyword">this</span>.length);</div><div class="line">   <span class="keyword">if</span>(s&gt;=e)<span class="keyword">return</span>;</div><div class="line">   var m=(s+e)&gt;&gt;<span class="number">1</span>;  </div><div class="line">   <span class="comment">//取中间值</span></div><div class="line">   <span class="keyword">this</span>.mergeSort(s,m,b);</div><div class="line">   <span class="keyword">this</span>.mergeSort(m+<span class="number">1</span>,e,b);</div><div class="line">   <span class="keyword">for</span>(var i=s,j=s,k=m+<span class="number">1</span>;i&lt;=e;++i)</div><div class="line">      b[i]=<span class="keyword">this</span>[(k&gt;e||j&lt;=m&amp;&amp;<span class="keyword">this</span>[j]&lt;<span class="keyword">this</span>[k])?j++:k++];</div><div class="line">   <span class="keyword">for</span>(var i=s;i&lt;=e;++i)</div><div class="line">      <span class="keyword">this</span>[i]=b[i];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>快排提供的解决是：</p>
<ol>
<li>选择一个枢轴，小于枢轴的到左边，大于枢轴的到右边</li>
<li>对两边分别递归地使用快排</li>
<li>合并</li>
</ol>
<p>与归并相似的一点是，二者都采用递归方法解决问题，但是归并的排序工作都留在了合并过程中完成，而快排正与之相反，排序工作都在分割的过程中完成。</p>
<p><img src="http://img.blog.csdn.net/20170409232255961?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXVndXN0eV8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="KP"></p>
<p>从图中可以明显看出，快排最终得到的串就是一个有序的串。</p>
<p><strong>快排时间空间复杂度：</strong></p>
<p>快排算法依赖于枢轴PIVOT的选择。当选择的枢轴越接近中间值，树越接近于完全树的树高，算法效率越高，最好可达到O(nlogn)。糟糕的枢轴选择将会使效率急速下降，甚至达到O(n*n)的级别。<br>于是，当一个串越是接近于无序，快排的效率越高。快排的平均时间复杂度是O(nlogn)，是所有排序算法中平均时间复杂度最好的算法。<br>快排需要栈的辅助，其空间复杂度是O(logn)。</p>
<p><strong>快排的代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Array.prototype.quikSort=function(s,e)&#123;</div><div class="line">  <span class="comment">//start,end</span></div><div class="line">   <span class="keyword">if</span>(s==<span class="keyword">null</span>)s=<span class="number">0</span>;</div><div class="line">   <span class="keyword">if</span>(e==<span class="keyword">null</span>)e=<span class="keyword">this</span>.length-<span class="number">1</span>;</div><div class="line">   <span class="keyword">if</span>(s&gt;=e)<span class="keyword">return</span>;</div><div class="line">   <span class="keyword">this</span>.swap((s+e)&gt;&gt;<span class="number">1</span>,e);</div><div class="line">   var index=s-<span class="number">1</span>;</div><div class="line">   <span class="keyword">for</span>(var i=s;i&lt;=e;++i)</div><div class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>[i]&lt;=<span class="keyword">this</span>[e])</div><div class="line">         <span class="keyword">this</span>.swap(i,++index);</div><div class="line">   <span class="keyword">this</span>.quickSort(s,index-<span class="number">1</span>);</div><div class="line">   <span class="keyword">this</span>.quickSort(index+<span class="number">1</span>,e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><hr>
<p>堆排序数据结构结课的时候还考了呢。怕是写错了吧当时。哎陈年旧事，不提也罢。</p>
<p>  p又查到说，堆的建立过程就是不断插入的过程，所以可能根本不是完全建好了一个堆才去改变，也许是边建边改变。（有道云笔记你的markdown真的问题还很大</p>
<hr>
<p>堆是一种数据结构，可以看做是一棵任一孩子结点都小于（大顶堆）或都大于（小顶堆）父亲结点的完全二叉树。这样根结点总是整个堆中最大或小的结点，每次只需将根取出来即可保证有序。但是，每添加或减少一个结点都需要对堆进行必要的维护。<br>于是，堆排序中最关键的操作就是将一个序列调整成为堆。</p>
<p>堆排序给出的解决方法：</p>
<ol>
<li>将序列建成堆</li>
<li>迭代地取根进入有序队列并调整堆直到堆为有序序列</li>
</ol>
<p>堆的产生过程其实就是一个调整过程，下面给出堆的调整过程（以大根堆为例）：</p>
<p><img src="http://img.blog.csdn.net/20170410000407454?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXVndXN0eV8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>最终取出数字的顺序即为最终顺序。</p>
<p>堆排序适合于结点数较多情况下的要求前几个结点。当记录数较少时，不推荐使用堆排序。</p>
<p>hash表+堆排序是处理海量数据的绝佳组合。</p>
<p><strong>堆排序时间空间复杂度</strong></p>
<p>完全二叉树高度log(n+1)，即对每个节点进行调整的时间复杂度是O(logn)，包括建堆的时间耗费与取值和调整，整个算法时间复杂度是O(nlogn)。额外空间只有temp用来存取出的数，O(1)。</p>
<p><strong>堆排序的代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Array.prototype.heapSort=function()&#123;</div><div class="line">   <span class="keyword">for</span>(var i=<span class="number">1</span>;i&lt;<span class="keyword">this</span>.length;++i)&#123;</div><div class="line">      <span class="keyword">for</span>(var j=i,k=(j-<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;k&gt;=<span class="number">0</span>;j=k,k=(k-<span class="number">1</span>)&gt;&gt;<span class="number">1</span>)&#123;</div><div class="line">         <span class="keyword">if</span>(<span class="keyword">this</span>[k]&gt;=<span class="keyword">this</span>[j])<span class="keyword">break</span>;</div><div class="line">         <span class="keyword">this</span>.swap(j,k);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span>(var i=<span class="keyword">this</span>.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;--i)&#123;</div><div class="line">      <span class="keyword">this</span>.swap(<span class="number">0</span>,i);</div><div class="line">      <span class="keyword">for</span>(var j=<span class="number">0</span>;k=(j+<span class="number">1</span>)&lt;&lt;<span class="number">1</span>;k&lt;=i;j=k,k=(k+<span class="number">1</span>)&lt;&lt;<span class="number">1</span>)&#123;</div><div class="line">         <span class="keyword">if</span>(k==i||<span class="keyword">this</span>[k]&lt;<span class="keyword">this</span>[k-<span class="number">1</span>])--k;</div><div class="line">         <span class="keyword">if</span>(<span class="keyword">this</span>[k]&lt;=<span class="keyword">this</span>[j])braek;</div><div class="line">         <span class="keyword">this</span>.swap(j,k);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>本篇文章中的代码部分来自于作者twobin于网址<a href="http://www.cnblogs.com/twobin的博文《排序算法性能比较》。" target="_blank" rel="external">http://www.cnblogs.com/twobin的博文《排序算法性能比较》。</a></p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在MFC中创建控制台]]></title>
      <url>/2017/10/31/%E5%9C%A8MFC%E4%B8%AD%E5%88%9B%E5%BB%BA%E6%8E%A7%E5%88%B6%E5%8F%B0/</url>
      <content type="html"><![CDATA[<hr>
<p>距离上次写已经一周了。浑浑噩噩的愚人节，浑浑噩噩的一周。<br>但是依然要加油啊~要明确自己想要的是什么！开开心心地、充实地活着才最重要！<br>加油！</p>
<hr>
<p>我用的VS是2015版，之前找了一些在MFC中同时显示窗口与命令行的方法，我可以用的只记住了一个，先记录如下：</p>
<p>在×.cpp的InitInstance()中的CWinAPPEx::InitInstance()前加上以下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></div><div class="line">   AllocConsole()</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>以后可以使用_cprintf()打印字符串，需要在使用该函数的文件添加头文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;conio.h&gt;</span></span></div></pre></td></tr></table></figure>
<p><strong>切记！这个头文件必须要在#include”stdafx.h”语句之后写，否则会报错！</strong></p>
<p>使用步骤如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CString str=<span class="string">""</span>;</div><div class="line">USES_CONVERSION;</div><div class="line">LPSTR lp=T2A(str);</div><div class="line">_cprintf(lp);</div></pre></td></tr></table></figure>
<p>这段代码完成了将CString类型的str输出的任务。</p>
]]></content>
      
        
        <tags>
            
            <tag> MFC </tag>
            
            <tag> 可视化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux、Vim、Git常用命令——简明扼要版]]></title>
      <url>/2017/10/31/linux%E3%80%81vim%E3%80%81git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>第一次操作系统实验课记录：</p>
<h2 id="一。linux下常用命令"><a href="#一。linux下常用命令" class="headerlink" title="一。linux下常用命令"></a>一。linux下常用命令</h2><h2 id="二。vim编辑器用法命令"><a href="#二。vim编辑器用法命令" class="headerlink" title="二。vim编辑器用法命令"></a>二。vim编辑器用法命令</h2><ol>
<li>首先确保linux下安装有vim。可以使用上述命令sudo apt-get install vim来确定。如果已经安装了vim，会显示没有变化，否则会帮你安装vim。</li>
<li>然后就可以开始使用vim啦！</li>
</ol>
<blockquote>
<p>你使用 vim 或vim filename.suffix 进入了vim的命令模式。</p>
</blockquote>
<p>在命令模式下，不能进行文本编辑操作，需要按下A/a/I/i进入插入模式，在这个模式下可以像notepad一样进行文本编辑。</p>
<p><strong>如果使用第二种命令进入vim，vim将会自动帮你确定文件类型</strong>。这样说吧，比如你创建了一个yayicpp.cpp文件进入编辑，vim将会使代码高亮、进行括号匹配等操作。</p>
<blockquote>
<p>好的！进入文本编辑模式之后，你迫不及待地写了一段helloworld。代码完成之后，你觉得只打印一行helloworld不太够，你想知道有没有类似于VS环境中那种Ctrl+C和Ctrl+V的操作。</p>
</blockquote>
<p>其实是有的。这个时候需要按下Esc重新进入命令模式。在命令模式下有很多功能组合，上述的复制粘贴就是其中一种，但是这里并不想以复制粘贴作为第一个被介绍的命令，让我们先从光标的移动开始。</p>
<ol>
<li>按下h键，光标左移；j光标下移；k光标上移；l光标右移。</li>
<li>按下d键进入删除模式，这时按下h可删除光标左侧的一个字符，按下j可删除光标所在行以及下面一行；按下k可删除光标所在行与其上面一行；按下l可删除光标所在的字符。双击d键删除光标所在行。</li>
<li>按下u键可以撤销前一步所做的改变。</li>
<li>按下V（Shift+v）或是v可以进入到一个选择的可视化界面，同样可以使用hjkl控制选择范围，v按照字符选择，V按照行数选择。选择完成之后按下y就可以复制选定内容。按下p就可以将复制内容粘贴到选定的位置。</li>
<li>按两下y可以复制光标所在行。</li>
</ol>
<blockquote>
<p>写到这里，你觉得可以了，可以从vim里面退出来了。</p>
</blockquote>
<ol>
<li>在命令模式下输入冒号，进入最后行模式。在最低端出现了光标。</li>
<li>在光标位置输入w，保存文件。</li>
<li>输入q，退出。</li>
<li>这些命令可以进行组合wq。wq可以用x替代。</li>
</ol>
<blockquote>
<p>你进入了最后行模式，又不想退出了，想继续编辑。</p>
</blockquote>
<ol>
<li>按下Esc或者Backspace可以回到命令模式。</li>
</ol>
<h2 id="三。git初步使用"><a href="#三。git初步使用" class="headerlink" title="三。git初步使用"></a>三。git初步使用</h2><p>git是一个强大的版本管理工具，是Linus写的。这个人emmmmm…技术天才有些狂妄。</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[序列比较]]></title>
      <url>/2017/10/31/%E5%BA%8F%E5%88%97%E6%AF%94%E8%BE%83/</url>
      <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pixel</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">int</span> a, b;</div><div class="line">    Pixel(<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</div><div class="line">truetruea = x; b = y;</div><div class="line">true&#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</div><div class="line">true<span class="keyword">if</span> (a &lt; b) &#123;</div><div class="line">truetrue<span class="keyword">if</span> (c &lt; a)<span class="keyword">return</span> c;</div><div class="line">truetrue<span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= a)<span class="keyword">return</span> a;</div><div class="line">true&#125;</div><div class="line">true<span class="keyword">else</span> &#123;</div><div class="line">truetrue<span class="keyword">if</span> (c &lt; b)<span class="keyword">return</span> c;</div><div class="line">truetrue<span class="keyword">else</span> <span class="keyword">return</span> b;</div><div class="line">true&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">alpha</span><span class="params">(<span class="keyword">char</span> fir, <span class="keyword">char</span> sec)</span> </span>&#123;</div><div class="line">true<span class="keyword">if</span> (fir == sec)<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">true<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;<span class="comment">/*</span></div><div class="line"><span class="comment">int S(int m, int n, string a, string b, int beta) &#123;</span></div><div class="line"><span class="comment">	for (int i = 0; i &lt;= m; i++)</span></div><div class="line"><span class="comment">		M[i][0] = i*beta;</span></div><div class="line"><span class="comment">	for (int i = 0; i &lt;= n; i++)</span></div><div class="line"><span class="comment">		M[0][i] = i*beta;</span></div><div class="line"><span class="comment">	for (int i = 1; i &lt;= m; i++)</span></div><div class="line"><span class="comment">		for (int j = 1; j &lt;= n; j++)</span></div><div class="line"><span class="comment">			M[i][j] = min(alpha(a[i-1],b[j-1]) + M[i-1][j-1], beta + M[i-1][j], beta + M[i][j-1]);</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">	return M[m ][n];</span></div><div class="line"><span class="comment">&#125;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">void back(int m, int n, string A,string B,int*result,int beta) &#123;</span></div><div class="line"><span class="comment">	if (m&lt;A.length()&amp;&amp;n&lt;B.length()&amp;&amp;M[m][n] +alpha(A[m],B[n])== M[m+1][n+1]) &#123;</span></div><div class="line"><span class="comment">		result[m] = 0;</span></div><div class="line"><span class="comment">		back(m + 1, n + 1, A,B,result,beta);</span></div><div class="line"><span class="comment">	&#125;</span></div><div class="line"><span class="comment">	else if (m&lt;A.length()&amp;&amp;n&lt;=B.length()&amp;&amp;M[m][n]+beta ==  M[m + 1][n]) &#123;</span></div><div class="line"><span class="comment">		result[m ] = 1;</span></div><div class="line"><span class="comment">		back(m +1, n, A,B,result,beta);</span></div><div class="line"><span class="comment">	&#125;</span></div><div class="line"><span class="comment">	else if(m&lt;=A.length()&amp;&amp;n&lt;B.length()) &#123;</span></div><div class="line"><span class="comment">		result[m] = -1;</span></div><div class="line"><span class="comment">		back(m, n + 1, A,B,result,beta);</span></div><div class="line"><span class="comment">	&#125;</span></div><div class="line"><span class="comment">&#125;*/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">SL</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="built_in">string</span> a, <span class="built_in">string</span> b, <span class="keyword">int</span> beta)</span> </span>&#123;</div><div class="line">true<span class="keyword">int</span>**M = <span class="keyword">new</span> <span class="keyword">int</span>*[<span class="number">2</span>];</div><div class="line">trueM[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[b.length() + <span class="number">1</span>];</div><div class="line">trueM[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[b.length() + <span class="number">1</span>];</div><div class="line">true<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</div><div class="line">truetrueM[<span class="number">0</span>][i] = beta*i;</div><div class="line">true&#125;	</div><div class="line">trueM[<span class="number">1</span>][<span class="number">0</span>] = beta;</div><div class="line">true<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</div><div class="line">truetrueM[<span class="number">1</span>][<span class="number">0</span>] = i*beta;</div><div class="line">truetrue<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</div><div class="line">truetruetrueM[<span class="number">1</span>][j] = min(alpha(a[i - <span class="number">1</span>], b[j - <span class="number">1</span>]) + M[<span class="number">0</span>][j - <span class="number">1</span>], beta + M[<span class="number">1</span>][j - <span class="number">1</span>], beta + M[<span class="number">0</span>][j]);</div><div class="line">truetrue&#125;</div><div class="line">truetrue<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</div><div class="line">truetruetrueM[<span class="number">0</span>][j] = M[<span class="number">1</span>][j];</div><div class="line">truetrue&#125;</div><div class="line">true&#125;</div><div class="line">true<span class="keyword">int</span> re = M[<span class="number">0</span>][n];</div><div class="line">true<span class="keyword">delete</span>[]M;</div><div class="line">true<span class="keyword">return</span> re;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DACA</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> r,<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="built_in">string</span> a, <span class="built_in">string</span> b, <span class="built_in">stack</span>&lt;Pixel&gt;*P,<span class="keyword">int</span> beta)</span> </span>&#123;</div><div class="line">true<span class="keyword">if</span> (x-o &lt;= <span class="number">1</span> || y-r &lt;= <span class="number">2</span>) &#123;</div><div class="line">truetrue<span class="keyword">int</span>**M = <span class="keyword">new</span> <span class="keyword">int</span>*[x+<span class="number">1</span>];</div><div class="line">truetrue<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x -o+ <span class="number">1</span>; i++) &#123;</div><div class="line">truetruetrueM[i] = <span class="keyword">new</span> <span class="keyword">int</span>[y -r+ <span class="number">1</span>];</div><div class="line">truetruetrueM[i][<span class="number">0</span>] = beta*i;</div><div class="line">truetrue&#125;</div><div class="line">truetrue<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= y-r; i++)</div><div class="line">truetruetrueM[<span class="number">0</span>][i] = i*beta;</div><div class="line">truetrue<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x-o; i++)</div><div class="line">truetruetrue<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= y-r; j++) &#123;</div><div class="line">truetruetruetrueM[i][j] = min(alpha(a[i - <span class="number">1</span>], b[j - <span class="number">1</span>]) + M[i - <span class="number">1</span>][j - <span class="number">1</span>], beta + M[i][j - <span class="number">1</span>], beta + M[i - <span class="number">1</span>][j]);</div><div class="line">truetruetrue&#125;</div><div class="line"></div><div class="line">true<span class="keyword">for</span> (<span class="keyword">int</span> i = x-o; i &gt;= <span class="number">0</span>; ) &#123;</div><div class="line">truetrue<span class="keyword">int</span> j = y - r;</div><div class="line">truetruetrue<span class="keyword">for</span> (j=y-r; j &gt;= <span class="number">0</span>; ) &#123;</div><div class="line">truetruetruetrue<span class="keyword">if</span> (i&gt;=<span class="number">1</span>&amp;&amp;j&gt;=<span class="number">1</span>&amp;&amp;M[i][j] == alpha(a[i<span class="number">-1</span>], b[j<span class="number">-1</span>]) + M[i - <span class="number">1</span>][j - <span class="number">1</span>]) &#123;</div><div class="line">truetruetruetruetruePixel*p = <span class="keyword">new</span> Pixel(i - <span class="number">1</span>+o, j - <span class="number">1</span>+r);</div><div class="line">truetruetruetruetrueP-&gt;push(*p);</div><div class="line">truetruetruetruetruei = i - <span class="number">1</span>; j = j - <span class="number">1</span>; </div><div class="line">truetruetruetrue&#125;</div><div class="line">truetruetruetrue<span class="keyword">else</span> <span class="keyword">if</span> (i&gt;=<span class="number">1</span>&amp;&amp;j&gt;=<span class="number">0</span>&amp;&amp;M[i][j] == beta + M[i - <span class="number">1</span>][j]) &#123;</div><div class="line">truetruetruetruetruePixel*p = <span class="keyword">new</span> Pixel(i - <span class="number">1</span>+o, j+r);</div><div class="line">truetruetruetruetrueP-&gt;push(*p);</div><div class="line">truetruetruetruetruei -= <span class="number">1</span>; </div><div class="line">truetruetruetrue&#125;</div><div class="line">truetruetruetrue<span class="keyword">else</span> <span class="keyword">if</span> (i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">1</span>&amp;&amp;M[i][j] == beta + M[i][j - <span class="number">1</span>]) &#123;</div><div class="line">truetruetruetruetruePixel*p = <span class="keyword">new</span> Pixel(i+o, j - <span class="number">1</span>+r);</div><div class="line">truetruetruetruetrueP-&gt;push(*p);</div><div class="line">truetruetruetruetruej -= <span class="number">1</span>; </div><div class="line">truetruetruetrue&#125;</div><div class="line">truetruetruetrue<span class="keyword">else</span> <span class="keyword">break</span>;</div><div class="line">truetruetrue&#125;</div><div class="line">truetruetrue<span class="keyword">if</span> (j == <span class="number">0</span> &amp;&amp; i == <span class="number">0</span>)<span class="keyword">break</span>;</div><div class="line">truetrue&#125;</div><div class="line">truetrue<span class="keyword">return</span>;</div><div class="line">true&#125;</div><div class="line">true</div><div class="line">true<span class="built_in">string</span> a2;</div><div class="line">true<span class="built_in">cout</span> &lt;&lt; <span class="string">"here:"</span> &lt;&lt;( y-r) / <span class="number">2</span>  &lt;&lt; <span class="string">","</span> &lt;&lt; y-r &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">true<span class="built_in">string</span> b2 =b.substr((y-r) / <span class="number">2</span> , y-r);</div><div class="line">true<span class="keyword">int</span> q[<span class="number">2</span>] = &#123; <span class="number">0</span>,<span class="number">0</span> &#125;;</div><div class="line">true<span class="keyword">int</span> min;</div><div class="line">true<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= x-o; i++) &#123;</div><div class="line">truetruea2 = a.substr(i, x-o);</div><div class="line">truetrueq[<span class="number">0</span>]=SL(i, (y-r) / <span class="number">2</span>, a, b, <span class="number">1</span>);</div><div class="line">truetrue<span class="built_in">cout</span> &lt;&lt; <span class="string">"done!"</span>;</div><div class="line">truetrueq[<span class="number">0</span>]+=SL(x-o - i, y-r - (y-r) / <span class="number">2</span>, a2, b2, <span class="number">1</span>);</div><div class="line">truetrue<span class="built_in">cout</span> &lt;&lt; <span class="string">"done!"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">truetrue<span class="keyword">if</span> (i == <span class="number">0</span>)min = q[<span class="number">0</span>];</div><div class="line">truetrue<span class="keyword">else</span> &#123;</div><div class="line">truetruetrue<span class="keyword">if</span> (min &gt; q[<span class="number">0</span>]) &#123;</div><div class="line">truetruetruetruemin = q[<span class="number">0</span>];</div><div class="line">truetruetruetrueq[<span class="number">1</span>] = i;</div><div class="line">truetruetrue&#125;</div><div class="line">truetrue&#125;</div><div class="line">true&#125;</div><div class="line">truemin = q[<span class="number">1</span>]+o;</div><div class="line">truePixel*p = <span class="keyword">new</span> Pixel(min, (y - r) / <span class="number">2</span> + r);</div><div class="line">trueP-&gt;push(*p);</div><div class="line">true</div><div class="line">trueDACA(o,r,min, (y-r) / <span class="number">2</span>+r, a, b, P, beta);</div><div class="line">true<span class="built_in">cout</span> &lt;&lt; <span class="string">"and here:"</span> &lt;&lt; min &lt;&lt; <span class="string">","</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">truea2 = a.substr(min-o , x-o);</div><div class="line">true<span class="built_in">cout</span> &lt;&lt; <span class="string">"???"</span>;</div><div class="line">true<span class="built_in">cout</span> &lt;&lt; <span class="string">"hhhh"</span> &lt;&lt; x - min &lt;&lt; <span class="string">";;;"</span> &lt;&lt; y - y / <span class="number">2</span>;</div><div class="line">trueDACA(min,(y-r)/<span class="number">2</span>+r,x  , y , a2, b2, P, beta);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">true<span class="built_in">string</span> A, B;</div><div class="line">true<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B) &#123;</div><div class="line">truetrue<span class="built_in">stack</span>&lt;Pixel&gt;*P = <span class="keyword">new</span> <span class="built_in">stack</span>&lt;Pixel&gt;();</div><div class="line">truetrue<span class="built_in">cout</span> &lt;&lt; SL(A.length(), B.length(), A, B,<span class="number">1</span>);</div><div class="line">truetrue<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">truetrueDACA(<span class="number">0</span>,<span class="number">0</span>,A.length(), B.length(), A, B, P, <span class="number">1</span>);</div><div class="line">truetrue<span class="built_in">cout</span> &lt;&lt; <span class="string">"LLLLL"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">truetrue<span class="keyword">while</span>(!(P-&gt;empty())) &#123;</div><div class="line">truetruetruetruePixel p = (P-&gt;top());</div><div class="line">truetruetruetrueP-&gt;pop();</div><div class="line">truetruetruetrue<span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; p.a &lt;&lt; <span class="string">","</span> &lt;&lt; p.b &lt;&lt; <span class="string">")"</span>;</div><div class="line">truetruetrue&#125;</div><div class="line">truetrue<span class="keyword">delete</span> P;</div><div class="line">truetrue<span class="built_in">cout</span> &lt;&lt; <span class="string">"what!"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">true&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OS Lab1]]></title>
      <url>/2017/10/31/OS-Lab12/</url>
      <content type="html"><![CDATA[<h1 id="OSLab1：MIT的Lab1"><a href="#OSLab1：MIT的Lab1" class="headerlink" title="OSLab1：MIT的Lab1"></a>OSLab1：MIT的Lab1</h1><p>这个作业真的非常令人心烦，现在到了检查作业的紧要关头啦！</p>
]]></content>
      
        
        <tags>
            
            <tag> OS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[first try]]></title>
      <url>/2017/10/29/first-try/</url>
      <content type="html"><![CDATA[<h1 id="yayi’s-new-blog"><a href="#yayi’s-new-blog" class="headerlink" title="yayi’s new blog"></a>yayi’s new blog</h1><p>what !你为什么这么多事啊！？</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/10/29/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[关于]]></title>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<p>╰(￣ω￣ｏ)！</p>
<p>就不说什么能认识大家很开心之类的废话了！</p>
<p>我目前还在大学奔波忙碌，真的完全是小白啦！之前学习专业课的时候受到很多大神博主的帮助，中文文档简直是瑰宝！</p>
<p>所以~希望我的东西或多或少也能帮助到别人！</p>
<p>鞠躬~(●’◡’●)</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[all-categories]]></title>
      <url>/all-catagories/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[all-archives]]></title>
      <url>/all-archives/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[读书]]></title>
      <url>/reading/index.html</url>
      <content type="html"></content>
    </entry>
    
  
</search>
