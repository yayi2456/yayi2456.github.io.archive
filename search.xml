<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[标准日本语初级(上)第一课]]></title>
      <url>/2018/05/17/%E6%97%A5%E8%AF%AD%E7%99%BD%E7%99%BD/%E6%A0%87%E5%87%86%E6%97%A5%E6%9C%AC%E8%AF%AD%E4%B8%8A1/</url>
      <content type="html"><![CDATA[<h1 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h1><p>日语中的汉字全部是<strong>多音字</strong>，至少会有两个读音。</p>
<p><strong>じん　人</strong>：ちゅうごくじん　にほんじん</p>
<p><strong>せい　生</strong>：がくせい　せんせい　りゅうがくせい</p>
<p>关于“先生”这个词，在日本一般只用于对教课的老师、政治议员、医生、律师的称呼。其次是在某一个领域比较厉害的人物，会被称为”先生“。</p>
<p><strong>がく　学</strong></p>
<p><strong>いん　員</strong>：しゃいん</p>
<p><strong>教授 きょうじゅ</strong>：读音前长后短。</p>
<p><strong>かい　会</strong>　　<strong>しゃ　社</strong>　　<strong>いん　員</strong></p>
<p>通过这些组合我们可以认识到一些新词，比如：<strong>かいいん　会員</strong>、<strong>しゃいん　社員</strong>、<strong>かいしゃ　会社</strong>、<strong>しゃかい　社会</strong></p>
<blockquote>
<p>区分：会社員　社員<br>会社員　指的是一种<strong>职业</strong>，意思是“公司职员”。 社員　指的是具体属于某一个公司的人，一般在指出公司的句子里面使用。</p>
</blockquote>
<p>日本会有<strong>鼻浊音</strong>，比如：企業　きぎょ，如果考虑正式的发音，应该是：kinyo，但是实际上，尤其年轻一辈，不考虑鼻浊音，就只读成普通的浊音：kigyo。</p>
]]></content>
      
        <categories>
            
            <category> 日本語 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 日本語 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu-windows 共享文件夹]]></title>
      <url>/2018/05/17/ubuntu-windows%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
      <content type="html"><![CDATA[<p>实际写的时间应该是2017年9-26。最初写在了CSDN。因为要放弃CSDN了，就挪过来。</p>
<a id="more"></a>
<h1 id="在windows下"><a href="#在windows下" class="headerlink" title="在windows下"></a>在windows下</h1><ol>
<li>创建一个文件夹</li>
<li>右击文件夹-&gt;属性-&gt;共享-&gt;添加用户-&gt;everyone-&gt;设置权限-&gt;添加-&gt;共享。</li>
<li>查看本机IP。</li>
</ol>
<h1 id="在Linux下"><a href="#在Linux下" class="headerlink" title="在Linux下"></a>在Linux下</h1><ol>
<li>安装samba包</li>
<li>File System中输入：smb://[ip]</li>
</ol>
<p>OK。</p>
<p>如果linux提示：failed to mount windows share:connection timed out，但是无论从虚拟机ping主机还是主机ping虚拟机都能ping通，说明是因为win10里面默认关闭了SMB服务。<br>询问Cortana“启用或关闭windows功能”（或者打开控制面板自己找这一项），找到<strong> SMB 1.0/CIFS 文件共享支持</strong>，打开，之后会被要求重启。电脑重启之后，就可以连接啦！<br>解决方法来源:<a href="https://kodi.wiki/view/SMB/Windows#Connection_Timed_Out" target="_blank" rel="external">SMB/Windows</a></p>
<p>连接的时候会要求用户名与密码，这是因为直接连接了机器，这个密码是要求Windows机器的账户密码。<br>其实我觉得有点奇怪…因为上述设置的时候明明“everyone”可以读写。不过无伤大雅，就没有再管。</p>
<hr>
<p>目前存在的问题：无法传输2M的pdf文件。但是6K的txt可以很快传输。</p>
<hr>
<p>#519再次更新：</p>
<p>前面说到无法传输pdf，实际上是超过了1M甚至几百K的文件不能传输，会有提示<code>Connection timed out</code>。<br>昨天看了些解决方案，都需要修改smb源码至少也需要修改conf文件。改了之后重启仍然不能传输。</p>
<p><a href="https://blog.csdn.net/shanshui90/article/details/8843500" target="_blank" rel="external">具体修改方式点这里</a></p>
<p>今天忽然就好了….而且传输速度很快…</p>
<hr>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[记一次linux server版本的get桌面]]></title>
      <url>/2018/04/27/%E8%AE%B0%E4%B8%80%E6%AC%A1linux-server%E7%89%88%E6%9C%AC%E7%9A%84get%E6%A1%8C%E9%9D%A2/</url>
      <content type="html"><![CDATA[<p>流水账，顺便带一点操作方法。</p>
<a id="more"></a>
<p>首先板子是UP2，之前其实已经预装了Ubuntu16.04的server版本，但是我们以为这只是一个简版而果断重新装了Ubuntu的desktop版。后来被告知这个server版预装有关于UP2开发的一系列包…于是又刷回了server版。</p>
<p><a href="https://downloads.up-community.org/download/up-squared-iot-grove-development-kit-ubuntu-16-04-server-image/" target="_blank" rel="external">如何刷回server版（for UP2），click here。</a></p>
<p>里面给出的image下载链接可能是因为源在国外的关系，下载速度emm，我放进了我的百度网盘，虽然速度也慢，但不至于超时失败。</p>
<p>除了server版的image，还需要一个制作PE启动盘的工具。仍然是官方给出的工具<a href="https://tuxboot.org/download/" target="_blank" rel="external">tuxboot</a>，省心的下载链接选<strong>Files on SourceForge</strong>，速度也慢，但好在不大。我也上传到了网盘。</p>
<blockquote>
<p>使用TuxBoot而不是其他UltraISO之类的软件的原因是：这里下载出来的image是.zip的格式，UltraISO并不能直接处理这个文件，如果使用UltraISO将这个.zip添加到.ISO，得到的镜像属于<strong>不可引导文件</strong>，无法为U盘建立引导分区。</p>
</blockquote>
<p>打开TuxBoot，选择 <strong>Pre Dowloaded</strong> -&gt; <strong>7zs(for zip)</strong> -&gt; <strong>选择文件所在位置</strong> -&gt; <strong>USB Drive</strong> -&gt; <strong>选择drive(U盘)</strong>。</p>
<p>如果想要可引导的ISO文件，可以勾选<strong>Save ISO File</strong>。<strong>MD5 check</strong>为预勾选，不要动。</p>
<p>下面是TuxBoot的一个截图：<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-4-28/12633202.jpg" alt=""></p>
<p>选完之后点OK等待完成，然后就得到了一个可以用来装Ubuntu<br>server版的U盘。</p>
<p>然后直接把U盘插到UP2的USB接口，重启UP2，就可以直接进入引导界面。等待它装完之后，板子自动关机。<strong>拔掉U盘</strong>，防止进行再次安装。开机。初始的用户名与密码都是<strong>upsquared</strong>。</p>
<p>至此，系统重装完成。</p>
<blockquote>
<p>上一次装系统还是自己装win10，这个比较简单，因为windows官方有傻瓜式的PE U盘制作引导，这里也给出网站<a href="https://www.microsoft.com/zh-cn/software-download/windows10" target="_blank" rel="external">click here</a>。跟着指示走就行了。</p>
</blockquote>
<hr>
<p>然后开始奋战在get桌面。其实这本来是一件很简单的事，但是由于校园网需要登陆+pppoeconfig文件找不到+命令行下登陆困难，这件事困扰了我一下午…其实最终这个问题也不是我解决的…使它自己好的…</p>
<p>首先新装的系统需要更新一下：<code>sudo apt-get update</code></p>
<p><a href="http://blog.creke.net/696.html" target="_blank" rel="external">具体命令看这里。</a></p>
<p><strong>注意</strong>：中文包可能会出出现“not avaliable”，这是因为需要指明安装简体还是繁体。<strong>hans</strong>是简体，<strong>hant</strong>是繁体。</p>
<p>首先，目前的情况是：</p>
<ol>
<li>up2没有wifi模块不能无线连接</li>
<li>一台不支持ipv6的路由器，好处是路由器一次登陆各设备都能上网。目前大多数路由器应该都是这样（那应该叫做AP</li>
<li>两根网线，一个给路由器WLAN，一个从路由器的LAN接到UP2的网口。</li>
<li>显示屏鼠标键盘都是必备的</li>
</ol>
<p>按理来说，我用PC连wifi登陆，然后UP2这边就应该能上网了，怪事是这样的：我登陆了wifi，发现欸怎么还不能从板子那边上网，但是很奇怪有的时候又可以get到，但是过了一会儿就会说无法从[web]得到数据，这个web就是我们学校登陆界面的网址。于是我就ping一下，ping不通，curl一个网址，也是传回登陆界面得html。emmm…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl www.bing.com</div></pre></td></tr></table></figure>
<p>这个问题其实我也没有解决，因为是可以上一段时间网的，就是不断地重新apt-get install，直到某次的进度达到100%（因为每次运行都会从上次失败的地方重新开始）。<br>总之，最后还是get到了桌面。<br><strong>但是应该是一直可以连接网络才对</strong><br><strong>想知道校园网网关的原理</strong></p>
<p>这时，get到的桌面就只有一个壁纸，其他什么都没有，可以<a href="https://www.zhihu.com/question/41770698" target="_blank" rel="external">这样安装unity桌面</a><br>上面的网页仅供参考，因为这里是新装的，就是因为没有装unity桌面，这样：<code>sudo apt-get install unity</code>应该就行。</p>
<hr>
<p>啊这么久以后了，今天脑子一抽卸载了python3，许多包都卸载了，决定重刷，这次试一试自己装桌面，不直接整包了。</p>
<blockquote>
<p>正好了解一些python3的问题吧。</p>
</blockquote>
<p>之后中文输入法什么的就在设置里面找就行了。</p>
<hr>
<p>至此，终于把板子恢复了~</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ModuleNotFoundError:No module named 'numpy' in pyCharm]]></title>
      <url>/2018/04/08/Python/numpy_not_found/</url>
      <content type="html"><![CDATA[<p>这个错误折磨了我三天….各种折磨….终于在今天给解决了。</p>
<a id="more"></a>
<p><strong>为什么会出现这个问题？</strong></p>
<p>有两种原因：</p>
<ol>
<li>没有装NumPy</li>
<li>已经装了NumPy但是运行的脚本使用的解释器不是装了NumPy的解释器。</li>
</ol>
<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>如果你现在已经自己从Python官网下载安装了Python环境，建议现在卸载掉，方法很简单，Win10直接去中的设置-&gt;应用中卸载就行。因为如果不卸载掉，你的电脑中可能在下列操作之后存在多个python.exe，打开不同的python.exe，安装的东西就不一样，能用的模块也不一样。如果什么应用默认使用了你不想使用的那个python，就很麻烦。</p>
<p>好了，现在可以装NumPy了。其实可以直接再cmd里面<code>pip3 insatll numpy</code>（用于python3）或<code>pip install python</code>（用于python2），但是我看网上各博客论坛上的大佬都<strong>不推荐这么做</strong>，最好是直接使用Anaconda，这样可以避免一些版本不兼容带来的幺蛾子。</p>
<p>如果你已经装了NumPy，同样，建议卸载。只需要在cmd里面<code>pip3 unintsall numpy</code>（py3）或是<code>pip unintall numpy</code>（py2）。</p>
<p>去下载Anaconda的安装包，不推荐官网，因为在国内官网奇慢。推荐去<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="external">清华大学镜像网站</a>下载，没有特殊需求的话看清平台与32/64，选择最新版<strong>似乎</strong>就行（因为我是全新的环境，pycharm2018.1community。</p>
<p>然后安装anaconda，自己选一个安装路径，不用必须安装到C盘，也不用觉得安装到C盘比较方便（反正都逃不过环境变量。</p>
<p>到这里python环境就没有问题了，接下来如果还是会有notfound的问题，就是pycharm的配置问题了。</p>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>如果你是在pyCharm中新建的项目，这里一定要提示：<strong>新建项目的时候一定自己选择python解释器</strong>！！！，因为，如果你不自己去选，默认是“新的解释器”，这个新的解释器不仅会在项目下建一些不必要的东西，还有可能需要为之安装jupyter note。总之，不推荐。推荐使用<strong>已经存在的解释器</strong>，也就是你刚刚安装anaconda选择的那个目录下的python.exe：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-4-10/98412092.jpg" alt=""></p>
<p>这样进去之后基本没什么问题了。</p>
<blockquote>
<p>插一句，如果出现这种找不到module的问题，去看一看这个运行的程序使用的是哪个解释器，这个信息会出现在底部的输出窗口。我就是因为发现jupyter的解释器一直是原来的那个新建的解释器才决定<strong>每次创建项目都使用已经存在的anaconda解释器</strong>。</p>
</blockquote>
<hr>
<p>关于运行配置，可以自己配置，只需要注意选择解释器的时候选择anaconda下的解释器就好。推荐直接在file-&gt;default setting中设置项目的默认解释器，或是在file-&gt;setting中为这个项目设置自己的默认解释器。</p>
<p>最后提一下，jupyter book需要在server上运行，第一次运行随便给一个token，然后底部给出一个链接，这就是可以运行了，随后使用<code>shift+enter</code>就可以运行一段代码了。运行方式感觉像是IDLE的改良。<br>如果jupyter运行的时候提示error需要安装jupyter，就安装一下就好。也不用自己去搜索，就按旁边的fix就好。</p>
<p>python file和jupyter note都可以使用：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-4-10/58382156.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-4-10/54609775.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[matlab notes]]></title>
      <url>/2018/02/26/matlab_notes/</url>
      <content type="html"><![CDATA[<a id="more"></a>
<p>nkes113@nankai.edu.cn</p>
<p><a href="https://www.edx.org" target="_blank" rel="external">哈佛</a></p>
<p><a href="ocw.mit.edu">mit</a></p>
<p><a href="mathworks.com">matlab</a></p>
<p>ixl.com</p>
<p>公邮nkmatlab2018@126.com<br>code:besidenk</p>
<!-- TOC -->
<ul>
<li><a href="#">第一节</a></li>
<li><a href="#op">变量脚本与op</a><ul>
<li><a href="#scripts">脚本 Scripts</a></li>
<li><a href="#variables">变量 variables</a><ul>
<li><a href="#">标量</a></li>
<li><a href="#array">数组　Array</a></li>
<li><a href="#">矩阵</a></li>
<li><a href="#">数据文件操作</a></li>
<li><a href="#exercise">Exercise：得到并存储当前时间</a></li>
</ul>
</li>
<li><a href="#">操作变量</a></li>
<li><a href="#plot">基本plot</a></li>
</ul>
</li>
<li><a href="#">可视化编程</a><ul>
<li><a href="#">用户函数</a></li>
</ul>
</li>
<li><a href="#"></a><ul>
<li><a href="#">解方程</a></li>
<li><a href="#">微分积分</a></li>
</ul>
</li>
<li><a href="#4">4画图</a><ul>
<li><a href="#cell">CELL</a></li>
<li><a href="#struct">Struct</a></li>
</ul>
</li>
<li><a href="#5">5符号与模拟</a></li>
<li><a href="#">双变量分析</a><ul>
<li><a href="#">相关系数计算</a><ul>
<li><a href="#pearson">Pearson</a></li>
<li><a href="#spearman">Spearman</a></li>
<li><a href="#jackknife">jackknife</a></li>
</ul>
</li>
<li><a href="#">经典线性回归分析与预测</a></li>
<li><a href="#">线性回归扩展</a><ul>
<li><a href="#">交互式多线性回归分析：</a></li>
<li><a href="#">岭回归：针对多重共线问题</a></li>
<li><a href="#"></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#">零碎的</a></li>
</ul>
<!-- /TOC -->
<h1 id="第一节"><a href="#第一节" class="headerlink" title="第一节"></a>第一节</h1><p>经典统计学</p>
<ol>
<li>三个基本假设：同一总体、相互独立、特定分布</li>
</ol>
<hr>
<ol>
<li>不同的数据采集方式有着不同的统计方法（平均数计算</li>
<li>数据是否符合经典统计学的分布规律</li>
</ol>
<p>ftp://202.113.29.4</p>
<p><strong>采样</strong></p>
<ol>
<li>基于设计的采样</li>
<li>基于模型的采样</li>
</ol>
<p><strong>Q2</strong>：癌症高发与污染是不是有关系。</p>
<h1 id="变量脚本与op"><a href="#变量脚本与op" class="headerlink" title="变量脚本与op"></a>变量脚本与op</h1><ol>
<li>set path</li>
<li>customization:preferences</li>
</ol>
<p><strong>帮助</strong>：<code>help sin</code>    <code>doc sin</code>   <code>docsearch sin</code></p>
<h2 id="脚本-Scripts"><a href="#脚本-Scripts" class="headerlink" title="脚本 Scripts"></a>脚本 Scripts</h2><p><strong>编辑文件</strong>：<code>edit filename.m</code>;<br><strong>注释</strong>:%zhushi<br><strong>输出字符串</strong>：<code>disp(&#39;string&#39;)</code>，不要试图像使用printf那样使用disp，如果一定要输出数据，考虑下面两种方式：</p>
<blockquote>
<p><code>disp(strcat(&#39;the number is:&#39;,num2str(num)))</code>;<br>或是：<br><code>str=sprintf(&#39;the number is:%f&#39;,num)</code><br><code>disp(str)</code></p>
</blockquote>
<h2 id="变量-variables"><a href="#变量-variables" class="headerlink" title="变量 variables"></a>变量 variables</h2><ol>
<li>matlab是一个<strong>weakly typed</strong>语言，不需要初始化。</li>
<li>matlab大小写敏感</li>
</ol>
<p><strong>尽量不要使用这些变量</strong>：</p>
<blockquote>
<p><strong>i</strong> 与 <strong>j</strong> 用于声明复数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;    &gt;&gt; a=1+2i</div><div class="line">&gt;</div><div class="line">&gt;a =</div><div class="line">&gt;</div><div class="line">&gt;   1.0000 + 2.0000i</div><div class="line">&gt;</div></pre></td></tr></table></figure></p>
<hr>
<p><strong>pi</strong>是$\pi$</p>
<hr>
<p><strong>ans</strong>是最后一个未赋值的算式的值</p>
<hr>
<p><strong>Inf</strong>与<strong>-Inf</strong>是正无穷与负无穷</p>
<hr>
<p><strong>NaN</strong>相当于null</p>
</blockquote>
<h3 id="标量"><a href="#标量" class="headerlink" title="标量"></a>标量</h3><p><strong>清除command window</strong>：<code>clc</code></p>
<h3 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组　Array"></a>数组　Array</h3><p><strong>注意</strong>：千万不要使用<code>A=(1,2,3)</code>或是<code>A=(1 2 3)</code>或是<code>A=(1;2;3)</code>这种！（是不是第二遍强调这个了！</p>
<p>矩阵：A=[1 2 3;4 5 6;7 8 9]空格也可以是逗号，scripts里面建议使用逗号。</p>
<p><strong>size与length</strong>：知道“matlab对于数组是先列后行（不同于C++ java等有助于理解这个”<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt; A=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>;<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>];</div><div class="line">&gt;&gt; hangshu=<span class="built_in">size</span>(A,<span class="number">1</span>);</div><div class="line">&gt;&gt; lieshu=<span class="built_in">size</span>(A,<span class="number">2</span>);</div><div class="line">&gt;&gt; lengtha=<span class="built_in">length</span>(A);</div><div class="line">&gt;&gt; [hangshu,lieshu,lengtha]</div><div class="line"></div><div class="line"><span class="built_in">ans</span> =</div><div class="line"></div><div class="line">     <span class="number">2</span>     <span class="number">3</span>     <span class="number">3</span></div></pre></td></tr></table></figure></p>
<p><strong>length</strong>函数其实是max(size(A))，也就是行长度与列长度之中，更大的那一个。</p>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><blockquote>
<p>但是我试了一下，似乎是最终形成的那个矩阵也应该是一个整齐的二维矩阵，而且使用length也是相当于一些数据（number）来算的。所以似乎也没有特别说的必要…</p>
</blockquote>
<h3 id="数据文件操作"><a href="#数据文件操作" class="headerlink" title="数据文件操作"></a>数据文件操作</h3><p><strong>将变量存进文件</strong>：<code>save filename v1 v2 ...</code>或者是<code>save filename</code>，后面的这个是将当前的workspace中的所有变量存入文件。</p>
<p><strong>清除当前工作区中的变量</strong>：<code>clear v1 v2...</code>或是<code>clear</code>，后面的这个将清除当前workspace中的所有的变量。</p>
<p><strong>加载文件中的变量</strong>：<code>load filename v1 v2...</code>或是<code>load filename</code>，后面这个将会将该文件中的所有变量load进工作区。</p>
<h3 id="Exercise：得到并存储当前时间"><a href="#Exercise：得到并存储当前时间" class="headerlink" title="Exercise：得到并存储当前时间"></a>Exercise：得到并存储当前时间</h3><p>有用的函数：<br><strong>clock</strong>：使用方式是直接clock。得到的是[year month day hour minute seconds]<br><strong>datestr</strong>：将上述的结果转化为时间的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt; datestr(clock)</div><div class="line"></div><div class="line">ans =</div><div class="line"></div><div class="line">    &apos;19-Mar-2018 21:43:44&apos;</div></pre></td></tr></table></figure>
<h2 id="操作变量"><a href="#操作变量" class="headerlink" title="操作变量"></a>操作变量</h2><ol>
<li>加减乘除+-*/</li>
<li>次方^</li>
<li>element wise运算前面加.</li>
<li>内置的函数：<code>sqrt</code>开平方、<code>log</code>自然对数、<code>log10</code>以10为底的对数、<code>sin cos atan</code>等三角函数、<code>round</code>四舍五入、<code>floor</code>全取整数、<code>ceil</code>天花板、<code>fix</code>向0舍取整、<code>abs</code>绝对值、<code>angle</code>相角、<code>factor</code>得到指定数据的素数因数。</li>
<li>矩阵转置’(单引号)</li>
<li>sum函数优先上下行相加，如果只有一行就全加上去</li>
<li>prod函数优先上下行相乘，如果只有一行就所有相乘</li>
<li>\运算右除，对于标量来说就是相反的事，但是对于矩阵来说A\B是：<figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A*x=b;</div><div class="line">x=A\b;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>目前主要用于求解方程。</p>
<ol>
<li>ones(hangshu,lieshu)</li>
<li>zeros(hangshu,lieshu)</li>
<li>rand(hangshu,lieshu)，默认情况下产生的数据在(0,1)之间——rand(n)默认生成nxn的随机矩阵</li>
<li>nan(hangshu,lieshu)</li>
<li>linspace(shi,zhong,geshu)，不是linespace喔~</li>
<li>b=0:1:10、b=0:10 不写中间的间隔默认是1</li>
<li>寻址：A(1)，先列后行</li>
<li>特殊寻址：A(2,:)等你知道</li>
<li>特殊寻址find：index=find(A(:)&gt;=10)，使用help</li>
<li><strong>ind2sub</strong></li>
<li><strong>sub2ind</strong></li>
<li><strong>min</strong> \ <strong>max</strong>参考sum</li>
</ol>
<h2 id="基本plot"><a href="#基本plot" class="headerlink" title="基本plot"></a>基本plot</h2><p>plot最好使用help。</p>
<p><strong>打开新图</strong>：<code>figure</code></p>
<h1 id="可视化编程"><a href="#可视化编程" class="headerlink" title="可视化编程"></a>可视化编程</h1><h2 id="用户函数"><a href="#用户函数" class="headerlink" title="用户函数"></a>用户函数</h2><p><code>function [avg,sd,range]=scriptname(p1,p2)</code></p>
<p>load进来之后是一个1x1的struct？</p>
<hr>
<p>function<br>    nargin：matlab中的函数调用可以允许更少的参数，该内置参数即为实参个数。</p>
<p>流的控制flow control</p>
<p>图像相关：<br>    help imread：matlab自带的图像函数相关说明<br>    surface analysis</p>
<pre><code>quiver画图函数mesh
doc specgraph
</code></pre><p>#</p>
<h2 id="解方程"><a href="#解方程" class="headerlink" title="解方程"></a>解方程</h2><ol>
<li><p>使用以下code：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">A=[<span class="number">1</span>,<span class="number">4</span>;<span class="number">-3</span>,<span class="number">1</span>];</div><div class="line">b=[<span class="number">34</span>;<span class="number">2</span>];</div><div class="line">y=A\b;</div><div class="line"><span class="built_in">disp</span>(y);</div></pre></td></tr></table></figure>
</li>
<li><p>使用函数<strong>roots</strong>解方程</p>
</li>
<li><p>使用函数<strong>polyfit</strong>/<strong>polyval</strong>进行多项式的拟合：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">x=[<span class="number">-1</span> <span class="number">0</span> <span class="number">2</span>];</div><div class="line">y=[<span class="number">0</span> <span class="number">-1</span> <span class="number">3</span>];</div><div class="line">p2=polyfit(x,y,<span class="number">2</span>);<span class="comment">%求解出系数</span></div><div class="line">plot(x,y,<span class="string">'o'</span>,<span class="string">'MarkerSize'</span>,<span class="number">10</span>);</div><div class="line">hold on;</div><div class="line">x=<span class="number">-3</span>:<span class="number">.01</span>:<span class="number">3</span>;<span class="comment">%对x进行排序hum（？）.01=0.01</span></div><div class="line">plot(x,polyval(p2,x),<span class="string">'r--'</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>使用<strong>fzero(funhandle,xvalue)</strong>求解func=0时在xvalue附近的解。其中funchandle也可以使用<strong>匿名函数</strong>。</p>
</li>
<li>使用函数<strong>fminbnd(funchandle,xmv,xMv)</strong>寻找在区间[xmv,xMv]之间的解。</li>
</ol>
<h2 id="微分积分"><a href="#微分积分" class="headerlink" title="微分积分"></a>微分积分</h2><p><strong>diff</strong>：diff实际上并不是专门用于“求微分”的函数，更确切地说，diff函数求解出的是<strong>差分</strong>，其实也就是一组数据或一组向量或一组二维数组…的后一项减前一项：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt; diff(<span class="number">1</span>:<span class="number">5</span>)</div><div class="line"></div><div class="line"><span class="built_in">ans</span> =</div><div class="line"></div><div class="line">     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span></div></pre></td></tr></table></figure>
<p>说diff可以用来求微分是因为在定义上，如果某一函数的微分在某一可微点$x_0$为：$dy$，则在该点，对于增量$\delta y=f(x_0+\delta x)-f(x_0)$，则应该有：$\delta y=dy+o(\delta x)$。因此，实际上在x取值间隔足够小的时候，x的取值间隔就是这里的$\delta x$，可以用来近似微分。<br><img src="https://zh.wikipedia.org/wiki/%E5%BE%AE%E5%88%86#/media/File:Dydx_zh.jpg" alt=""></p>
<p>如果使用diff来求导数，需要注意是$\frac{dy}{dx}$，因此需要对求出的数据进行除以$\delta x$的操作。</p>
<p>比如：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt; x=-<span class="built_in">pi</span>:<span class="number">0.1</span>:<span class="built_in">pi</span>;</div><div class="line">&gt;&gt; f=@(x)(<span class="built_in">sin</span>(x));</div><div class="line">&gt;&gt; y_ori=f(x);</div><div class="line">&gt;&gt; y_diff=diff(y_ori);</div><div class="line">&gt;&gt; y_div=y_diff/<span class="number">0.1</span>;</div><div class="line">&gt;&gt; figure;plot(y_ori,<span class="string">'r-'</span>);hold on;plot(y_diff,<span class="string">'b-'</span>);hold on;plot(y_div,<span class="string">'k-'</span>);legend(<span class="string">'ori'</span>,<span class="string">'diff'</span>,<span class="string">'div'</span>);</div></pre></td></tr></table></figure>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-3-19/26208230.jpg" alt=""></p>
<h1 id="4画图"><a href="#4画图" class="headerlink" title="4画图"></a>4画图</h1><p><strong>hist</strong>:画直方图</p>
<ol>
<li>hist(x)：默认10个等宽bin，将给的数据分入这十个bin，显示每个bin中的数目。</li>
<li>hist(x,scaler)：scaler个等宽bin，将给的数据分入这几个bin。</li>
<li>hist(x,vector)：vector指定的bin，将给的数据分入这些bin。</li>
<li>[counts,centers]=hist(x)：每个bin中的个数以及bin的中心</li>
</ol>
<p><strong>histc</strong>：hist衍生</p>
<ol>
<li>hist(x,vector)：不会像hist那样plot出来，只得要对应数据，可以自己去plot。</li>
</ol>
<p><strong>bar</strong>：hist类似</p>
<ol>
<li>bar(x,y,option)：x是bin，y是hist中对应的x，画直方图，不同的是这里是累加过程。option可选style，具体可help。</li>
</ol>
<p><strong>randn</strong>：随机数——更多用法请查看<a href="https://cn.mathworks.com/help/matlab/ref/randn.html?s_tid=doc_ta" target="_blank" rel="external">官方randn文档</a></p>
<ol>
<li>randn(n)：有<strong>正态分布</strong>的随机数组成的nxn矩阵。</li>
<li>randn([a b …])：随机的x维矩阵</li>
<li>randn：一个随机数</li>
<li>$\mu+\sigma*randn(n)$：一个nxn的矩阵是$\mu$方差是$\sigma^2$的正态分布</li>
<li>s=rng;rng(s);<strong>保存/重置</strong>随机生成数状态</li>
<li><code>mu=[1 2];sigma=[1 0.5;0.5 2];R=chol(sigma);z=repmat(mu,10,1)+randn(10,2)*R;</code>其中：repmat是将已有矩阵复制成给定个数：nxn or mxn</li>
</ol>
<p><strong>cumsum</strong>：累加</p>
<ol>
<li>cumsum(A)：将从左至右累加A中元素并得出一个新的APLUS</li>
</ol>
<h2 id="CELL"><a href="#CELL" class="headerlink" title="CELL"></a>CELL</h2><ol>
<li>cell可以定义但不必须：<code>A=cell(2,3);</code> <code>A={&#39;hello&#39;,&#39;world&#39;;[1 2 3 ;4 5 6],17};</code></li>
<li>cell寻址使用大括号<code>A{1}=[1 2 3];</code> <code>A{1,2}=18;</code></li>
</ol>
<h2 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h2><ol>
<li>结构可以定义但不必须：<code>s=struct</code> <code>s=struct(&#39;name&#39;,&#39;yayi&#39;,&#39;age&#39;,19)</code></li>
<li>结构访问同对象：<code>s.name=&#39;yang&#39;</code></li>
<li>使用类似指针的东西：<code>s=struct(&#39;name&#39;,{&#39;yayi&#39;,&#39;yuki&#39;},&#39;age&#39;,{19,13});p1=s(1);p2=s(2);</code></li>
<li>使用函数getfield获取结构体的各个field或是使用函数fieldnames。</li>
</ol>
<p><a href="https://cn.mathworks.com/help/matlab/math/resample-image-with-gridded-interpolation.html" target="_blank" rel="external">对图像进行网格插值</a></p>
<h1 id="5符号与模拟"><a href="#5符号与模拟" class="headerlink" title="5符号与模拟"></a>5符号与模拟</h1><ol>
<li>-</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a=sym(<span class="string">'1/3'</span>);</div><div class="line">b=sym(<span class="string">'2/3'</span>);</div><div class="line">c=a+b;</div><div class="line"><span class="comment">%好像哪个语言里面也有这种功能....具体忘记是哪个了...</span></div></pre></td></tr></table></figure>
<ol>
<li>-</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pretty(<span class="string">'x+x+3*x^2+2*x^2'</span>);</div><div class="line"><span class="comment">%就是合并同类项</span></div></pre></td></tr></table></figure>
<ol>
<li>-</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">%对矩阵：</span></div><div class="line">a=sym(<span class="string">'[a b;c d]'</span>);</div><div class="line"><span class="comment">%这样出来的矩阵，可以进行诸如* inv det的各种矩阵运算</span></div></pre></td></tr></table></figure>
<hr>
<h1 id="双变量分析"><a href="#双变量分析" class="headerlink" title="双变量分析"></a>双变量分析</h1><h2 id="相关系数计算"><a href="#相关系数计算" class="headerlink" title="相关系数计算"></a>相关系数计算</h2><h3 id="Pearson"><a href="#Pearson" class="headerlink" title="Pearson"></a>Pearson</h3><h3 id="Spearman"><a href="#Spearman" class="headerlink" title="Spearman"></a>Spearman</h3><p><strong>适用于</strong>：有序变量之间<strong>关联强度</strong>与<strong>方向测量</strong>。适合于偏斜分布数据。</p>
<p>$$\rho=1-\frac{6\sum_{i=1}^{n}{(x_i-y_i)^2}}{n(n^2-1)}$$</p>
<p>其中x，y都应该是有序变量。</p>
<p>可以用来检测排序总体之间是不是存在相关性：<br>零假设是两个变量之间不存在相关关系，即$\rho<em>s=0$，检验的统计量$t</em>\gamma=\rho_s\sqrt{n-1}$。当n&gt;=30，采用z检验。</p>
<h3 id="jackknife"><a href="#jackknife" class="headerlink" title="jackknife"></a>jackknife</h3><h2 id="经典线性回归分析与预测"><a href="#经典线性回归分析与预测" class="headerlink" title="经典线性回归分析与预测"></a>经典线性回归分析与预测</h2><h2 id="线性回归扩展"><a href="#线性回归扩展" class="headerlink" title="线性回归扩展"></a>线性回归扩展</h2><p>验证正态分布：<code>chizgof</code></p>
<ol>
<li>matlab使用反斜线算子<code>\</code>解线性方程组。</li>
<li><code>help regress</code> <code>help robustfit</code>：识别数据中的异常值</li>
<li><code>leverage</code>：计算X的QR分解之后的杠杆值：这个值接近1，则预测值接近于实际值。</li>
</ol>
<p><strong>aoctool</strong>函数：</p>
<p><strong>MATLAB应用</strong></p>
<h3 id="交互式多线性回归分析："><a href="#交互式多线性回归分析：" class="headerlink" title="交互式多线性回归分析："></a>交互式多线性回归分析：</h3><p>###逐步回归分析：** <code>stepwise</code></p>
<h3 id="岭回归：针对多重共线问题"><a href="#岭回归：针对多重共线问题" class="headerlink" title="岭回归：针对多重共线问题"></a>岭回归：针对多重共线问题</h3><p><code>ridge</code></p>
<p>### </p>
<p>polyconf polydemo</p>
<p>nlparci nlinfit nlintool nlmefit glmfit glmval</p>
<p>treedisp treeval</p>
<h1 id="零碎的"><a href="#零碎的" class="headerlink" title="零碎的"></a>零碎的</h1><ol>
<li>tic toc</li>
<li>binocdf</li>
<li>mnpdf</li>
<li>mnrnp?</li>
<li>poiss-poisspdf（泊松分布的概率密度函数）-poissoncdf</li>
</ol>
]]></content>
      
        <categories>
            
            <category> matlab </category>
            
        </categories>
        
        
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[编译复习课]]></title>
      <url>/2018/01/17/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%A4%8D%E4%B9%A0%E8%AF%BE/</url>
      <content type="html"><![CDATA[<p>词法分析语法分析语义分析：分析阶段<br>中间…综合阶段</p>
<p>使用算法构造对应模块程序</p>
<p>各个阶段做什么事？<br>通常倒过来问：某个事情在哪个阶段做？</p>
<p>词法：将字符流切成单词流<br>语法：将单词流构建语法树<br>语义：类型检查、变量定义与使用规则<br>中间代码生成：语法树-&gt;中间代码<br>代码优化：基本块、流图、基本块内数据流分析、跨基本快数据流分析<br>代码生成：三地址吗转化汇编代码</p>
<p>预处理器：文本替换（宏、包含文件</p>
<p>汇编器、链接器：<br>加载器：将程序load到内存中-》修改程序中的地址（啊啊啊啊我又想到os了😭</p>
<p>符号表管理：词法、语法、以后<br>错误处理：语法阶段</p>
<p>几个阶段如何组织？</p>
<p>前四个阶段包括中间代码，之前，主要面向高级语言<br>后面的包括优化都是后端</p>
<h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>单词：类别、符号串分组<br>模式：单词<_>词素<br>词素是具体字符串 单词是一种类型(NUMBER)<br>模式是对一种单词的描述</_></p>
<p>不可能用自然语言描述组织：</p>
<h2 id="正则表达式——模式"><a href="#正则表达式——模式" class="headerlink" title="正则表达式——模式"></a>正则表达式——模式</h2><p><strong>符号串集合</strong>。<br>有穷集、无穷集-》处理无穷集</p>
<p>使用简单语言（符号串集合）的运算描述复杂语言</p>
<p>定义：</p>
<pre><code>1. 符号表中的符号（表示长度为一的符号串集合
2. $\epsilon$
3. A|B
4. AB
5. A*
6.(A)
</code></pre><p>lex支持更多形式，但是这四种运算已经是完备的了。</p>
<p>字母表、符号串、语言</p>
<p>运算法则：服从集合与符号串</p>
<p>等价：运算出的符号串集合相同</p>
<p>正则定义：类似于上下文无关文法</p>
<p>符号简写：<br>+：正则闭包<br>？：有或没有、0或1次连接<br>[]：或</p>
<p>基本概念<br>正则表达式的设计</p>
<h3 id="有限自动机"><a href="#有限自动机" class="headerlink" title="有限自动机"></a>有限自动机</h3><p>非确定有限自动机NFA<br>五元组<br>{状态集合，字母表，又想变（迁移函数），顶点（初态），终态集合}</p>
<p>DFA无epsilon边，<br>NFA发出相同符号边转到不同状态<br>===NFA不确定但是DFA确定</p>
<p>epsilon体现在状态迁移函数的定义域，多条边体现在值域</p>
<p>确定有限自动机DFA</p>
<p>一个状态一个符号唯一确定下一个状态</p>
<p>五元组<br>状态转换图<br>状态转换矩阵：行是状态，列是字符表中符号==》计算机容易存储</p>
<p>判断等价===》相同正则</p>
<p>等价的nfa与dfa，dfa时间复杂性一定是更优的。</p>
<p>正则式-》NFA</p>
<p>汤姆森构造法：正则-&gt;NFA   是语法制导翻译的方法</p>
<p>NFA-&gt;DFA——子集构造法</p>
<p>目标是构造与NFA等价的DFA。<br>等价：识别的字符串集合是一样的<br>动态描述：二者对相同的字符串结果相同。在NFA里面停下的一堆状态与DFA中的某个状态等价。</p>
<p>障碍：无穷。</p>
<p>最小化DFA：概念——区分</p>
<p>摸个符号串区分两个状态：停下的状态一个是acc一个是其他。<br>若分散在两个现有集合——分开。<br>加死状态：状态迁移矩阵不能有项是空：非终态</p>
<h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p>概念</p>
<p>上下文无关文法：CFG：四元式（终结符、非终结符、开始符号、产生式集合）</p>
<p>形式化地描述：A-&gt;α</p>
<p>推导、语言、句型、句子<br>最走推到、最右推导<br>语法树、二义性文法<br>CFG等价</p>
<p>CFG与正则式</p>
<p>自顶向下语法分析</p>
<p>算符文法：没有连续的非终结符、不能有ε产生式</p>
<p>优先级计算：</p>
<p>句柄确定&lt;=&gt;</p>
<p>活前缀：前缀末端不超过最右句柄的末端</p>
<p>构造识别活前缀的DFA。closure goto</p>
<p>概念、分析表</p>
<p>预测分析</p>
<p>SLR、LR</p>
<h2 id="语法制导翻译"><a href="#语法制导翻译" class="headerlink" title="语法制导翻译"></a>语法制导翻译</h2><p>S属性、L属性 设计</p>
<p>结合：自顶向下 继承；自底向上 综合</p>
<p>结构等价：表达式树等价<br>名字等价：虎太郎披上羊皮就不是灰太狼</p>
<p>类型表达式的上下文无关文法</p>
<p>中间代码生成：临时名字的重用<br>三地址码生成：按照算法构造</p>
<p>表达式-&gt;三地址码</p>
<p>代码优化</p>
<p>基本块、流图、从基本快口循环 下次引用 优化方法</p>
<p>目标代码生成<br>基本块内局部最优</p>
]]></content>
      
        <categories>
            
            <category> 编译 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编译 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[chap5-设备]]></title>
      <url>/2018/01/16/OS/chap5-%E8%AE%BE%E5%A4%87/</url>
      <content type="html"><![CDATA[<h1 id="设备基础"><a href="#设备基础" class="headerlink" title="设备基础"></a>设备基础</h1><p><strong>设备类型</strong></p>
<p>按功能分类</p>
<ol>
<li>存储设备：暂时或永久</li>
<li>I / O设备：人机交互</li>
<li>通信设备：数据交换和传输<br>按数据管理方式分类</li>
<li>块流：使用不同大小的块作为数据管理的基本单位</li>
<li>字节流：使用字节作为DM的基本单位</li>
</ol>
<p>按设备分配进行分类</p>
<ol>
<li>独占设备：低速I / O设备</li>
<li>共享设备：高速I / O设备</li>
<li>虚拟设备：通过软件模拟硬件</li>
</ol>
<p>按工作模式分类</p>
<ol>
<li>逻辑设备：由OS维护的数据结构</li>
<li>物理设备：不同种类的硬件</li>
</ol>
<p><strong>设备管理讨论</strong></p>
<p>设备的复杂性：<br>不同的设备有不同的工作模式<br>不同设备使用不同的数据格式<br>不同的设备支持不同的接口</p>
<p>有关设备的重要问题：<br>速度：电脑的瓶颈<br>HCI：用户造成的操作错误<br>兼容性：独立于设备，独立于操作系统</p>
<p>设备管理的关键策略：<br>高效合理：协调CPU，RAM和设备之间的速度差异。 以更高效的方式控制和管理设备。<br>方便：兼容，安全，稳定<br>标准化：IT行业的基础</p>
<p><strong>设备管理目的</strong></p>
<p>独立于设备的编程接口：</p>
<ol>
<li>隐藏硬件组件之间的差异</li>
<li>为用户提供简单而通用的控制方法</li>
<li>保持用户进程的安全性和稳定性</li>
</ol>
<p>高效的管理策略</p>
<ol>
<li>分配和释放：像进程调度一样</li>
<li>性能增强：提高数据传输速度，使设备更适应CPU和RAM</li>
<li>保护：内部和外部保护，死锁</li>
</ol>
<p>设备管理的困难</p>
<ol>
<li>端口地址管理</li>
<li>控制模式设计</li>
<li>死锁：不合理的设备请求或分配</li>
</ol>
<h2 id="硬件介绍"><a href="#硬件介绍" class="headerlink" title="硬件介绍"></a>硬件介绍</h2><p>建构：</p>
<ol>
<li>物理组件：由模拟信号驱动的设备</li>
<li>电子部件：可以响应和执行数字指令的控制器或适配器</li>
</ol>
<p>控制器/适配器</p>
<ol>
<li>主板扩展插槽</li>
<li>适配器中的寄存器和数据缓冲区</li>
</ol>
<p>适配器的责任</p>
<ol>
<li>地址转换：将逻辑地址映射到设备端口</li>
<li>数据传输：接收或发送所需的数据</li>
<li>命令执行：将数字指令转换为模拟信号来驱动物理组件</li>
<li>性能增强：应用缓存和其他方法来提高设备的性能</li>
</ol>
<p><strong>电阻式触摸屏工作原理</strong>：p7</p>
<h3 id="设备的工作流程"><a href="#设备的工作流程" class="headerlink" title="设备的工作流程"></a>设备的工作流程</h3><p>硬件工作周期的步骤：启动，自检，运行，结果检查和错误处理</p>
<p>设备端口</p>
<ol>
<li>状态寄存器：存储设备的当前状态</li>
<li>指令寄存器：存储收到的指令</li>
<li>数据缓冲区：存储所需的数据</li>
</ol>
<p>CPU和设备之间的通信机制</p>
<ol>
<li>设置状态和指令寄存器的内容</li>
<li>设备执行指令，或完成数据通信</li>
<li>工作完成后，设备通过中断通知CPU</li>
</ol>
<p>示例：IBM软盘驱动器</p>
<ol>
<li>指令集：读取，写入，查找，格式化等</li>
<li>参数：由CPU设置，存储在设备寄存器中</li>
<li>位流：CPU逐位发送数据，软驱将数据缓冲区中的位排列成字节，并进行必要的检查</li>
</ol>
<p><strong>CPU与设备之间的通信</strong>：参见接口</p>
<h3 id="如何访问设备？"><a href="#如何访问设备？" class="headerlink" title="如何访问设备？"></a>如何访问设备？</h3><ol>
<li>I / O端口<ol>
<li>设备的寄存器的ID</li>
<li>计算机维护I / O通信的I / O端口列表</li>
<li>缺点：分离内存空间和设备的寄存器<br>其实还有，用于端口的指令不如用于内存访问的指令多</li>
</ol>
</li>
</ol>
<ol>
<li>内存映射I / O<ol>
<li>所有器件的寄存器都映射到内存空间</li>
<li>每个寄存器都分配一个唯一的内存地址</li>
</ol>
</li>
</ol>
<blockquote>
<p>内存IO映射<br>优点</p>
<ul>
<li>将I / O地址视为内存地址的一部分，会生成全局地址空间</li>
<li>I / O和内存的区别是隐藏的，程序员可以设计复杂的I / O程序</li>
<li>I / O地址可以被有效地保护(?)<br>坏处<br>硬件很难区分内存和I / O设备的地址<br>管理成本较高，在双公交或多母线架构下更为复杂</li>
</ul>
</blockquote>
<p>实际上存在混合编址方案：设备的数据缓存被map到内存，寄存器由io端口指定。</p>
<ol>
<li>总线：与前面的并不是并列关系</li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/95853200.jpg" alt=""><br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/15945208.jpg" alt=""></p>
<h3 id="设备工作模式"><a href="#设备工作模式" class="headerlink" title="设备工作模式"></a>设备工作模式</h3><h4 id="忙等待"><a href="#忙等待" class="headerlink" title="忙等待"></a>忙等待</h4><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/31066338.jpg" alt=""></p>
<p>特殊内核进程将数据发送到设备端口;<br>进程重复检查端口，直到端口可用并发送其余数据;<br>内核进程完成后，用户进程继续运行;<br>缺点：CPU浪费太多——接口中的查询方式</p>
<h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/93569841.jpg" alt=""></p>
<p>特殊内核进程将数据发送到设备端口;<br>进程进入休眠状态，CPU将运行其他进程;<br>数据缓冲区为空后，设备向CPU发送中断;<br>内核进程被唤醒并发送其余的数据<br>缺点：频繁的中断是耗时的——接口中的中断输出方式</p>
<h4 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h4><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-17/96816977.jpg" alt=""></p>
<p>用户进程导致CPU陷阱，特殊内核进程设置设备中的寄存器并退出trap;<br>设备直接从内存中读取数据;<br>工作完成后，设备向CPU发送中断;<br>用户进程被唤醒并继续运行<br>——只需一次中断就可以</p>
<p><strong>DMA实现细节</strong>：请参考书上p187</p>
<p>DMA的内部结构：</p>
<ol>
<li>单路径：只有一套寄存器，只能控制一个I / O设备</li>
<li>多路径：多套寄存器，可同时控制多个I / O设备</li>
<li>DMA调度：在多个通道之间切换</li>
</ol>
<p>DMA的工作模式：</p>
<pre><code>1. 数据传输模式：一次一个字VS块模式
</code></pre><ol>
<li>周期窃取：DMA请求一个字的总线并得到它</li>
<li>突发模式：DMA获取总线并启动一系列的数据传输</li>
<li>Fly-by模式：DMA告诉设备控制器直接将数据发送到内存</li>
<li>设备到设备和存储器到存储器：DMA从设备/存储器获取字并将其发送到目标地址</li>
</ol>
<p>DMA中使用的地址：</p>
<ol>
<li>物理地址：MMU位于CPU中，CPU将对应内存的虚拟地址转换以后给DMA地址寄存器</li>
<li>虚拟地址：MMU位于内存中，这种情况很少</li>
<li>缓冲：消除设备之间的速度差异</li>
</ol>
<p>为了避免DMA过于复杂，磁盘读入数据之后将数据存在自己的缓冲区，一是为了检验校验和，二是为了减少总线使用减少DMA复杂度。</p>
<blockquote>
<p>DMA请求<br>CPU对DMA控制器初始化，并向I/O接口发出操作命令，I/O接口提出DMA请求。<br>DMA响应<br>DMA控制器对DMA请求判别优先级及屏蔽，向总线裁决逻辑提出总线请求。当CPU执行完当前总线周期即可释放总线控制权。此时，总线裁决逻辑输出总线应答，表示DMA已经响应，通过DMA控制器通知I/O接口开始DMA传输。<br>DMA传输<br>DMA控制器获得总线控制权后，CPU即刻挂起或只执行内部操作，由DMA控制器输出读写命令，直接控制RAM与I/O接口进行DMA传输。<br>在DMA控制器的控制下，在存储器和外部设备之间直接进行数据传送，在传送过程中不需要中央处理器的参与。开始时需提供要传送的数据的起始位置和数据长度。<br>DMA结束<br>当完成规定的成批数据传送后，DMA控制器即释放总线控制权，并向I/O接口发出结束信号。当I/O接口收到结束信号后，一方面停 止I/O设备的工作，另一方面向CPU提出中断请求，使CPU从不介入的状态解脱，并执行一段检查本次DMA传输操作正确性的代码。最后，带着本次操作结果及状态继续执行原来的程序。</p>
</blockquote>
<p>DMA是必需的吗？</p>
<h3 id="IO通道"><a href="#IO通道" class="headerlink" title="IO通道"></a>IO通道</h3><p>DMA的缺点<br>    缓慢而简单，不能支持复杂的I / O编程<br>I / O通道简介<br>    特殊芯片（PU）用于管理I / O设备<br>    字符复用信道，选择复用信道，组复用信道<br>    I / O通道与CPU共享内存，并与CPU分别工作<br>I / O通道的结构<br>    CAW：地址寄存器，将I / O通道程序的地址存储在内存中<br>    CCW：命令寄存器，存储当前的I / O命令<br>    CSW：状态寄存器，用于存储I / O操作结果的状态<br>    CDW：数据寄存器，数据缓冲区</p>
<pre><code>![](http://oysmkdi7t.bkt.clouddn.com/18-1-17/67957883.jpg)
</code></pre><h2 id="IO软件"><a href="#IO软件" class="headerlink" title="IO软件"></a>IO软件</h2><p>同步阻塞VS异步传输<br>    阻塞：用户程序将暂停（挂起），直到I / O操作完成<br>    数据传输：中断到来之前，CPU正在异步工作（对程序来说是阻塞）<br>错误处理<br>    硬件级错误处理：由设备执行（尽量在底层执行）<br>    高级错误处理：将状态返回到更高级别并由内核/用户程序处理<br>统一命名：一个文件或一个设备的名字应该是一个简单的字符串或是一个整数，不应依赖于设备：<br>    设备独立的概念：<strong>访问任意IO设备而无须事先制定设备</strong><br>    使用I / O设备地址映射名称<br>缓冲<br>    如何根据缓冲区维护数据缓冲区和控制数据传输：数据离开设备通常不会直接到达目的地。（实时约束）<br>设备的分配和释放<br>    如何实现I / O设备共享？<br>    如何避免死锁？</p>
<h3 id="IO软件层次"><a href="#IO软件层次" class="headerlink" title="IO软件层次"></a>IO软件层次</h3><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-17/68828231.jpg" alt=""></p>
<h4 id="中断-1"><a href="#中断-1" class="headerlink" title="中断"></a>中断</h4><p>如何由用户控制I / O设备？<br>    用户进程请求I / O并被阻止<br>    设备驱动程序启动I / O操作并被阻止<br>    I / O设备完成操作并发送中断<br>    设备驱动程序完成并且用户进程被唤醒<br>中断的工作流程<br>    硬件级错误处理：由设备执行<br>    高级错误处理：将状态返回到更高级别并由内核/用户程序处理</p>
<p><strong>在终端形成之后，在软中断中</strong>：<br>保存没被硬件保存的所有寄存器<br>为中断服务程序设置上下文（运行环境）<br>为中断服务程序设置栈<br>应答中断控制器, 再次开放中断<br>寄存器从被保存的地方复制到进程表中<br>运行中断服务程序<br>为下次要运行进程设置ＭＭＵ上下文<br>装载新的进程寄存器<br>开始运行新进程</p>
<h4 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h4><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-17/8186980.jpg" alt=""></p>
<p>对设备执行操作进行控制的代码是设备驱动程序</p>
<p>设备驱动程序的逻辑位置被指明<br>驱动程序与设备控制器之间通过总线完成通信</p>
<p>设备驱动程序介绍<br>    控制设备控制器的说明：更上层，忽视了设备之间的区别<br>    设备驱动程序始终视为内核进程：这样才能访问设备控制的寄存器（可以作为用户进程，需要系统调用，消除系统崩溃的一个源头）<br>    OS为抽象驱动程序提供统一的接口：如上图<br>    设备驱动程序：静态库或动态库（目前主流是动态）<br>设备驱动程序的工作流程<br>    接收并检查高级进程发送的参数<br>    检查设备并启动设备（当前是不是在使用？初始化设备，电源需求，日志等）<br>    配置设备的寄存器（将向设备发送的指令存进设备控制器的控制寄存器，检查控制器是不是已经接收命令并准备接受下一个命令，直到所有命令都送出）<br>    接收I / O操作的状态<br>设备驱动程序的重要问题<br>    同步阻塞VS无延迟运行（需要长时间处理，设备驱动程序进程阻塞自己，直到中断到来唤醒；不需要长时间，完成后应检查错误。随后可能会将数据发给某个设备无关软件，返回一个信息。如果还有命令就执行，没有的话就阻塞自己）<br>    可重入：驱动程序的复杂性（第一次调用完成之前第二次到来<br>    可热插拔的系统和内存请求：传送必须被终止，请求应该被抹去。有时候新设备的到来可能夺走旧设备的资源</p>
<pre><code>设备驱动程序以阿布年不允许系统调用，但是可以调用内核的某些过程。比如DMA、定时器、分配释放硬接线的内存页面等。
</code></pre><h3 id="与设备无关的io软件"><a href="#与设备无关的io软件" class="headerlink" title="与设备无关的io软件"></a>与设备无关的io软件</h3><ol>
<li><p>设备驱动程序的统一接口</p>
</li>
<li><p>引入缓冲的方式</p>
</li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-17/71738832.jpg" alt=""></p>
<p>(a) 无缓冲输入<br>(b) 缓冲区放在用户空间<br>(c) 缓冲区在核心空间，然后被复制到用户空间<br>(d) 在内核空间有双缓冲区</p>
<ol>
<li>适当的使用缓冲</li>
</ol>
<p>缓冲技术在io中很普遍，但是数据传递中太多的缓冲会影响系统性能</p>
<ol>
<li><p>IO中错误报告：</p>
<ol>
<li>建立io的错误处理机制，尽量在底层处理错误</li>
<li>分别处理不同错误：如编程/io</li>
</ol>
</li>
<li><p>分配与释放专用设备</p>
<p>根据设备使用特性建立分配与释放原则（独享设备／共享设备），直接释放或队列管理．</p>
</li>
<li><p>建立与设备无关的数据传递格式</p>
<p>不同设备数据传递格式不同，但须用软件隔离此特性，使上层软件不必考虑设备访问中的这一特性，如访问块大小的转换。</p>
</li>
</ol>
<h3 id="用户空间的IO"><a href="#用户空间的IO" class="headerlink" title="用户空间的IO"></a>用户空间的IO</h3><p> SDK / DDK或编程库<br>    隐藏设备驱动程序的细节，使用户访问I / O设备变得简单<br>    如“cout”，“print”……<br>后台程序和守护进程<br>    用户的虚拟设备<br>    设备共享的缓冲和调度</p>
<h3 id="spooling"><a href="#spooling" class="headerlink" title="spooling"></a>spooling</h3><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/49382128.jpg" alt=""></p>
<p>预输入模块：将作业输入到输入井中；<br>缓输出模块：将作业结果缓冲式输出到独享设备上；<br>作业调度模块：控制作业从输入井中取数，向输出井中送数；<br>输入、输出井：在磁盘上开辟的两个 “井”区域。 </p>
<h1 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h1><p>磁盘是一种外设，CPU和内存访问速度比磁盘快若干个数量级，磁盘系统的性能对整个系统性能有重要影响，磁盘设备管理的目标就是提高磁盘的访问速度和安全性。从以下几方面讲：</p>
<pre><code>1. 磁盘硬件及访问性能
2.RAID
3.CD-ROM
4.可刻录／可重写ＣＤ
5.ＤＶＤ
6. 磁盘格式化问题
7.磁盘访问调度策略
</code></pre><p>柱面定位时间：磁头移动到指定柱面的机械运动时间；<br>旋转延迟时间：磁盘旋转到指定扇区的机械运动时间；它与磁盘转速相关，如：软盘转速可为600r/m(每分钟转速)，硬盘可为10000r/m。<br>数据传送时间：从指定扇区读写数据的时间。<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-17/5015339.jpg" alt=""></p>
<pre><code>柱面定位（寻道）时间在访问时间中是主项，合理组织磁盘数据的存储位置可提高磁盘I/O性能。
</code></pre><p>例：读一个128KB大小的文件：<br>(1)文件若由8个连续磁道(每磁道32个扇区)上的256个扇区构成：<br>        20ms+(8.3ms+16.7ms)<em>8=220ms;<br>其中，柱面定位时间为20ms，旋转延迟时间为8.3ms，32扇区数据传送时间为16.7ms；<br>(2)文件若由256个随机分布的扇区构成：<br>        (20ms+8.3ms+0.5ms)</em>256=7373ms;<br>其中，1扇区数据传送时间为0.5ms；<br>随机分布时的访问时间为连续分布时的33.5倍。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>短查找时间优先算法（SSTF）：按磁头臂移动最小距离优先分配磁盘。磁盘使用率高，分配快。</p>
<p>扫描(SCAN)算法：磁头沿一个方向移动，并为请求进程分配磁盘，然后反方向移动再进行分配。保证队列中不出现饿死情况。（或称电梯法）</p>
<p>循环扫描(C-SCAN)算法：磁头沿一个方向移动，并为请求进程分配磁盘，到头后返回重新移动。可减少等待时间。</p>
<p> N步扫描(N-step-SCAN)算法：把磁盘I/O请求队列分成长度为N的段，每次使用扫描算法处理这N个请求。当N=1时，该算法退化为FIFO算法。</p>
<p> 双队列扫描(FSCAN)算法：请求队列分成两个，一个用做处理，一个用做存放新到请求。</p>
]]></content>
      
        <categories>
            
            <category> OS </category>
            
            <category> 课 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OS </tag>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[chap6-死锁]]></title>
      <url>/2018/01/16/OS/chap6-%E6%AD%BB%E9%94%81/</url>
      <content type="html"><![CDATA[<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>死锁</strong>：如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，该进程集合是死锁的。</p>
<p>大多数情况下，都是在等另外的进程放弃所占的资源，但是由于所有的进程都不能运行，他们永远也等不到自己需要的资源</p>
<p><strong>死锁产生条件</strong>：</p>
<ol>
<li>互斥条件：每个资源要么已经分配了一个进程，要么就是可用的</li>
<li>占有和等待条件：已经得到了某个资源的进程可以请求新的资源</li>
<li>不可抢占条件：已经分配给一个进程的资源不能强制性被抢占，只能被占有它的进程显式释放</li>
<li>环路等待条件：死锁发生时，系统中一定有两个或者两个以上的进程组成的一条环路，该换路中的每一个进程都在等待下一个进程占有的资源。</li>
</ol>
<p><strong>死锁的危害</strong>：死锁进程永远不能活动，被持有的资源永远不可以访问<br>-&gt;不合理的资源获取可能会产生死锁（闭环，像数据库一样）</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol>
<li><p>破坏4个条件，阻碍死锁发生</p>
</li>
<li><p>避免死锁发生</p>
</li>
<li><p>死锁检测与恢复</p>
</li>
<li><p>鸵鸟</p>
</li>
</ol>
<h3 id="prevention"><a href="#prevention" class="headerlink" title="prevention"></a>prevention</h3><p>破坏四个条件</p>
<ol>
<li>互斥条件：虚拟共享资源<br> 避免分配那些不是绝对必须的资源，尽量做到尽可能少的进程可以真正请求资源<br> eg：使用打印机守护进程以及假脱打印机技术</li>
<li>占有和等待条件：禁止已持有资源的进程等待其他资源<br> 在一次分配中满足一个进程的所有资源需求，否则进程将被阻塞，直到所有需要的资源都可用</li>
<li>不可抢占条件：夺取死锁进程的资源并给其他进程<br> 避免引发混乱，使用虚拟化技术</li>
<li>环路等待条件：为每种资源分配类型标识，进程必须按照升序/降序来请求资源。<br> 一种变体是不需要一定升序，但是需要不允许进程请求比当前所占有资源编号低的资源。</li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/49382128.jpg" alt=""></p>
<h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p>preventation不合理。</p>
<p>系统必须判断这次请求资源是不是安全的，并且只能在安全的情况下得到资源。</p>
<p><strong>安全状态</strong>：存在一个合理的资源分配序列<br><strong>不安全状态</strong>：不存在可以避免死锁的资源分配序列</p>
<p>避免死锁的机制：os只在安全的情况下分配资源。<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/33686334.jpg" alt=""></p>
<p>阴影部分不能进。</p>
<h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><h4 id="单资源"><a href="#单资源" class="headerlink" title="单资源"></a>单资源</h4><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/66291438.jpg" alt=""></p>
<p>查看是否有进程还需要的资源数小于系统剩余的资源数，如果有，就分给他，如果没有，会产生死锁。</p>
<p>也可以这样说：如果一个进程请求资源，检查是不是可以给他。</p>
<h4 id="多资源"><a href="#多资源" class="headerlink" title="多资源"></a>多资源</h4><p>与单资源差不多，但是需要每一个还需要的资源数都是小于剩余的资源数，如果存在，就给，然后收回这个已经完成的资源，如果没有，就不可能成功了。</p>
<h3 id="安全状态与死锁"><a href="#安全状态与死锁" class="headerlink" title="安全状态与死锁"></a>安全状态与死锁</h3><p>系统安全-&gt;没有死锁<br>没有死锁不一定是系统安全。但是只要确保系统是安全的，就一定不会死锁。</p>
<h3 id="死锁检测与恢复"><a href="#死锁检测与恢复" class="headerlink" title="死锁检测与恢复"></a>死锁检测与恢复</h3><p>守护进程判断运行状态，长时间不运行则认为进入思索。</p>
<p>可以使用图、集合、向量、矩阵等记录资源分配状态，试图找到环路。</p>
<p>请求矩阵中的向量定义成qij，表示进程i请求类型j的资源量，代表当前进程产生的资源请求<br>初始态所有进程无标记，通过算法标记进程<br>最后查看：若有无标记的进程，则说明有死锁现 象存在</p>
<p><strong>算法</strong>：<br>1）在分配矩阵中标记一行全为0的进程<br>2）向量W初始化成可用向量Available<br>3）按下标i查找，进程i未标记并且该进程的请求向量小于等于W，就进行标记；若找不到这样的行，算法终止。<br>4）若找到这样的行，标记进程i后，再把分配矩阵中的相应行加到W中，返回步骤3。</p>
<p>其实就是银行家算法</p>
<p><strong>恢复</strong>：</p>
<ol>
<li>抢占</li>
<li>Backdating：设置检查点在进程中，当检测到死锁时，进程将返回到检查点。</li>
<li>进程查杀：直接杀死进程。</li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/76831176.jpg" alt=""></p>
<h2 id="非资源死锁"><a href="#非资源死锁" class="headerlink" title="非资源死锁"></a>非资源死锁</h2><ol>
<li><p>两阶段加锁<br>对需要修改的数据：先请求加锁，再修改数据；若有一个数据已加锁，进程则释放所有加锁的记录。（像csmaca一样</p>
</li>
<li><p>通信死锁<br>通信中多个进程发送信息，但需要阻塞当前进程等待对方回复。若发送信息丢失，则死锁。<br>解决办法：超时中断；</p>
</li>
<li><p>活锁<br>所谓活锁既是：进程没有死锁，但却无法运行下去，只是在不断的重复尝试，如冲突检测。</p>
</li>
<li><p>进程饿死<br>由于条件限制使有些进程请求永远无法得到服务，进程被饿死。从饿死进程角度看，像是发生了死锁。</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> OS </category>
            
            <category> 课 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OS </tag>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[流光]]></title>
      <url>/2017/12/16/%E6%B5%81%E5%85%89/</url>
      <content type="html"><![CDATA[<h1 id="生死桥"><a href="#生死桥" class="headerlink" title="生死桥"></a>生死桥</h1><p>怀玉心想，怎的每个人都要听他的心里话呢？到底心里有没有话？简简单单的一桩事儿，自家的事儿，哪有什么？世上各人都爱小事化大。</p>
]]></content>
      
        <categories>
            
            <category> 因寄所托 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Lab4_Document]]></title>
      <url>/2017/12/12/OS/Lab4_Document/</url>
      <content type="html"><![CDATA[<h1 id="Lab4-Document"><a href="#Lab4-Document" class="headerlink" title="Lab4-Document"></a>Lab4-Document</h1><p>1511266 杨颖</p>
<h2 id="Part-A-Multiprocessor-Support-and-Cooperative-Multitasking"><a href="#Part-A-Multiprocessor-Support-and-Cooperative-Multitasking" class="headerlink" title="Part A: Multiprocessor Support and Cooperative Multitasking"></a>Part A: Multiprocessor Support and Cooperative Multitasking</h2><h3 id="Multiprocessor-Support"><a href="#Multiprocessor-Support" class="headerlink" title="Multiprocessor Support"></a>Multiprocessor Support</h3><p>在本实验的开始部分，首先将为jos添加多核支持。在多核模式下，所有CPU地位平等，有相同的系统资源与IO总线访问权。但是，在系统启动时，多CPU可以被分为两类：BSP与AP。BSP在系统上电时接管机器，完成系统的初始化，随后，出于某种需要，BSP将会唤醒AP，AP也可以作为独立的CPU执行指令。</p>
<p>在这种系统之中，每个CPU都有一个模块是<strong>LAPIC</strong>，它负责系统的中断传递，为每个CPU提供一个独特的编号。</p>
<p>LAPIC是Local Advanced Programmable Interrupt Controller，local高级可编程中断控制器。LAPIC一般由中断信号、PRT、一组寄存器与其他一些部件组成，可以处理硬件的中断请求信息，并通知CPU进行处理。</p>
<p>在本次实验中，我们将会用到LAPIC模块的如下功能函数：</p>
<ol>
<li>cpunum()：</li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/87627035.jpg" alt=""></p>
<p>该函数中，通过访问lapic[ID]对应字段获得当前的cpu编号。</p>
<ol>
<li>lapic_startap():</li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/96651596.jpg" alt=""></p>
<p>这个函数中，BSP负责对尚未工作的AP进行初始化与唤醒操作。首先设置向量，然后发送INIT中断来重置其他CPU，最终发送STRARTUP信号与开始执行的位置，使一个CPU正式开始工作。</p>
<ol>
<li>lapic_init():</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span></div><div class="line">lapic_init(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span> (!lapicaddr) <span class="keyword">return</span>;</div><div class="line">	<span class="comment">// lapicaddr is the physical address of the LAPIC's 4K MMIO</span></div><div class="line">	<span class="comment">// region.  Map it in to virtual memory so we can access it.</span></div><div class="line">	<span class="comment">//lapiaddr是LAPIC的4K的MIMO区域的物理地址</span></div><div class="line">	<span class="comment">//把他映射到虚拟地址空间，就可以访问了</span></div><div class="line">	lapic = mmio_map_region(lapicaddr, <span class="number">4096</span>);</div><div class="line">	<span class="comment">//enable LAPIC；设置伪中断向量</span></div><div class="line">	<span class="comment">// Enable local APIC; set spurious interrupt vector.</span></div><div class="line">	<span class="comment">//#define SVR     (0x00F0/4)   // Spurious Interrupt Vector</span></div><div class="line">	<span class="comment">//#define ENABLE     0x00000100   // Unit Enable</span></div><div class="line"></div><div class="line">	<span class="comment">//in inc/trap.c</span></div><div class="line">	<span class="comment">//#define IRQ_OFFSET	32	// IRQ 0 corresponds to int IRQ_OFFSET</span></div><div class="line">	<span class="comment">//// Hardware IRQ numbers. We receive these as (IRQ_OFFSET+IRQ_WHATEVER)</span></div><div class="line">	<span class="comment">//#define IRQ_SPURIOUS     7</span></div><div class="line">	lapicw(SVR, ENABLE | (IRQ_OFFSET + IRQ_SPURIOUS));</div><div class="line"></div><div class="line">	<span class="comment">// The timer repeatedly counts down at bus frequency</span></div><div class="line">	<span class="comment">// from lapic[TICR] and then issues an interrupt.  </span></div><div class="line">	<span class="comment">//定时器重复从lapic [TICR]的总线频率倒计数，然后发出中断。</span></div><div class="line">	<span class="comment">// If we cared more about precise timekeeping,</span></div><div class="line">	<span class="comment">// TICR would be calibrated using an external time source.</span></div><div class="line">	<span class="comment">//如果我们更关心精确的计时，TICR将使用外部时间源进行校准。</span></div><div class="line">	lapicw(TDCR, X1);<span class="comment">//in this:向lapic数组写入东西lapic[TDCR]=X1;</span></div><div class="line">	lapicw(TIMER, PERIODIC | (IRQ_OFFSET + IRQ_TIMER));</div><div class="line">	lapicw(TICR, <span class="number">10000000</span>); </div><div class="line"></div><div class="line">	<span class="comment">// Leave LINT0 of the BSP enabled so that it can get</span></div><div class="line">	<span class="comment">// interrupts from the 8259A chip.</span></div><div class="line">	<span class="comment">//吧BSP的LINT0（向量表0）enable，这样就可以从8259A芯片得到中断</span></div><div class="line">	<span class="comment">// According to Intel MP Specification, the BIOS should initialize</span></div><div class="line">	<span class="comment">// BSP's local APIC in Virtual Wire Mode, in which 8259A's</span></div><div class="line">	<span class="comment">// INTR is virtually connected to BSP's LINTIN0. In this mode,</span></div><div class="line">	<span class="comment">// we do not need to program the IOAPIC.</span></div><div class="line">	<span class="comment">//根据英特尔MP规范，BIOS应在虚拟线路模式下初始化BSP的本地APIC，</span></div><div class="line">	<span class="comment">//其中8259A的INTR虚拟连接到BSP的LINTIN0。 </span></div><div class="line">	<span class="comment">//在这种模式下，我们不需要编程IOAPIC。</span></div><div class="line">	<span class="comment">//如果当前cpu不是启动cpu，它的中断表0 被mask</span></div><div class="line">	<span class="keyword">if</span> (thiscpu != bootcpu)</div><div class="line">		lapicw(LINT0, MASKED);</div><div class="line">	<span class="comment">// Disable NMI (LINT1) on all CPUs</span></div><div class="line">	<span class="comment">//中断表1都被mask</span></div><div class="line">	lapicw(LINT1, MASKED);</div><div class="line">	<span class="comment">// Disable performance counter overflow interrupts</span></div><div class="line">	<span class="comment">// on machines that provide that interrupt entry.</span></div><div class="line">	<span class="comment">//在一些特定的版本（提供了中断入口）的机器上，</span></div><div class="line">	<span class="comment">//disable PCINT（性能计数器溢出？？？）</span></div><div class="line">	<span class="keyword">if</span> (((lapic[VER]&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0xFF</span>) &gt;= <span class="number">4</span>)</div><div class="line">		lapicw(PCINT, MASKED);</div><div class="line">	<span class="comment">// Map error interrupt to IRQ_ERROR.</span></div><div class="line">	lapicw(ERROR, IRQ_OFFSET + IRQ_ERROR);</div><div class="line"></div><div class="line">	<span class="comment">// Clear error status register (requires back-to-back writes).</span></div><div class="line">	lapicw(ESR, <span class="number">0</span>);</div><div class="line">	lapicw(ESR, <span class="number">0</span>);</div><div class="line">	<span class="comment">// Ack any outstanding interrupts.</span></div><div class="line">	lapicw(EOI, <span class="number">0</span>);</div><div class="line">	<span class="comment">// Send an Init Level De-Assert to synchronize arbitration ID's.</span></div><div class="line">	<span class="comment">//#define ICRHI   (0x0310/4)   // Interrupt Command [63:32]</span></div><div class="line">	<span class="comment">//#define INIT       0x00000500   // INIT/RESET</span></div><div class="line">	<span class="comment">//#define DELIVS     0x00001000   // Delivery status</span></div><div class="line">	<span class="comment">//#define LEVEL      0x00008000   // Level triggered</span></div><div class="line">	<span class="comment">//#define BCAST      0x00080000   // Send to all APICs, including self.</span></div><div class="line">	lapicw(ICRHI, <span class="number">0</span>);</div><div class="line">	lapicw(ICRLO, BCAST | INIT | LEVEL);</div><div class="line">	<span class="keyword">while</span>(lapic[ICRLO] &amp; DELIVS) ;</div><div class="line">	<span class="comment">// Enable interrupts on the APIC (but not on the processor).</span></div><div class="line">	<span class="comment">//TPR 任务优先级</span></div><div class="line">	lapicw(TPR, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数初始化LAPIC。像其他结构一样，lapic被映射到固定的物理地址，随后进行各种中断向量的设置以及向量表的mask操作，设置错误状态寄存器的值，最后设置任务优先级。</p>
<p>像VGA设备一样，物理地址空间上也为LAPIC设备留了一个洞，它将会被map到虚拟地址的MMIOBASE。这种访问方式使得CPU可以像访问内存一样访问设备。</p>
<blockquote>
<p><strong>Exercise 1</strong></p>
<p>完成mmio_map_region函数，它将会完成把LAPIC设备所占据的物理地址map到预留的虚拟地址部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> *</div><div class="line">mmio_map_region(physaddr_t pa, size_t size)</div><div class="line">&#123;</div><div class="line">	<span class="comment">// Where to start the next region.  Initially, this is the</span></div><div class="line">	<span class="comment">// beginning of the MMIO region.  Because this is static, its</span></div><div class="line">	<span class="comment">// value will be preserved between calls to mmio_map_region</span></div><div class="line">	<span class="comment">// (just like nextfree in boot_alloc).</span></div><div class="line">	<span class="comment">//这是mmio开始的地方</span></div><div class="line">	<span class="keyword">static</span> uintptr_t base = MMIOBASE;</div><div class="line">	<span class="comment">// Reserve size bytes of virtual memory starting at base and</span></div><div class="line">	<span class="comment">// map physical pages [pa,pa+size) to virtual addresses</span></div><div class="line">	<span class="comment">// [base,base+size).  Since this is device memory and not</span></div><div class="line">	<span class="comment">// regular DRAM, you'll have to tell the CPU that it isn't</span></div><div class="line">	<span class="comment">// safe to cache access to this memory.  Luckily, the page</span></div><div class="line">	<span class="comment">// tables provide bits for this purpose; simply create the</span></div><div class="line">	<span class="comment">// mapping with PTE_PCD|PTE_PWT (cache-disable and</span></div><div class="line">	<span class="comment">// write-through) in addition to PTE_W.  (If you're interested</span></div><div class="line">	<span class="comment">// in more details on this, see section 10.5 of IA32 volume</span></div><div class="line">	<span class="comment">// 3A.)</span></div><div class="line">	<span class="comment">//保留虚拟内存的的size字节，并把物理地址pa，pa+size给map到base,base+size，</span></div><div class="line">	<span class="comment">//由于这是设备的内存，并不是dram，需要告诉cpu缓存到这里的access是不安全的，</span></div><div class="line">	<span class="comment">//幸运的是，页表提供了这样的位</span></div><div class="line">	<span class="comment">//只需要使用PTE_PCD|PTE_PWT|PTE_W即可</span></div><div class="line">	<span class="comment">//如果你对这个很有兴趣，可以去看10.5节，IA32 卷3A</span></div><div class="line">	<span class="comment">// Be sure to round size up to a multiple of PGSIZE and to</span></div><div class="line">	<span class="comment">// handle if this reservation would overflow MMIOLIM (it's</span></div><div class="line">	<span class="comment">// okay to simply panic if this happens).</span></div><div class="line">	<span class="comment">//确保你roundsizeup</span></div><div class="line">	<span class="comment">//确保你检测是不是会超过MMIOLIM，如果超过了，panic</span></div><div class="line">	<span class="comment">// Hint: The staff solution uses boot_map_region.</span></div><div class="line">	<span class="comment">//使用boot_map_region</span></div><div class="line">	<span class="comment">// Your code here:</span></div><div class="line">	<span class="comment">//Note:pa=5 size=7 pgsize=10</span></div><div class="line">	<span class="comment">//actually endsp shall be 20</span></div><div class="line">	uint32_t endsp=ROUNDUP(size+pa,PGSIZE);</div><div class="line">	pa=ROUNDDOWN(pa,PGSIZE);</div><div class="line">	size=endsp-pa;</div><div class="line">	<span class="keyword">if</span>(base+size&gt;MMIOLIM)panic(<span class="string">"the reservation would overflow MMIOLIM"</span>);</div><div class="line">	boot_map_region(kern_pgdir,base,size,pa,PTE_PCD|PTE_PWT|PTE_W);</div><div class="line">	<span class="comment">//panic("mmio_map_region not implemented");</span></div><div class="line">	<span class="comment">//</span></div><div class="line">	base+=size;</div><div class="line">	<span class="keyword">return</span> (<span class="keyword">void</span>*)(base-size);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>这里需要注意的是size与paddr的关系。由于最终覆盖到的地址应该在size+paddr，因此不能使用ROUNDDOWN(paddr)与ROUNDUP(size)直接做运算，否则可能会产生缺页的情况。</p>
</blockquote>
<h3 id="Application-Processor-Bootstrap"><a href="#Application-Processor-Bootstrap" class="headerlink" title="Application Processor Bootstrap"></a>Application Processor Bootstrap</h3><p>在<strong>i386_init</strong>函数中，本实验又增加了新的初始化过程：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/96728212.jpg" alt=""></p>
<p>在启动AP之前，BSP将会首先去获知多处理器的信息，比如CPU总数，他们各自的APIC编号以及LAPIC的MMIO地址。<strong>kern/mpconfig.c</strong>中的<strong>mp_init</strong>函数通过访问MP配置表来获知这些信息。随后，<strong>lapic_init</strong>初始化LAPIC设备，<strong>pic_init</strong>在更底层的部分初始化8259A的中断控制器。最后<strong>boot_aps</strong>函数(kern/init.c)将会启动各个AP，使他们从<strong>MPENTRY_PADDR</strong>开始运行。</p>
<p><strong>boot_aps</strong>函数如下：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/39840649.jpg" alt=""></p>
<p>可以看到，BSP首先将AP启动后执行的代码搬到AP的启动位置code，随后逐个唤醒AP。对每一个AP，将会告诉它它的内核栈的位置，随后调用<strong>lapic_statrap</strong>(kern/lapic.c)。lapic_startap的代码在上方已经贴出，它为CPU设置各种中断信息并最终给出STRATUP信号表明AP已经设置完成，随后AP开始从给定地址开始运行。进入<strong>mpentry.S</strong>的运行，设置initial页表并转入自己的内核栈，随后调用<strong>mp_main</strong>函数，设置页表，初始化LAPIC、GDT以及trap，随后告诉<strong>boot_aps</strong>这个CPU设置完毕，<strong>boot_aps</strong>接收到AP的信息之后，进入下一个AP的初始化。</p>
<p>随后就像在Lab3中的那样，调用用户程序。</p>
<blockquote>
<p><strong>Exercise 2</strong></p>
<p>修改<strong>page_init</strong>函数，不再将从MPENTRY_PADDR开始的虚拟地址添加到可用页上，给出更新后的函数：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/29015296.jpg" alt=""></p>
<p><strong>Question</strong></p>
<ol>
<li>Compare kern/mpentry.S side by side with boot/boot.S. Bearing in mind that kern/mpentry.S is compiled and linked to run above KERNBASE just like everything else in the kernel, what is the purpose of macro MPBOOTPHYS? Why is it necessary in kern/mpentry.S but not in boot/boot.S? In other words, what could go wrong if it were omitted in kern/mpentry.S? Hint: recall the differences between the link address and the load address that we have discussed in Lab 1. </li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/70313494.jpg" alt=""><br>MPBOOTYPHYS的目的是计算应该访问的地址。<br>与boot.S不同，在mpentry.S中启动的AP，其load进的地址并不是像boot一样与假设自己被加载进来的地址相同，而是被BSP加载到MPENTRY_PADDR。为了访问到正确的物理地址，应该换算成希望加载进来的地址再进行对地址的操作。</p>
</blockquote>
<h3 id="Per-CPU-State-and-Initialization"><a href="#Per-CPU-State-and-Initialization" class="headerlink" title="Per-CPU State and Initialization"></a>Per-CPU State and Initialization</h3><p>在多CPU的系统中，需要明确每个CPU私有的状态以及共有的资源划分。在<strong>kern/cpu.h</strong>中定义的CpuInfo结构存储有大部分的私有信息。thiscpu指向当前cpu的CpuInfo结构。</p>
<blockquote>
<p><strong>Exercise 3</strong><br>修改<strong>mem_init_mp</strong>函数，为每个CPU map一个内核栈。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/29300920.jpg" alt=""></p>
<p>像在memlayout.h中定义的那样，补充后的代码是：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/92996124.jpg" alt=""></p>
<p><strong>Exercise 4</strong></p>
<p>修改<strong>trap_init_percpu</strong>使得在多CPU环境下可以运行</p>
<p>代码：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/58108225.jpg" alt=""></p>
<p>这段代码中一共有四个需要修改的地方，一是所有的ts应该修改为thiscpu-&gt;ts，而是栈顶应该由KSTACKTOP-(KSTKSIZE + KSTKGAP)变为KSTACKTOP-i*(KSTKSIZE + KSTKGAP)，三是gdt中tss表项位置应该由[(GD_TSS0 &gt;&gt; 3)变为[(GD_TSS0 &gt;&gt; 3)+i，四是load选择子的时候应该修改为对应cpu的选择子ltr(GD_TSS0+i*8);。</p>
</blockquote>
<p>这样就完成了不同CPU的trap初始化。</p>
<p>完成这里的操作之后，make qemu CPUS=4，可以看到所有函数检查通过，CPU信息输出。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/75077349.jpg" alt=""></p>
<h3 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a>Locking</h3><p>上述完成之后，代码将会停在原地。为了使得AP能够进一步运行，需要首先解决多个CPU同时运行内核代码的竞争状况。为了解决这个问题，采用内核锁机制。当有进程在内核空间时，内核将会上一个锁，回到用户空间后，锁被释放。</p>
<p>在<strong>kern/spinlock.h</strong>中定义了一个kernel_lock，提供了<strong>lock_kernel</strong>与<strong>unlock_kernel</strong>函数。需要我们自己来决定加锁解锁的位置。</p>
<blockquote>
<p><strong>Exercise 5</strong><br>加锁与解锁</p>
<ol>
<li><p>在i386_init中，在BSP唤醒其他CPU之前加锁：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/63950397.jpg" alt=""></p>
</li>
<li><p>在mp_main中，在AP初始化之后加锁，然后调用sched_yield来开始调度。<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/24870973.jpg" alt=""></p>
</li>
<li><p>在trap中，如果是从用户模式来的trap，就获得锁。<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/38167577.jpg" alt=""></p>
</li>
<li><p>在env_run中，在进入用户模式的时候释放锁<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/44217150.jpg" alt=""></p>
</li>
</ol>
</blockquote>
<hr>
<blockquote>
<p>Question</p>
<ol>
<li>It seems that using the big kernel lock guarantees that only one CPU can run the kernel code at a time. Why do we still need separate kernel stacks for each CPU? Describe a scenario in which using a shared kernel stack will go wrong, even with the protection of the big kernel lock. </li>
</ol>
<p>这是因为在lab3中已经写过，当用户进程发生中断的时候，执行的代码中有：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/35810116.jpg" alt=""><br>这段代码是产生中断之后硬件自己就会执行的，在这个时候仍未调用trap，自然还没有为内核加锁。也就是说，如果使用同一个栈，当两个cpu同时发生中断的时候，这段代码很可能会被打断执行顺序，从而导致内核栈的混乱。</p>
</blockquote>
<h3 id="Round-Robin-Scheduling"><a href="#Round-Robin-Scheduling" class="headerlink" title="Round-Robin Scheduling"></a>Round-Robin Scheduling</h3><p>接下来，将会修改调度过程的代码，来为jos添加调度的功能。</p>
<p>在这里，这个功能会被描述为：</p>
<p>函数<strong>shced_yield</strong>负责选择一个新进程运行，它从当前运行进程的编号开始寻找，找第一个有着ENV_RUNNABLE的进程把运行权交付给它。如果没有其他进程是ENV_RUNNABLE状态而且现在的进程还可以运行，那就还让现在的进程运行。</p>
<blockquote>
<p><strong>Exercise 6</strong></p>
<p>修改该sched_yield函数：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/8461936.jpg" alt=""></p>
</blockquote>
<p>需要注意的是，这时syscall函数仍未被完成，需要在此后陆续添加更多的SYS_*来允许用户空间的系统调用。</p>
<p>随后可以测试，修改i386_init函数，创建3个进程：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/59214383.jpg" alt=""></p>
<p>使用make qemu CPUS=2，可以得到结果：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/79530109.jpg" alt=""></p>
<blockquote>
<p>Question</p>
<ol>
<li>In your implementation of env_run() you should have called lcr3(). Before and after the call to lcr3(), your code makes references (at least it should) to the variable e, the argument to env_run. Upon loading the %cr3 register, the addressing context used by the MMU is instantly changed. But a virtual address (namely e) has meaning relative to a given address context–the address context specifies the physical address to which the virtual address maps. Why can the pointer e be dereferenced both before and after the addressing switch? </li>
</ol>
<p>e所指示的空间是在mem_init中被申请的物理空间，它并不会存在于每个进程的可用页表里供进程自己决定map的虚拟地址，而是对每个进程而言都是一样的。</p>
<ol>
<li>Whenever the kernel switches from one environment to another, it must ensure the old environment’s registers are saved so they can be restored properly later. Why? Where does this happen?</li>
</ol>
<p>只有这样做，才能保存上一个进程的运行状态信息，恢复进程运行时才不会出错。<br>这个操作发生在trap函数中，代码是这样的：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/86607615.jpg" alt=""><br>它保存了发生trap的进程的tf。<br>然而，进程之间切换由kernel决定。每次发生进程调度，都会发生trap（这里将syscall主动放弃cpu也通过trap完成）</p>
</blockquote>
<h3 id="System-Calls-for-Environment-Creation"><a href="#System-Calls-for-Environment-Creation" class="headerlink" title="System Calls for Environment Creation"></a>System Calls for Environment Creation</h3><p>下面将允许用户进程创建子进程并执行。</p>
<p>在Unix中，fork函数可以用来创建子进程。这个子进程完全copy了父进程的地址空间，二者唯一不同的是在父进程中fork返回子进程的编号而在子进程中返回的是0。</p>
<p>我们将实现一个更加原始的fork，首先需要完成一些系统调用函数。<br>在这些个函数之中，需要频繁用到函数envid2env来检查进程操作是否合法，首先来分析这个envid2env函数：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/74947768.jpg" alt=""></p>
<p>如果envid是0，说明是当前进程希望获得自己的env结构，直接允许获得，返回curenv，函数成功。<br>如果给的envid不合法或者指定进程是free进程，无法得到进程结构，返回bad environment。<br>否则如果指定需要检查权限，那么给定的envid必须是当前进程的子进程，如果满足要求返回成功，否则返回失败：bad environment。</p>
<blockquote>
<p><strong>Exercise 7</strong>：</p>
<p>只需要按照要求完成代码：</p>
<p><strong>sys_exofork</strong>：创建一个新进程，其中，用户地址空间没有任何map，不可以运行。子进程将会拥有和父进程一样的寄存器状态值，该函数在子进程中返回0，在父进程中返回子进程的id。（由于子进程刚刚被创建的时候是没有执行能力的，因此实际上，在子进程中是无法返回的，直到其父进程用下面的函数将子进程标记为可运行）<br>代码：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/70937828.jpg" alt=""></p>
<p><strong>sys_env_set_status</strong>：设置一个进程的状态为ENV_RUNNABLE或者是ENV_NOT_RUNNABLE。<br>代码：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/20728662.jpg" alt=""></p>
<p><strong>sys_page_alloc</strong>：申请一个物理页并把它map在给定进程的给定地址。<br>代码：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/47728587.jpg" alt=""></p>
<p><strong>sys_page_map</strong>：把给定进程的某一个页的映射同样映射到另一个进程的给定地址，这样，这两个进程享有了共享的一个物理页。<br>代码：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/41333018.jpg" alt=""></p>
<p><strong>sys_page_unmap</strong>：把某一个页从某一个进程的对应地址上unmap。<br>代码：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-25/27465683.jpg" alt=""></p>
</blockquote>
<p>完成这些之后，partA的dumbfork测试就可以通过了。</p>
<h2 id="Part-B-Copy-on-Write-Fork"><a href="#Part-B-Copy-on-Write-Fork" class="headerlink" title="Part B: Copy-on-Write Fork"></a>Part B: Copy-on-Write Fork</h2><p>像在前面提到的一样，Unix提供了fork函数，这个函数将会复制整个父进程的地址空间。xv6 Unix的fork将会复制父进程的所有页到新的页，这也是在dumbfork里面做的。但是，这样的操作耗时而且通常都是无用功：创建出的子进程可能很快就会被父进程委派去做其他的工作，子进程的地址空间很快会被新的数据取代。</p>
<p>出于这种考虑，现在来实现一种新的特性，子进程与父进程将享有同一套地址空间，直到有进程真的要去修改这块空间。这样的技术叫做<strong>copy-on-write</strong>。</p>
<p>在这种特性之下，当创建子进程的时候，父进程仅仅将自己的映射关系给子进程，同时把自己共享出去的页都标记为只读。当有一方想要修改该虚拟地址空间时触发一个page fault，这时，内核才真正意识到需要一个新的页，这时才会去为发生错误的进程申请一个自己的页。这样的设计使得子进程在执行之前花费的代价很少，一般只会有一个栈的页。</p>
<h3 id="User-level-page-fault-handling"><a href="#User-level-page-fault-handling" class="headerlink" title="User-level page fault handling"></a>User-level page fault handling</h3><p>用户层面的缺页异常有很多种引起的可能，cow只是其中的一种。内核必须能够决定为不同程序空间引起的缺页异常提供不一样的解决方式，比如，在栈中发生的缺页异常需要申请并map一个物理页，在bss区域引起的缺页中断会申请一个全0的物理页然后映射。</p>
<p>对内核来说，有很多信息都可以作为判断依据，接下来，将完成我们的pgfault处理函数。</p>
<h3 id="Setting-the-Page-Fault-Handler"><a href="#Setting-the-Page-Fault-Handler" class="headerlink" title="Setting the Page Fault Handler"></a>Setting the Page Fault Handler</h3><p>为了处理缺页中断，用户进程需要向内核注册并存储自己的缺页中断处理函数的入口点。为了实现这个功能，在Env结构中新加了成员<code>env_pgfault_upcall</code>。</p>
<blockquote>
<p><strong>Exercise 8</strong>：<br>完成函数<code>sys_env_set_pgfault_upcall</code>，确保进行了权限检查。</p>
<p>根据提示，该函数为特定进程设置一个缺页中断处理函数。这个进程必须是自己或者是自己的子进程。<br>写出代码：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/2663658.jpg" alt=""></p>
</blockquote>
<h3 id="Normal-and-Exception-Stacks-in-User-Environments"><a href="#Normal-and-Exception-Stacks-in-User-Environments" class="headerlink" title="Normal and Exception Stacks in User Environments"></a>Normal and Exception Stacks in User Environments</h3><p>在正常的执行中，用户进程将会在用户栈中执行，esp指向栈顶，当一个缺页中断发生的时候，内核将会使用户进程重新在另一个栈中运行缺页中断的处理函数。也就是，我们需要使内核能够自动换栈。</p>
<p>异常栈有一个page大小，最顶端是UXSTACKTOP。因此，第一个中断发生后将会空间UXSTACKTOP-PGSIZE到UXSTACKTOP之间作为异常栈。在处理函数中可以通过各种调用恢复原进程的正确执行，随后该函数返回，回到上次发生中断的地方，重新执行出错代码。<br>每一个希望有用户层次的缺页中断处理函数的进程都必须支持申请新页来作为他自己的异常栈。</p>
<h3 id="Invoking-the-User-Page-Fault-Handler"><a href="#Invoking-the-User-Page-Fault-Handler" class="headerlink" title="Invoking the User Page Fault Handler"></a>Invoking the User Page Fault Handler</h3><p>接下来我们要修改trap中的代码，使它有以下的功能。</p>
<p>如果这个用户进程并没有自己的缺页中断处理函数，当他有缺页中断发生的时候，就销毁这个进程然后退出，否则。</p>
<p>异常栈中的情况是这样的：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/95241296.jpg" alt=""></p>
<p>UXSTTACKTOP是栈底，依次push进了许多变量，他们与结构<strong>UTrapframe</strong>吻合。函数执行结束后，需要从异常栈返回原本的用户栈。</p>
<p>实际情况中可能更加复杂：缺页中断额处理函数本身还可能会发生中断，这时，继续往栈顶push数据，但是需要注意，由于一些原因，需要先push一个32bit的空位。这个将会在后面进行解释。如果tf-&gt;tf_esp在上述区域之中，那么就是在异常栈中发生的缺页中断，否则就是在原本的用户进程中发生的中断。</p>
<blockquote>
<p><strong>Exercise 9</strong></p>
<p>完成函数<code>page_fault_handler</code>。他需要将用户空间的缺页中断给用户的处理函数。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/77522130.jpg" alt=""></p>
<p>首先，只有有处理函数才能进行下一步的操作，否则将会free掉这个进程。<br>随后确定将要push的结构的首地址。如果当前进程可以访问这个地址，那么就把对应的地址写为对应的值，保存好之前执行状态的信息。保存完之后，将程序的下一个执行地址设置为函数的入口地址，将该进程的栈顶设置为异常栈的栈顶，运行。</p>
</blockquote>
<h3 id="User-mode-Page-Fault-Entrypoint"><a href="#User-mode-Page-Fault-Entrypoint" class="headerlink" title="User-mode Page Fault Entrypoint"></a>User-mode Page Fault Entrypoint</h3><p>接下来，需要我们完成执行C程序并且返回到原执行状态的汇编指令，该汇编指令是<code>sys_env_set_pgfault_upcall</code>的处理过程。</p>
<blockquote>
<p><strong>Exercise 10</strong>：<br>完成lib/pfentry.S中的<code>_pgfault_upcall</code>过程。</p>
<p>只需要根据提示，结合上述的异常栈动作：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/27738708.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/86236764.jpg" alt=""></p>
</blockquote>
<p>最后，完成C程序库部分的缺页异常处理机制：</p>
<blockquote>
<p><strong>Exercise 11</strong>：<br>完成lib/pgfault.c中的<code>set_pgfault_handler</code>函数：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/14374721.jpg" alt=""></p>
</blockquote>
<h3 id="Implementing-Copy-on-Write-Fork"><a href="#Implementing-Copy-on-Write-Fork" class="headerlink" title="Implementing Copy-on-Write Fork"></a>Implementing Copy-on-Write Fork</h3><p>fork函数是一个cow的子进程创建函数，它的控制流程是这样的：</p>
<ol>
<li><p>使用<code>set_pgfault_handler</code>来确定中断处理函数C程序层面的入口</p>
</li>
<li><p>调用<code>sys_exofork</code>创建一个新进程</p>
</li>
<li><p>对每一个可写的或是cow的在UTOP之下的页，父进程为之调用<strong>duppage</strong>函数，这个函数将会把cow的页map到子进程地址空间，然后重新在自己的地址空间map这些页。</p>
</li>
<li><p>父进程为子进程设置缺页中断处理函数入口点</p>
</li>
<li><p>子进程可以运行了，父进程将其标志为RUNNABLE</p>
</li>
</ol>
<p>之后，每次想要修改cow页面都会触发缺页中断，触发之后过程如下：</p>
<ol>
<li><p>kernel把pagefault告诉_pgfault_upcall，执行入口调用pgfault函数</p>
</li>
<li><p>pgfault检查错误是写错误而且页面是cow，否则panic</p>
</li>
<li><p>pgfault申请新的页，map到一个临时地址，把出错的页面信息copy到新的页面，随后把新页map到一个合适的地址。</p>
</li>
</ol>
<p>kernle会把进程的页表都map到UVPT页目录map到UVPD，方便根据虚拟地址获取对应页的权限信息。首先我们先来看一看这个小技巧。</p>
<p>在内核中可以使用函数<code>pgdir_walk</code>获得权限信息，但是在用户空间，虚拟地址的翻译决定了自身的页表与页目录是不可见的。为了方便的获取权限信息，我们向用户进程的页目录中插入一个特殊的entry。这个entry指向页目录的首部。</p>
<p>这样，当我们访问一个PDX与PTX均是特定数值V的虚拟地址时，我们访问到了页目录。<br>这个地址作为指针数组的开头，使用某虚拟地址的PDX作为索引，使我们可以访问到页目录的各项。</p>
<p>当我们访问一个PDX是V但是PTX不是V的虚拟地址时，我们访问到了页表。同样地我们可以访问到各个页表项。</p>
<p>上述提到的两个虚拟地址分别是UVPD与UVPT。在memlayout.h中定义。<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/57100150.jpg" alt=""></p>
<blockquote>
<p><strong>Exercise 12</strong>：<br>完成frok，duppage以及pgfault。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/99153651.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/36579327.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/42000412.jpg" alt=""></p>
</blockquote>
<p>partB到这里就结束了，在进入partC之前，首先来梳理一下从fork开始的整个运行过程。</p>
<p>当一个用户进程调用fork函数创建子进程，在fork中将申请一个新的进程，复制父进程的地址空间映射给子进程并把二者空间中的对应页都标记为cow，随后父进程为子进程申请用户栈，设置缺页处理过程入口点，最终将子进程的状态标记为可运行。fork退出后将得到两个可运行的进程，在子进程中fork函数返回的是0，在父进程中返回的是子进程的进程id，随后二者可以区分开开始运行。</p>
<p>子进程开始运行其他东西或是父进程需要写数据的时候，其中一个必然会触发一个cow的缺页中断。这个进程的缺页中断经过内核dispatch，将会执行我们在trap中完成的处理函数，假设它已经设置了自己的处理函数，那么就会创建一个异常栈，开始执行在pfentry.S中的汇编代码，执行完毕之后返回原来发生错误的执行位置，继续执行。</p>
<h2 id="Part-C-Preemptive-Multitasking-and-Inter-Process-communication-IPC"><a href="#Part-C-Preemptive-Multitasking-and-Inter-Process-communication-IPC" class="headerlink" title="Part C: Preemptive Multitasking and Inter-Process communication (IPC)"></a>Part C: Preemptive Multitasking and Inter-Process communication (IPC)</h2><h3 id="Clock-Interrupts-and-Preemption"><a href="#Clock-Interrupts-and-Preemption" class="headerlink" title="Clock Interrupts and Preemption"></a>Clock Interrupts and Preemption</h3><p>在此之前，我们不同进程之间的调度都是自愿的。下面将通过引入时钟中断来强制进行调度。</p>
<h3 id="Interrupt-discipline"><a href="#Interrupt-discipline" class="headerlink" title="Interrupt discipline"></a>Interrupt discipline</h3><p>外部中断在本实验中一共有16个，标号是32-47。在本实验中，内核中的外部中断被忽略，在用户空间中通过设置FL_IF来设置允许外部中断。</p>
<blockquote>
<p><strong>Exercise 13</strong>：<br>修改trapentry.S以及trap.c来初始化上述的中断，然后修改该env_alloc允许用户空间的外部中断</p>
<p>像上一个实验一样即可：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/19942562.jpg" alt=""><br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/85310004.jpg" alt=""></p>
<p>只需在指定的位置将新建的env的tf_eflags修改为FL_IF允许即可。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/89863916.jpg" alt=""></p>
</blockquote>
<h3 id="Handling-Clock-Interrupts"><a href="#Handling-Clock-Interrupts" class="headerlink" title="Handling Clock Interrupts"></a>Handling Clock Interrupts</h3><p>在lapic_init以及pic_init中，已经设置好了产生时钟中断，下面需要处理时钟中断。</p>
<blockquote>
<p><strong>Exercise 14</strong>：<br>修改trap_dispatch，它调用sched_yield。<br>直接给出代码：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/87756184.jpg" alt=""></p>
</blockquote>
<h3 id="Inter-Process-communication-IPC"><a href="#Inter-Process-communication-IPC" class="headerlink" title="Inter-Process communication (IPC)"></a>Inter-Process communication (IPC)</h3><p>进程间的通信有很多种模型，这里只实现简单的一种。</p>
<h3 id="IPC-in-JOS"><a href="#IPC-in-JOS" class="headerlink" title="IPC in JOS"></a>IPC in JOS</h3><p>这里进程可以相互发送或接收的信息有：一个32bit的数据或是一整个页。整个页的发送是通过共享内存来实现的，这在下面将具体说明。</p>
<h3 id="Sending-and-Receiving-Messages"><a href="#Sending-and-Receiving-Messages" class="headerlink" title="Sending and Receiving Messages"></a>Sending and Receiving Messages</h3><p>为了接收数据，进程将调用sys_ipc_recv。这个系统调用使这个进程不可运行，直到收到数据。当进程等待接收消息时，任何其他进程都可以向其发送消息不会检查权限。</p>
<p>为了尝试发送一个值，一个环境调用sys_ipc_try_send与接收者的环境ID和要发送的值。如果指定的环境实际上正在接收（它已经调用sys_ipc_recv并且还没有获得值），则发送递送消息并返回0.否则发送返回-E_IPC_NOT_RECV以指示目标环境当前不期望接收值。</p>
<h3 id="Transferring-Pages"><a href="#Transferring-Pages" class="headerlink" title="Transferring Pages"></a>Transferring Pages</h3><p>当进程使用小于UTOP的dstva调用sys_ipc_recv时，表明它愿意接收页面映射。如果发送者发送一个页面，那么该页面应该被映射到接收者地址空间中的dstva。如果接收者已经有了一个映射到dstva的页面，那么这个页面被unmap。</p>
<p>当环境使用小于UTOP的srcva调用sys_ipc_try_send时，说明发送者想要发送当前映射到srcva（发送者）的页面到接收者，具有权限perm。在一个成功的IPC之后，发送者在srcva的地址空间保留其原始的映射，但是接收者也在接收者的地址空间中获得了原来由接收者指定的dstva的同一物理页面的映射。结果这个页面在发送者和接收者之间被共享。</p>
<p>如果发送者或接收者不指示应该传送页面，则不传送页面。在任何IPC之后，内核将接收方的Env结构中的新字段env_ipc_perm设置为所接收页面的权限，如果没有收到页面，则为零。</p>
<h3 id="Implementing-IPC"><a href="#Implementing-IPC" class="headerlink" title="Implementing IPC"></a>Implementing IPC</h3><blockquote>
<p><strong>Exercise 15</strong>：<br>根据说明补充syscall与ipc中的函数：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/20379443.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/74580574.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/80248583.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-26/16842939.jpg" alt=""></p>
</blockquote>
<p>本实验结束。</p>
]]></content>
      
        <categories>
            
            <category> OS </category>
            
            <category> MIT Lab </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2017/12/04/OS/%E4%B8%B2%E8%AE%B2/</url>
      <content type="html"><![CDATA[<h2 id="文件写入时发生了什么？"><a href="#文件写入时发生了什么？" class="headerlink" title="文件写入时发生了什么？"></a>文件写入时发生了什么？</h2><p>在内存中创建一个新的inode节点或者索引节点，如果存在，在文件系统中找到对应的inode。</p>
<p>修改文件夹对应的数据节点。<br>最初只在内存中修改并标记这块数据已经被修改了，你记得帮我写回去。</p>
<p>close并不能使数据立即回到硬盘上。pagebuffer可以被禁用。fsync可以强制立即写回磁盘。</p>
<pre><code>//sqlite将收到文件系统缓存影响。
</code></pre><p>先写数据还是先写索引？更偏向于先写数据，这样顶多修改内容存不上，如果先写索引，可能导致文件系统将无效数据误认为是文件数据。</p>
<h2 id="文件删除时发生了什么"><a href="#文件删除时发生了什么" class="headerlink" title="文件删除时发生了什么"></a>文件删除时发生了什么</h2><p>找到对应的inode：这时在cache内存（pagecache）以及文件系统上都存有该文件的数据。</p>
<p>在内存中删除inode，清除页面。<br>把硬盘中的inode清除，对应数据块清除，硬盘中的块标记为未使用，文件夹中的项删除。</p>
<p>一个文件（夹）怎样叫做存在？1.在某一个文件夹下有她的树根的索引 2.在占用未占用位图中存在数据块占用标志。</p>
<p>如何恢复一个被误删的文件？寻找树根。而树根是有特点的。一个文件恢复需要扫描位图中显示的未使用的数据块，找到树根，然后顺着树根找到所有文件。<br>所以，一旦误删，就不能再动硬盘了，再动硬盘可能会破坏原来的数据，导致文件直接找不到或者缺失或者？（不会乱码咩）</p>
<p>怎样快速删除文件并且不可恢复？<br>删除与覆盖、与文件系统相关、把我的空lab5给他复制过去hhh。</p>
<h2 id="关机时发生了什么？"><a href="#关机时发生了什么？" class="headerlink" title="关机时发生了什么？"></a>关机时发生了什么？</h2><p>init在接收到特定信号时发起关机</p>
<p>使用SIGSTOP提示关机，使用SIGKILL强制关机</p>
<p>各种内存数据回写。</p>
<p>意外断电？<br>1.可能数据在内存中没有被回写 2.磁头正在飞行（可能会有保护机制） 3.磁头正在写入<br>如果搞坏了磁介质可能只是这个地方不能读写，但是<br>RAID1多地机房。</p>
<p>意外断电防护：使用重力传感器，（磁头）失重时将会尽快写入数据。</p>
<h2 id="开机时发生了什么"><a href="#开机时发生了什么" class="headerlink" title="开机时发生了什么"></a>开机时发生了什么</h2><p>跳转到指定地址取指令（0xfffff0或0x00000000（手机））：<br>bios中存在一些基本指令：兼容机的标准化使得BIOS可以适配大量硬件</p>
<p>硬盘数据载入内存 这是因为硬盘的读取模式也兼容给bios的读写。</p>
<p>格式化C盘再复制回去：NTLDR missing：NTFS系统自身的代码。VBR：ntfs文件系统的加载器，包含文件系统的读取方式与操作系统。使用vbr把文件load进来。</p>
<p>操作系统接管运行，为进程准备环境。</p>
<p>init进程创建用户交互进程。winlogon。init不做任何操作只等关机，其他任务都是init的子进程的工作。</p>
<p>为什么不拷贝一份新的而是使用父进程的？子进程直接自己调用exec，直接调用（freertos）。拷贝执行？？？<br>子进程在出来之后就已经是一个完整的pcb了。</p>
<p>父进程可以接收子进程的main函数的返回值。<br>父进程等待子进程退出，由父进程替子进程收拾残局：找到他分配的页面，转为可用页面。SIGCHILD。<br>如果一个进程的父进程先自己退出了，这个子进程的父进程就变成init。</p>
<h2 id="exec时发生了什么？"><a href="#exec时发生了什么？" class="headerlink" title="exec时发生了什么？"></a>exec时发生了什么？</h2><p>在文件系统中找到文件，读取文件目录树</p>
<p>将文件映射入内存</p>
<p>程序执行</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[我的编译器]]></title>
      <url>/2017/12/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E6%88%91%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8/</url>
      <content type="html"><![CDATA[<h1 id="我的编译器"><a href="#我的编译器" class="headerlink" title="我的编译器"></a>我的编译器</h1><p>password: password<br><a id="more"></a></p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="PG的配置"><a href="#PG的配置" class="headerlink" title="PG的配置"></a>PG的配置</h3><h3 id="VS属性的配置"><a href="#VS属性的配置" class="headerlink" title="VS属性的配置"></a>VS属性的配置</h3><p>好了，这时在PG中的任务已经完成了，接下来想要使用VS来执行PG生成的程序，还需要进行一些属性的配置。<br>多种组合可行。这里只说明了我自己用的一种组合，路径也以我的电脑为准。我的机器VS2015，win10。</p>
<p>在<strong>属性</strong>页面添加：</p>
<ol>
<li>配置属性 -&gt; VC++目录 -&gt; 包含目录：D:/Program Files（x86）/Parser Generator 2/Cpp/Include</li>
<li>配置属性 -&gt; VC++目录 -&gt; 库目录：D:/Program Files（x86）/Parser Generator 2/Cpp/Lib</li>
<li>C/C++ -&gt; 预处理器 -&gt; 预处理器定义：YYDEBUG,_MBCS;</li>
<li>C/C++ -&gt; 代码生成 -&gt;运行库：多线程调试(/MTd)</li>
<li>链接器 -&gt; 输入 -&gt; 附加依赖项：ylmtd.lib;</li>
</ol>
<p>是YYDEBUG,_MBCS;中间是<strong>逗号</strong>。</p>
<p>$$\color{red}{注意！上述除了“多线程调试”，其他均是在原有的基础上添加。}$$</p>
<h2 id="语法分析部分"><a href="#语法分析部分" class="headerlink" title="语法分析部分"></a>语法分析部分</h2><h3 id="lex与yacc的结合"><a href="#lex与yacc的结合" class="headerlink" title="lex与yacc的结合"></a>lex与yacc的结合</h3><p><a href="http://blog.csdn.net/lpstudy/article/details/51328851" target="_blank" rel="external">lipeng的结合参考</a>算了。没什么特别大的参考价值，他的着重点与我的不同。</p>
<p><a href="https://docs.oracle.com/cd/E62103_01/html/E62875/lex-1.html" target="_blank" rel="external">oracle的文档：lex</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/sdk/lex/" target="_blank" rel="external">IBM的文档：lex</a>–最终问题在这里面解决。<br>查看其“结合”部分。</p>
<p>在lex中没有main函数，yylval是在lex中定义的一个变量，使用extern YYSTYPE yylval在yacc中使用。</p>
<h4 id="“default”标签跳过“-”的初始化操作"><a href="#“default”标签跳过“-”的初始化操作" class="headerlink" title="“default”标签跳过“ ”的初始化操作"></a>“default”标签跳过“ ”的初始化操作</h4><p><a href="https://msdn.microsoft.com/query/dev14.query?appId=Dev14IDEF1&amp;l=ZH-CN&amp;k=k(C2361" target="_blank" rel="external">编译器错误C2361:“default”标签跳过“ ”的初始化操作</a>&amp;rd=true)<br><a href="http://blog.csdn.net/t19870905/article/details/23608547" target="_blank" rel="external">“default”标签跳过“ ”的初始化操作解决</a></p>
<p>出现“default”标签跳过yylval的初始化操作的原因是：在lex中，我把rule section的正则语义动作定义段写在了对yylval的extract之前。只要挪到后面，这个错误就不见了。（这个看一看在cpp中的错误代码就能发现异常。）</p>
<h4 id="yylval：无法解析的外部符号"><a href="#yylval：无法解析的外部符号" class="headerlink" title="yylval：无法解析的外部符号"></a>yylval：无法解析的外部符号</h4><p>写错地方了。yylval是在yacc里面的，写extern应该在lex里面写。</p>
<p>在yacc中无需用到yylval，这是因为在语义动作上，比如NUMBER，如果不写他的语义动作，他将会自动把产生式左部的值赋为与NUMBER一起给yacc的yylval的值。</p>
<p>成功！现在来总结一下叭！</p>
<blockquote>
<p>现在拥有：一个yacc文件名叫myparser.y，一个lex文件名叫mylexer.l。<br>创建了一个新的既有lex又有yacc的项目。<br>把原来lex中的除了main函数之外的东西拷贝到新程序的对应位置（不建议直接全部复制，因为可能会有细小问题出现。特别注意你在生成project的时候定义的lexer的名字！）注意上面提到过的那个rule section的问题。<br>在lexer的include句之后定义<code>extern string yylval</code>（我这里使用string只是因为我的YYSTYPE是string，我的不能直接使用宏YYSTYPE）<br>在lex的匹配语义动作中加上对yylval的赋值（<code>yylval=yytext;</code>这句将匹配对应的字符串给yylval。同样因为我的yylval是string，不是string可以自己转换一下。<br>在lex的语义动作最后加上<code>return NUBER;</code>（NUBER只是一个例子，应该返回这个匹配对应的token。<br>把原来yacc中的代码拷到新程序的对应位置（同样不建议直接全部复制。<br>如果原来不懂yylavl的意义，在单token行也写了语义动作赋值，把这个语义动作删掉，或者使用\$1对这个值做你想要的处理之后赋给\$\$。<br>好了！生成之后，在VS项目中运行就好啦！</p>
</blockquote>
<h3 id="符号表的设计"><a href="#符号表的设计" class="headerlink" title="符号表的设计"></a>符号表的设计</h3><p>由于支持函数类等操作，所以要增加多个生存期作用域，需要多个符号表。这些符号表将动态生成，压进栈中。这也是考虑到作用域的特性。另一方面，由于作用域与语法相关，符号表的创建（除了全局符号表）在yacc中完成。yacc获取栈，lex获取栈，共同操作。</p>
<p><a href="http://blog.csdn.net/livecoldsun/article/details/25011413" target="_blank" rel="external">C++标准库栈</a><br>上述链接其实没什么特别多的东西，记住两点三函数：</p>
<ol>
<li>使用stack需要包括头文件<code>#include&lt;stack&gt;</code></li>
<li>这是个模板类，使用时指定类型：<code>stack&lt;CHash*&gt; mystack;</code></li>
<li>函数们：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">函数名</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">top()</td>
<td style="text-align:center">返回栈顶元素，不弹出</td>
</tr>
<tr>
<td style="text-align:center">pop()</td>
<td style="text-align:center">弹出栈顶元素，不返回</td>
</tr>
<tr>
<td style="text-align:center">push(member)</td>
<td style="text-align:center">将member压栈</td>
</tr>
<tr>
<td style="text-align:center">size()</td>
<td style="text-align:center">返回栈中元素个数</td>
</tr>
<tr>
<td style="text-align:center">empty()</td>
<td style="text-align:center">检查栈是不是空</td>
</tr>
</tbody>
</table>
<p>简直是救星！<a href="http://greatverve.cnblogs.com/archive/2012/10/24/cpp-int-string.html" target="_blank" rel="external">string CString int char等互转</a></p>
<h3 id="语法树的生成"><a href="#语法树的生成" class="headerlink" title="语法树的生成"></a>语法树的生成</h3><p><a href="http://www.cnblogs.com/likebeta/archive/2012/06/16/2551662.html" target="_blank" rel="external">C++的文件操作</a></p>
<p>这次的作业我走了很多弯路，主要一点就是没有搞清楚自己究竟要干什么。这次作业的重点在于“语法树生成”。</p>
<h3 id="编译器对函数的处理"><a href="#编译器对函数的处理" class="headerlink" title="编译器对函数的处理"></a>编译器对函数的处理</h3><h3 id="YACC部分"><a href="#YACC部分" class="headerlink" title="YACC部分"></a>YACC部分</h3><p>注意：yacc中的文法定义顺序是非常有关系的。不一样的顺序将会带来不一样的结果。越靠上的文法，越会先被匹配。<br>在添加产生式的过程中出现了”rules are never reduced”。在第一次写作业时也出现了，但是那时没有好好积累。<br>shift在这里是”移入“，reduce是”归约“。这是LR算法中的语言。</p>
<p><a href="https://stackoverflow.com/questions/30447829/rules-are-never-reduced-understanding-why" target="_blank" rel="external">理解”rules are never reduced”-stackoverflow</a></p>
<p><a href="https://stackoverflow.com/questions/6839844/yacc-rules-not-getting-reduced" target="_blank" rel="external">not getting reduced</a></p>
<p><a href="https://stackoverflow.com/questions/29135724/yacc-rules-not-reduced" target="_blank" rel="external">rules are never reduced</a></p>
<p>总结上述的一些：</p>
<ol>
<li>可能是因为指出的那个没有在右边出现过。</li>
<li>可能是在前面的某个产生式包括了这个产生式的情况，所以不能被匹配。</li>
<li>你的递归没有办法被终止。</li>
<li>yacc似乎会将第一个产生式左部作为开始符号。</li>
</ol>
<blockquote>
<p>In general, you want to use the -v option to get yacc to prodcue a y.output file with detailed information about your grammar. This file will tell you specifically about all the conflicts and unused rules – what they are and how they come about – while the messages just give you a summary of the problems.(使用-v选项来获取更详细的输出信息。)</p>
</blockquote>
<p>有时即使没有错误或者警告，程序也运行不出来，大概是匹配了不是本意的文法，自己看吧。我心情不好。<br>一直感觉文法是对的，一直运行不出来。我的lex没有返回一些token给yacc。能运行就怪了。</p>
<p>没有好好理解VS里面.h与.cpp，不要随便在里面写一些函数，然后包括去使用。</p>
<h3 id="LEX部分"><a href="#LEX部分" class="headerlink" title="LEX部分"></a>LEX部分</h3>]]></content>
      
        <categories>
            
            <category> 编译原理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[琐碎]]></title>
      <url>/2017/12/02/Untitled-1/</url>
      <content type="html"><![CDATA[<p>git的beanch原来真的可以在本地也切换啊！<br>当我用git checkout lab3的时候，文件夹里的东西也会跟着变。<br>这也就解释了，为什么我明明从写好的lab3复制文件到lab4的lab3却没反应，因为我根本就没有复制到la4文件夹的lab3分支！首先进入lab3再复制，最后进入lab4分支，指定merge lab3分支，成功！。</p>
<h2 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h2><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><table>
<thead>
<tr>
<th style="text-align:center">干什么</th>
<th style="text-align:center">句子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">删除本地的一个分支</td>
<td style="text-align:center">git branch -d <branch name=""></branch></td>
</tr>
<tr>
<td style="text-align:center">新增加一个分支</td>
<td style="text-align:center">git checkout -b <branchname><branchremote></branchremote></branchname></td>
</tr>
<tr>
<td style="text-align:center">删除远程分支</td>
<td style="text-align:center">git push <remotename> -delete <branchname></branchname></remotename></td>
</tr>
</tbody>
</table>
<h3 id="我见过的错误解决方法"><a href="#我见过的错误解决方法" class="headerlink" title="我见过的错误解决方法"></a>我见过的错误解决方法</h3><ol>
<li>在 git merge lab3之后产生冲突，人为解决之后再次merge无法merge：<br>只需根据提示：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git add .</div><div class="line">git commit -m &quot;mesage&quot;</div><div class="line">git merge lab3</div></pre></td></tr></table></figure>
<h2 id="VS"><a href="#VS" class="headerlink" title="VS"></a>VS</h2><h3 id="cmd运行完之后闪退"><a href="#cmd运行完之后闪退" class="headerlink" title="cmd运行完之后闪退"></a>cmd运行完之后闪退</h3><p>可以通过更改属性的方式解决。什么system(“pause”)啊也行吧，但是我觉得没有属性来的方便永久。</p>
<p>“配置属性”–&gt;“链接器”–&gt;“系统”，然后在右侧的列表中，在第一项”子系统“的值中选择”控制台（/SUBSUSTEM:CONSOLE）“。</p>
]]></content>
      
        <categories>
            
            <category> 琐碎 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> all </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[编译原理——语法分析]]></title>
      <url>/2017/11/29/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h1><p>终于开始语法分析的复习了！</p>
<p>上下文无关文法：1. 便于扩充语言特性 2. 语法容易被理解 3. 检错机制加入（其他就不行？）</p>
<p>语法分析器的位置（等待加图）</p>
<p>通用的语法分析器几乎是不可能保证效率的（目前有通用的语法分析器，Cocke-Younger-Kasami），目前有两种算法，<strong>自底向上</strong>（对应最左推导LL），<strong>自顶向下</strong>（对应最右推导LR）。</p>
<h2 id="语法错误处理"><a href="#语法错误处理" class="headerlink" title="语法错误处理"></a>语法错误处理</h2><p>在编程中可能会发生不同的错误，在词法（拼写错误）、语法（单词漏写、顺序错误）、语义、逻辑上都可能会发生错误，其中，语法错误相对较多，成为检查重点。</p>
<p>对语法错误的分析相对简单：它具有<strong>可行前缀/活前缀</strong>特性，在使用给定词法串前缀加上一些字符不能构成该语法的正确语言串时，就会发生错误。</p>
<p>处理错误有三个目标：清楚报告出现的错误、快速从错误中恢复、不能对正确程序的编译处理造成太大的影响。</p>
<blockquote>
<p>给出一个报告错误的方法：打印出有问题的那行 -&gt; 给出一个错误所在地的指针</p>
</blockquote>
<p>错误处理一般在于自圆其说。很难清晰的预测程序员原本的意图，只需要报告最一般的错误可能。</p>
<h3 id="错误恢复策略"><a href="#错误恢复策略" class="headerlink" title="错误恢复策略"></a>错误恢复策略</h3><p><strong>Panic模式</strong>：遇到错误之后，不断丢弃输入中的符号。直到发现$\color{red}{同步词法单元}$集合中的符号。</p>
<p>$\color{red}{同步词法单元}$：通常是界限符，比如分号、右大括号。他们的意图清晰，没有二义性。编译器的设计这必须为自己的编译器定义合适的同步词法单元。</p>
<p>panic模式可能会丢掉很多正常输入（这些失去的分析有可能会影响接下来的分析），但是这种模式很简单，能够保证不会进入无限循环。接下来的几个方法都不能保证。</p>
<p><strong>短语级</strong>：局部修正，继续分析。比如，可能会做一些逗号换分号，加减分号的操作。已经在一些修复型编译器中使用。</p>
<p>需要避免进入无限循环。比如设定是”在有错误的串前面加一个分号“，就可能会一直循环下去。</p>
<p>可以与panic结合，避免丢弃太多单词。</p>
<p><strong>错误产生式</strong>：描述错误模式。</p>
<p>可以更好的进行修正，检测错误信息。</p>
<p><strong>全局修正</strong>：x</p>
<h2 id="上下文无关文法"><a href="#上下文无关文法" class="headerlink" title="上下文无关文法"></a>上下文无关文法</h2><h3 id="正式定义"><a href="#正式定义" class="headerlink" title="正式定义"></a>正式定义</h3><p>一个上下文无关文法由<strong>终结符</strong>、<strong>非终结符</strong>、<strong>一个开始符号</strong>、<strong>一组产生式</strong>组成。使用符号描述是：$(V<em>{T} , V</em>{N} , S , p)$</p>
<p>在文法中有一些约定的命名方式（待补充）</p>
<h3 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h3><p>实际上是语法等价的一个替换过程。使用右部替换左部。</p>
<p><strong>形式化定义</strong>：<br>$$\alphaA\beta \Rightarrow \alpha\gama\beta 当且仅当存在 A \rightarrow \gama$$</p>
<p>$$  $$</p>
<h3 id="推导与语言"><a href="#推导与语言" class="headerlink" title="推导与语言"></a>推导与语言</h3><p><strong>最左推导</strong>：总是替换最左边的非终结符</p>
<p><strong>最右推导</strong>：总是替换最右边的非终结符</p>
<p><strong>形式化定义</strong>：</p>
<h3 id="推导与语法分析树"><a href="#推导与语法分析树" class="headerlink" title="推导与语法分析树"></a>推导与语法分析树</h3><p>一颗语法树可能会对应多个推导过程。如果限制了最左或者最右，那么一个语法树就只能对应一个推导。</p>
<h3 id="CFG设计"><a href="#CFG设计" class="headerlink" title="CFG设计"></a>CFG设计</h3><p>正则表达式可描述符号串$\in$GFG可描述字符串</p>
<h4 id="NFA-gt-CFG"><a href="#NFA-gt-CFG" class="headerlink" title="NFA-&gt;CFG"></a>NFA-&gt;CFG</h4><p>在CFG，与正则不同的是：CFG的开始符号是所有，正则的终态是空串；CFG的终态是空串，正则的终态是所有。</p>
<p>因此：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-29/75004681.jpg" alt=""></p>
<p>终态：$A_i \rightarrow \epsilon$</p>
<blockquote>
<p>形如xy(x!=y)的01串：（不能用正则）</p>
<ol>
<li>奇数串：S-&gt;B|BSB B-&gt;0|1</li>
<li>偶数串：拆成两个穿拼接形式。只要两个奇数串中心位置不同，拼出的偶数串就符合上述描述。<br>给出证明：</li>
</ol>
</blockquote>
<p>证明：</p>
<h4 id="CFG验证"><a href="#CFG验证" class="headerlink" title="CFG验证"></a>CFG验证</h4><p>证明CFG G生成语言L：互相包含。</p>
<blockquote>
<p>一个例子（略）</p>
</blockquote>
<h4 id="CFG修改"><a href="#CFG修改" class="headerlink" title="CFG修改"></a>CFG修改</h4><ol>
<li>去错</li>
<li>重写：满足特殊要求</li>
</ol>
<p>$$不合要求的问题<br>\begin{cases}<br>二义性 \<br>\epsilon-moves \<br>回路 \<br>左递归 \<br>提取左公因子<br>\end{cases}<br>$$</p>
<h4 id="消除二义性"><a href="#消除二义性" class="headerlink" title="消除二义性"></a>消除二义性</h4>]]></content>
      
        <categories>
            
            <category> 编译原理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[编译原理——语法分析]]></title>
      <url>/2017/11/29/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91/</url>
      <content type="html"><![CDATA[<p>Tiny C中的语法树：节点分为两类 语句 表达式<br><a id="more"></a></p>
<p>语句还可以细分，表达式还可以细分。</p>
<p>注意，有些叶节点是不需要保存的。比如说if statement，if ( ) else都可以不需要保存。</p>
<p>具体创建树有两种，一种是递归下降的形式，另一种是yacc的形式，与语法制导定义相似。</p>
<p>（哇那我很多都写错了…这两天是白干了吗…）</p>
]]></content>
      
        <categories>
            
            <category> 编译原理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[串讲复习]]></title>
      <url>/2017/11/27/OS/OS4+Memory%20and%20Process/</url>
      <content type="html"><![CDATA[<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p><strong>例：STL的实现</strong><br>printf：<br>对屏幕：</p>
<ol>
<li>在每一个像素有一种颜色</li>
<li>文本模式</li>
</ol>
<h2 id="系统调用与函数调用"><a href="#系统调用与函数调用" class="headerlink" title="系统调用与函数调用"></a>系统调用与函数调用</h2><p>系统调用是中断，相当于在用户程序执行的过程中嵌入一段由OS完成的代码，完成后再返回用户程序。其中，包括特权级的升降。在进行系统调用的过程中，进入之后首先会检查用户传参是否有危险，随后再执行系统调用。这将在一个新的页完成，存在于<strong>内核态独立地址空间</strong>，将会带来包括TLB，Cache等的一系列问题。因此，系统调用的代价比函数调用的代价大得多。</p>
<h1 id="进程间的通信"><a href="#进程间的通信" class="headerlink" title="进程间的通信"></a>进程间的通信</h1><h2 id="直接通信与间接通信"><a href="#直接通信与间接通信" class="headerlink" title="直接通信与间接通信"></a>直接通信与间接通信</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">send(A,)</div></pre></td></tr></table></figure>
<h2 id="阻塞通信与非阻塞通信"><a href="#阻塞通信与非阻塞通信" class="headerlink" title="阻塞通信与非阻塞通信"></a>阻塞通信与非阻塞通信</h2><p>像网络中那样，阻塞通信就是//</p>
<h2 id="通信链路缓冲"><a href="#通信链路缓冲" class="headerlink" title="通信链路缓冲"></a>通信链路缓冲</h2><p><strong>0容量</strong>：发送方需要等待接收方<br><strong>有限容量</strong>：<br><strong>无限容量</strong>：</p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号类似于中段，</p>
<p>是最原始、最简单的一个进程间交互的模式。在关机时，系统将会用这种方式通知各各进程。</p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>父子之间传递信息</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>类似于电子邮件系统。</p>
<p>得到一个队列，使用队列号来标识。此后消息的send与recv都通过这个队列。</p>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>创建共享段<code>shmget(key,size,flags)</code>。其中key是其他人希望与你共享内存的话必须知道的值。<code>shmat(shmid,*shmaddr,flags)</code>把共享段映射到进程地址空间。</p>
<p>在这里，将又会遇到在“哲学家就餐”那部分的问题。另外，还将会有在cache还是内存的问题。cache作为在读写操作时第一个碰到的硬件，是否可以保证进程A写的时候吧东西写进了共享区的物理内存？在B不能使用的时候它的Cache的正确性哈能不能保证？—？</p>
<p>由一个“可否使用cache”的位</p>
]]></content>
      
        <categories>
            
            <category> OS </category>
            
            <category> MIT Lab </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Lab3_Document]]></title>
      <url>/2017/11/27/OS/Lab3_Document/</url>
      <content type="html"><![CDATA[<h1 id="Lab3-Document"><a href="#Lab3-Document" class="headerlink" title="Lab3 Document"></a>Lab3 Document</h1><h2 id="Part-A：User-Enviornments-and-Exception-Handling"><a href="#Part-A：User-Enviornments-and-Exception-Handling" class="headerlink" title="Part A：User Enviornments and Exception Handling"></a>Part A：User Enviornments and Exception Handling</h2><p>在这一部分，首先需要了解关于在本实验中env（进程）的相关定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//in inc/env.h</span></div><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">    ENV_FREE = <span class="number">0</span>,</div><div class="line">    ENV_DYING,</div><div class="line">    ENV_RUNNABLE,</div><div class="line">    ENV_RUNNING,</div><div class="line">    ENV_NOT_RUNNABLE</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这是在本实验中定义的进程状态，在实验中，仅用到了ENV_FREE、ENV_RUNNABLE、以及ENV_RUNNING。</p>
<p>类似于课上讲的pcb，在本实验中对一个进程的描述定义如下：</p>
<p><code>//in inc/env.c</code></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/83894027.jpg" alt=""></p>
<p>第一个变量env_tf是当中断或异常或系统调用发生的时候，该进程需要保存的寄存器的值；最后一个变量指明了该进程的地址空间。</p>
<p>在kern/env.c中可以看到，关于进程，有三个全局的变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">envs</span> = <span class="title">NULL</span>;</span><span class="comment">// All environments</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">curenv</span> = <span class="title">NULL</span>;</span><span class="comment">// The current env</span></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_free_list</span>;</span><span class="comment">// Free environment list</span></div></pre></td></tr></table></figure>
<p>在马上进行的初始化之后，在envs所标识的物理地址开始，一直到<code>NENV\*(struct Env)</code>结束，是所有可以被使用的进程描述结构占用的空间，每一个(struct Env)大小都是一个可用的Env描述。curenv被指示为是当前正在运行的进程。env_free_list指向第一个可以使用的进程描述结构，这样的设计使得进程描述结构的申请与销毁都变得很容易，而且由于该链表中存储的是处于ENV_FREE状态的进程，很少需要有添加删除的过程。</p>
<h3 id="Allocating-the-Environments-Array"><a href="#Allocating-the-Environments-Array" class="headerlink" title="Allocating the Environments Array"></a>Allocating the Environments Array</h3><p>就像在实验二中那样，在这里需要修改<code>pmap.c</code>中的代码，为envs映射空间。仿照在lab2中的写法，修改程序如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//in kern/pmap.c the first LAB3: Your code here</span></div><div class="line">envs=(struct Env\*)(boot\_alloc(NENV\*<span class="keyword">sizeof</span>(struct Env)));<span class="comment">//为Env结构申请空间</span></div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//in kern/pmap.c the second LAB3: Your code here</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ROUNDUP(NENV\*<span class="keyword">sizeof</span>(struct Env),PGSIZE);i+=PGSIZE)&#123;</div><div class="line">        page_insert(kern_pgdir,(struct PageInfo\*)pa2page(PADDR(envs)+i),(<span class="keyword">void</span>\*)(UENVS+i),PTE_U);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>像在lab2中做过的那样，<code>boot\_map\_region</code>使得从PADDR(envs)开始，连续PTSIZE的物理空间映射到从UENVS开始的虚拟地址空间上。</p>
<p>做到这里尝试<code>make qemu</code>的时候，发现失败了。</p>
<p><strong>注意</strong>：回想在lab2中所做的工作，在<code>page_init</code>函数中曾经为没有用的页面加入freelist。查看当时的代码发现，那时计算剩余空间的时候，是从为npages分配空间呢的后一页开始计算的。在<code>mem_init</code>中修改了之后的映射之后，这时的freelist应该从envs占用所有空间之后的第一页进行添加，于是修改代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> begin=(<span class="keyword">int</span>)ROUNDUP(((<span class="keyword">char</span>*)envs) + (<span class="keyword">sizeof</span>(struct Env) * NENV) - <span class="number">0xf0000000</span>, PGSIZE);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (i=begin/PGSIZE;i&lt;npages;i++)&#123;</div><div class="line">    pages[i].pp_ref=<span class="number">0</span>;</div><div class="line">    pages[i].pp_link=page_free_list;</div><div class="line">    page_free_list=&amp;pages[i];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再次<code>make qemu</code>，得到结果如下：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/91108119.jpg" alt=""></p>
<h3 id="Creating-and-Running-Environments"><a href="#Creating-and-Running-Environments" class="headerlink" title="Creating and Running Environments"></a>Creating and Running Environments</h3><p>在这一部分，将会完善<code>kern/env.c</code>中的内容，来建立起一个进程操作的雏形。</p>
<p>由于还没有文件系统，这时我们用一个技巧来骗过boot loader，使得bootloader加载kernel的时候也把我们需要的用户程序加载进来。这些用户程序在<code>user</code>文件夹下。</p>
<p>首先， -b binary option告诉编译器只需要将程序编译成二进制文件，而不需要生成.o文件，随后把这个文件作为一个较大的数组放在最后，同时在真正应该被搬进内存的文件中声明extern变量，告诉编译器在链接之前先不要管这个。随后，在链接阶段，大数组已经被load进来，与其他代码一同进行地址映射。最终这里的代码可以被执行。</p>
<p>查看<code>kern/init.c</code>文件，发现在所有初始化之后有这样的语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(TEST)</span></div><div class="line">    <span class="comment">// Don't touch -- used by grading script!</span></div><div class="line">    ENV_CREATE(TEST, ENV_TYPE_USER);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="comment">// Touch all you want.</span></div><div class="line">    ENV_CREATE(user_testbss, ENV_TYPE_USER);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>这是告诉编译器：如果用户采用<code>make qemu</code>的方式运行，那么就创建一个user_testbss这样的用户进程，实际上就是执行testbss.c文件生成的那个binary。</p>
<p>在env完成之后对这里进行更深一步的讨论。</p>
<p>接下来需要写出下面几个函数的代码：</p>
<ol>
<li>env_init</li>
<li>env_setup_vm</li>
<li>region_alloc</li>
<li>load_icode</li>
<li>env_create</li>
<li>env_run</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Mark all environments in 'envs' as free, set their env_ids to 0,</span></div><div class="line"><span class="comment">// and insert them into the env_free_list.</span></div><div class="line"><span class="comment">//把所有的envs设置成free的，他们的id都是0，然后插入freelist</span></div><div class="line"><span class="comment">// Make sure the environments are in the free list in the same order</span></div><div class="line"><span class="comment">// they are in the envs array (i.e., so that the first call to</span></div><div class="line"><span class="comment">// env_alloc() returns envs[0]).</span></div><div class="line"><span class="comment">//需要保证所有在freelist里面的env的顺序与在数组中的env相同？？？</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//本函数：初始化所有在env数组中的的env结构，把它们加到freelist里面，要求如上。</span></div><div class="line"><span class="comment">//在meminit之后执行。</span></div><div class="line"><span class="comment">//env数组：*envs，当前：*curenv，freelist：*env_free_list</span></div><div class="line"><span class="keyword">void</span></div><div class="line">env_init(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">    struct Env*current=NULL;</div><div class="line">    <span class="keyword">int</span> i=NENV-<span class="number">1</span>;</div><div class="line">    <span class="comment">//一共NENV个env</span></div><div class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</div><div class="line">    <span class="comment">//NENV is defined in inc/env.h</span></div><div class="line">    <span class="comment">//current-&gt;env_tf=3;</span></div><div class="line">    envs[i].env_id=<span class="number">0</span>;</div><div class="line">    envs[i].env_runs=<span class="number">0</span>;</div><div class="line"><span class="comment">//  current-&gt;env_pgdir=NULL;</span></div><div class="line">    envs[i].env_link=env_free_list;</div><div class="line">    env_free_list=&amp;envs[i];</div><div class="line">    i--;</div><div class="line">&#125;</div><div class="line">    <span class="comment">// Per-CPU part of the initialization</span></div><div class="line">    env_init_percpu();</div><div class="line">    cprintf(<span class="string">"envinit done!\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数比较简单，需要注意的一点是要求倒着添加到链表里面。其他只是按照要求写的代码。</p>
<p>这个函数在最后执行了一个已经完成的函数：<code>env_init_percpu</code>，如下图：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/83957122.jpg" alt=""></p>
<p>该函数完成对各个段寄存器的设置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//为进程e初始化内核虚拟空间</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span></div><div class="line">env_setup_vm(struct Env *e)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	struct PageInfo *p = NULL;</div><div class="line">	<span class="comment">// Allocate a page for the page directory</span></div><div class="line">	<span class="keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))</div><div class="line">		<span class="keyword">return</span> -E_NO_MEM;</div><div class="line">	<span class="comment">// Now, set e-&gt;env_pgdir and initialize the page directory.</span></div><div class="line">	<span class="comment">//初始化pagedir？</span></div><div class="line">	<span class="comment">// Hint:</span></div><div class="line">	<span class="comment">//    - The VA space of all envs is identical above UTOP</span></div><div class="line">	<span class="comment">//	(except at UVPT, which we've set below).</span></div><div class="line">	<span class="comment">//	See inc/memlayout.h for permissions and layout.</span></div><div class="line">	<span class="comment">//	Can you use kern_pgdir as a template?  Hint: Yes.</span></div><div class="line">	<span class="comment">//	(Make sure you got the permissions right in Lab 2.)</span></div><div class="line">	<span class="comment">//所有envs的虚拟地址空间都在UTOP之上</span></div><div class="line">	<span class="comment">//查看inc/memlayout.h看许可以及布局</span></div><div class="line">	<span class="comment">//可以使用kern_pgdir作为一个模板</span></div><div class="line">    <span class="comment">//    - The initial VA below UTOP is empty.</span></div><div class="line">	<span class="comment">//    - You do not need to make any more calls to page_alloc.</span></div><div class="line">	<span class="comment">//    - Note: In general, pp_ref is not maintained for</span></div><div class="line">	<span class="comment">//	physical pages mapped only above UTOP, but env_pgdir</span></div><div class="line">	<span class="comment">//	is an exception -- you need to increment env_pgdir's</span></div><div class="line">	<span class="comment">//	pp_ref for env_free to work correctly.</span></div><div class="line">	<span class="comment">//    - The functions in kern/pmap.h are handy.</span></div><div class="line">	<span class="comment">// LAB 3: Your code here.</span></div><div class="line">	e-&gt;env_pgdir=(pde_t*)page2kva(p);<span class="comment">//page2kva in pmap.c</span></div><div class="line">	p-&gt;pp_ref++;</div><div class="line">	memcpy(e-&gt;env_pgdir,kern_pgdir,PGSIZE);<span class="comment">//kernel's e is the kernel's e</span></div><div class="line">	<span class="comment">//permission:RR</span></div><div class="line">	<span class="comment">//p[PDX(UTOP)] = PADDR(p) | PTE_U | PTE_P;</span></div><div class="line">	<span class="comment">// UVPT maps the env's own page table read-only.</span></div><div class="line">	<span class="comment">// Permissions: kernel R, user R</span></div><div class="line">	e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//为进程申请len字节的物理地址空间，然后把它map到va</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span></div><div class="line">region_alloc(struct Env *e, <span class="keyword">void</span> *va, size_t len)</div><div class="line">&#123;</div><div class="line">	<span class="comment">// LAB 3: Your code here.</span></div><div class="line">	<span class="comment">// (But only if you need it for load_icode.)</span></div><div class="line">	<span class="comment">//</span></div><div class="line">	<span class="comment">// Hint: It is easier to use region_alloc if the caller can pass</span></div><div class="line">	<span class="comment">//   'va' and 'len' values that are not page-aligned.</span></div><div class="line">	<span class="comment">//如果允许传入不是页对齐的va（虚拟地址）和len（长度）的话会更好一些</span></div><div class="line">	<span class="comment">//   You should round va down, and round (va + len) up.</span></div><div class="line">	<span class="comment">//   (Watch out for corner-cases!)</span></div><div class="line">	<span class="comment">//什么叫corner-cases</span></div><div class="line">	<span class="comment">//获取首地址</span></div><div class="line">	<span class="comment">//只是申请了页面，其实没有真正的物理空间</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=(uint32_t)ROUNDDOWN(va,PGSIZE);i&lt;(uint32_t)ROUNDUP(va+len,PGSIZE);i+=PGSIZE)&#123;</div><div class="line">		struct PageInfo*pa=page_alloc(<span class="number">0</span>);</div><div class="line">		<span class="keyword">if</span>(pa==NULL)panic(<span class="string">"fail to alloc !in region_alloc!"</span>);</div><div class="line">		page_insert(e-&gt;env_pgdir,pa,(<span class="keyword">void</span>*)i,PTE_U|PTE_W);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数指定进程申请从指定虚拟地址开始的len字节空间。由于vs与va+len可能不是页面对齐的，因此真正在分配页面的时候，需要做操作ROUNDOWN与ROUNDUP来进行页面的对齐。当申请页面失败时，panic，否则就将页面插入到当前进程的pgdir中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span></div><div class="line">load_icode(struct Env *e, uint8_t *binary)<span class="comment">//binary：ELF</span></div><div class="line">&#123;<span class="comment">//注意，对应的用户数据已经在内存中了</span></div><div class="line">	struct Elf*elf=(struct Elf*)binary;<span class="comment">//给定的ELF文件头结构（更详细的，查看inc/elf.h）</span></div><div class="line">	struct Proghdr *ph, *eph;<span class="comment">//ELF文件指定程序段的程序头</span></div><div class="line">		<span class="comment">// is this a valid ELF?</span></div><div class="line">	<span class="keyword">if</span> (elf-&gt;e_magic != ELF_MAGIC)</div><div class="line">		panic(<span class="string">"not a elf!"</span>);</div><div class="line">	ph = (struct Proghdr *) ((uint8_t *) elf + elf-&gt;e_phoff);<span class="comment">//第一个程序头开始</span></div><div class="line">	eph = ph + elf-&gt;e_phnum;<span class="comment">//最后一个不是程序头结构开始的位置</span></div><div class="line">	lcr3(PADDR(e-&gt;env_pgdir));<span class="comment">//将CR3中装载进去这次的页目录</span></div><div class="line">	<span class="keyword">for</span> (; ph &lt; eph; ph++)&#123;</div><div class="line">		<span class="keyword">if</span>(ph-&gt;p_type==ELF_PROG_LOAD)&#123;</div><div class="line">		region_alloc(e,(<span class="keyword">void</span>*)ph-&gt;p_va,ph-&gt;p_memsz);</div><div class="line">        <span class="comment">//申请从ph-&gt;p_va程序假设自己所在的虚拟地址开始，到va+memsz结束的空间</span></div><div class="line">		memmove((<span class="keyword">void</span>*)ph-&gt;p_va,binary+ph-&gt;p_offset,ph-&gt;p_filesz);</div><div class="line">    <span class="comment">//  The ph-&gt;p_filesz bytes from the ELF binary, starting at</span></div><div class="line">	<span class="comment">//  'binary + ph-&gt;p_offset', should be copied to virtual address</span></div><div class="line">	<span class="comment">//  ph-&gt;p_va.  Any remaining memory bytes should be cleared to zero.</span></div><div class="line">	<span class="comment">//  (The ELF header should have ph-&gt;p_filesz &lt;= ph-&gt;p_memsz.)</span></div><div class="line">	<span class="comment">//  Use functions from the previous lab to allocate and map pages.</span></div><div class="line">	<span class="comment">//在ELF中的ph-&gt;p_filesz字节的，从binary+ph-&gt;p_offset都应该被copy到虚拟地址空间ph-&gt;p_va</span></div><div class="line">	<span class="comment">//任何剩余的空间被清零</span></div><div class="line">		memset((<span class="keyword">void</span>*)(ph-&gt;p_va+ph-&gt;p_filesz),<span class="number">0</span>,ph-&gt;p_memsz-ph-&gt;p_filesz);<span class="comment">//eme2file</span></div><div class="line">		<span class="comment">//memcpy((void*)ph-&gt;p_va,binary+ph-&gt;p_offset,ph-&gt;p_filesz);</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"><span class="comment">//after modification , everything is OK!</span></div><div class="line">	<span class="comment">// call the entry point from the ELF header</span></div><div class="line">	<span class="comment">// note: does not return!</span></div><div class="line">	<span class="comment">//((void (*)(void)) (ELFHDR-&gt;e_entry))();</span></div><div class="line">	e-&gt;env_tf.tf_eip=elf-&gt;e_entry;</div><div class="line">	<span class="comment">// Now map one page for the program's initial stack</span></div><div class="line">	<span class="comment">// at virtual address USTACKTOP - PGSIZE.</span></div><div class="line">	<span class="comment">// LAB 3: Your code here.</span></div><div class="line">	region_alloc(e,(<span class="keyword">void</span>*)(USTACKTOP-PGSIZE),PGSIZE);</div><div class="line">	lcr3(PADDR(kern_pgdir));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数负责把已经装入内存的binary文件重新装载到ELF文件头中指定的位置，并为用户进程创建一个栈。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span></div><div class="line">env_create(uint8_t *binary, <span class="keyword">enum</span> EnvType type)</div><div class="line">&#123;</div><div class="line">	<span class="comment">// LAB 3: Your code here.</span></div><div class="line">	struct Env *newenv_store;</div><div class="line">	<span class="keyword">int</span> result=env_alloc(&amp;newenv_store,<span class="number">0</span>);</div><div class="line">	<span class="keyword">if</span>(result&lt;<span class="number">0</span>)panic(<span class="string">"env_alloc: %e"</span>, result); ;</div><div class="line">	<span class="keyword">if</span>(result==<span class="number">0</span>)&#123;</div><div class="line">		newenv_store-&gt;env_type=type;</div><div class="line">		load_icode(newenv_store,binary);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用到了已经定义好的函数：<code>env_alloc</code>。<code>env_create</code>本身比较简单，我们来看一下<code>env_alloc</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span></div><div class="line">env_alloc(struct Env **newenv_store, envid_t parent_id)</div><div class="line">&#123;</div><div class="line">	int32_t generation;</div><div class="line">	<span class="keyword">int</span> r;</div><div class="line">	struct Env *e;</div><div class="line">	<span class="comment">//没有新的可以用了</span></div><div class="line">	<span class="keyword">if</span> (!(e = env_free_list))</div><div class="line">		<span class="keyword">return</span> -E_NO_FREE_ENV;</div><div class="line">	<span class="comment">// Allocate and set up the page directory for this environment.</span></div><div class="line">	<span class="keyword">if</span> ((r = env_setup_vm(e)) &lt; <span class="number">0</span>)</div><div class="line">		<span class="keyword">return</span> r;</div><div class="line">	<span class="comment">// Generate an env_id for this environment.</span></div><div class="line">	generation = (e-&gt;env_id + (<span class="number">1</span> &lt;&lt; ENVGENSHIFT)) &amp; ~(NENV - <span class="number">1</span>);</div><div class="line">	<span class="keyword">if</span> (generation &lt;= <span class="number">0</span>)	<span class="comment">// Don't create a negative env_id.</span></div><div class="line">		generation = <span class="number">1</span> &lt;&lt; ENVGENSHIFT;</div><div class="line">	e-&gt;env_id = generation | (e - envs);</div><div class="line">	<span class="comment">// Set the basic status variables.</span></div><div class="line">	e-&gt;env_parent_id = parent_id;</div><div class="line">	e-&gt;env_type = ENV_TYPE_USER;</div><div class="line">	e-&gt;env_status = ENV_RUNNABLE;</div><div class="line">	e-&gt;env_runs = <span class="number">0</span>;</div><div class="line">	<span class="comment">// Clear out all the saved register state,</span></div><div class="line">	<span class="comment">// to prevent the register values</span></div><div class="line">	<span class="comment">// of a prior environment inhabiting this Env structure</span></div><div class="line">	<span class="comment">// from "leaking" into our new environment.</span></div><div class="line">	memset(&amp;e-&gt;env_tf, <span class="number">0</span>, sizeof(e-&gt;env_tf));</div><div class="line">	<span class="comment">// Set up appropriate initial values for the segment registers.</span></div><div class="line">	<span class="comment">// GD_UD is the user data segment selector in the GDT, and</span></div><div class="line">	<span class="comment">// GD_UT is the user text segment selector (see inc/memlayout.h).</span></div><div class="line">	<span class="comment">// The low 2 bits of each segment register contains the</span></div><div class="line">	<span class="comment">// Requestor Privilege Level (RPL); 3 means user mode.  When</span></div><div class="line">	<span class="comment">// we switch privilege levels, the hardware does various</span></div><div class="line">	<span class="comment">// checks involving the RPL and the Descriptor Privilege Level</span></div><div class="line">	<span class="comment">// (DPL) stored in the descriptors themselves.</span></div><div class="line">	e-&gt;env_tf.tf_ds = GD_UD | <span class="number">3</span>;</div><div class="line">	e-&gt;env_tf.tf_es = GD_UD | <span class="number">3</span>;</div><div class="line">	e-&gt;env_tf.tf_ss = GD_UD | <span class="number">3</span>;</div><div class="line">	e-&gt;env_tf.tf_esp = USTACKTOP;</div><div class="line">	e-&gt;env_tf.tf_cs = GD_UT | <span class="number">3</span>;</div><div class="line">	<span class="comment">// You will set e-&gt;env_tf.tf_eip later.</span></div><div class="line">	<span class="comment">// commit the allocation</span></div><div class="line">	env_free_list = e-&gt;env_link;</div><div class="line">	*newenv_store = e;</div><div class="line">	cprintf(<span class="string">"[%08x] new env %08x\n"</span>, curenv ? curenv-&gt;env_id : <span class="number">0</span>, e-&gt;env_id);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数完成一系列的初始化操作，申请新进程，地址空间申请，一些属性的设置（这也是在env_init中不是做设置的原因），寄存器值的清理与设置等等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span></div><div class="line">env_run(struct Env *e)</div><div class="line">&#123;</div><div class="line">		<span class="keyword">if</span> (curenv != e) &#123;</div><div class="line">		<span class="comment">// if (curenv-&gt;env_status == ENV_RUNNING)</span></div><div class="line">		<span class="comment">// 	curenv-&gt;env_status = ENV_RUNNABLE;</span></div><div class="line">		curenv = e;</div><div class="line">		e-&gt;env_status = ENV_RUNNING;</div><div class="line">		e-&gt;env_runs++;</div><div class="line">		lcr3(PADDR(e-&gt;env_pgdir));<span class="comment">//将当前的地址空间设置为当前进程的地址空间</span></div><div class="line">	&#125;</div><div class="line">	env_pop_tf(&amp;e-&gt;env_tf);</div><div class="line"></div><div class="line">	<span class="comment">//panic("env_run not yet implemented");</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数只需要根据提示即可写出，看一下<code>env_pop_tf</code>的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span></div><div class="line">env_pop_tf(struct Trapframe *tf)</div><div class="line">&#123;</div><div class="line">	<span class="function">__asm <span class="title">__volatile</span><span class="params">(<span class="string">"movl %0,%%esp\n"</span></span></span></div><div class="line"><span class="function"><span class="params">		<span class="string">"\tpopal\n"</span></span></span></div><div class="line"><span class="function"><span class="params">		<span class="string">"\tpopl %%es\n"</span></span></span></div><div class="line"><span class="function"><span class="params">		<span class="string">"\tpopl %%ds\n"</span></span></span></div><div class="line"><span class="function"><span class="params">		<span class="string">"\taddl $0x8,%%esp\n"</span> <span class="comment">/* skip tf_trapno and tf_errcode */</span></span></span></div><div class="line"><span class="function"><span class="params">		<span class="string">"\tiret"</span></span></span></div><div class="line"><span class="function"><span class="params">		: : <span class="string">"g"</span> (tf)</span> : "memory")</span>;</div><div class="line">	<span class="comment">//对应的汇编代码：</span></div><div class="line">	<span class="comment">/*</span></div><div class="line"><span class="comment">	mov tf,eax</span></div><div class="line"><span class="comment">	movl eax,esp</span></div><div class="line"><span class="comment">	popal</span></div><div class="line"><span class="comment">	popl es</span></div><div class="line"><span class="comment">	popl ds</span></div><div class="line"><span class="comment">	addl $0x8,esp</span></div><div class="line"><span class="comment">	iret</span></div><div class="line"><span class="comment">	*/</span></div><div class="line">	<span class="comment">//从这里开始，真正退出了内核态，进入用户态</span></div><div class="line">	panic(<span class="string">"iret failed"</span>);  <span class="comment">/* mostly to placate the compiler */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>真正开始运行时，是需要trap伪装栈内容之后才能调用该函数，进入用户态的。trap的内容将在PartB讨论。届时还会需要用到该函数的内容。</p>
<p>按照文档的说明，使用<code>b env_pop_tf</code>打断点，查看内容，在经过若干次执行之后：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/74775132.jpg" alt=""></p>
<p>iret将进行退栈操作，此处暂未涉及。</p>
<p>这里写完之后，就可以梳理一下在进入用户态之前都发生了什么：(in kern/init.c)</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/30532.jpg" alt=""></p>
<p>首先，清理bss。这将保证所有未初始化的都是0，在testbss中将会有体现。然后初始化控制台，进行内存的初始化，进程初始化，trap的初始化。随后创建一个env，开始执行。</p>
<p>现在，我们可以讨论在上面提到过的<code>ENV_CREATE</code>。</p>
<p><code>ENV_CREATE</code>在<code>kern/env.c</code>中被定义：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/30871223.jpg" alt=""></p>
<p>首先可以看到本文件对那些骗boot loader装载进来的用户程序的外部定义，随后调用env_create函数，以<code>ENV_PASTE3(_binary_obj_, x, _start)</code>作为传入的ELF文件头结构，以type作为类型被创建。</p>
<p>随后，在create之后，执行load_icode，将对应内存的文件搬运到指定内存，并设置进程的入口点为函数的入口点，为用户进程初始化map一个页空间的栈，准备开始执行。</p>
<p>随后，调用了env_run函数，执行这个已经准备好的用户程序。但是在这个阶段，这个程序实际上还不能被真正执行。</p>
<h3 id="Handling-Interrupts-and-Exceptions"><a href="#Handling-Interrupts-and-Exceptions" class="headerlink" title="Handling Interrupts and Exceptions"></a>Handling Interrupts and Exceptions</h3><p>中断与异常都将会打断原有程序的执行，转而执行其他程序。他们的区别就在于，中断用于处理那些处理器外部的异步事件，而异常处理被处理器在执行指令时发现的错误情况。</p>
<p>中断会被INTR引起，异常会被INT引起。这也确定了breakpoint应该是一个异常而不是中断。</p>
<h3 id="Basics-of-Protected-Control-Transfer"><a href="#Basics-of-Protected-Control-Transfer" class="headerlink" title="Basics of Protected Control Transfer"></a>Basics of Protected Control Transfer</h3><p>中断和异常都可能完成这个转化，完成特权级的转化需要两个东西：<strong>IDT</strong>与<strong>TSS</strong>。</p>
<p><strong>IDT</strong>：IDT确保了用户程序切换到内核态的情况只有已经由kernel定义的几种，保证切换过程中的安全性。 x86允许256个不同的中断或异常，他们有着不一样的<strong>中断向量</strong>，CPU利用中断向量来确定这个中断的中断向量表，进而找到处理中断的入口，执行处理程序。<br>找到中断向量的描述符之后，EIP中装载的将会是中断处理程序的入口地址，CS中装载的是运行优先级。不一样的运行优先级设置带来不一样的结果，在接下来的实验中将会被讨论到。</p>
<p>一个IDT Gate是这样的：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/79807638.jpg" alt=""></p>
<p>segment selector与offset用来描述在段机制下自己的中断响应函数的位置。segment selector负责在GDT里面找到对应的段，offset负责找对应的偏移量。找到函数之后，保存现场并执行响应函数。</p>
<p><strong>TSS</strong>：处理器需要空间来存储旧的寄存器中的值，这样从中断或异常中返回的时候，用户程序才能够接着执行。因此，在从用户态切换到内核态的时候，需要换一个栈进行操作。这时就需要TSS来确定段寄存器来确定这个栈到底在哪里。<br>从用户态切换到内核态时，首先在栈中push一些寄存器值：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-14/87170051.jpg" alt=""></p>
<p>然后加载中断描述符中的值，然后把ESP和SS置为指向新栈的值。</p>
<p>尽管TSS可能会很复杂，但是在这个实验中只是用到了指向内核栈的部分。</p>
<p>在中断发生的时候，系统将会看一下产生中断的程序的特权级，决定应该怎样保护现场。如果在特权状态，不用换栈，只需要保存更少的东西，而处于用户状态下的程序在执行完中断响应函数之后还要从内核栈退回到自己的用户栈，保存了更多的东西。</p>
<p>iret：系统指令，从中断中返回。<br>ret：从函数中返回<br>retf：与ret基本一样，从函数中返回。（弹出栈，拿出返回地址（就是下一条语句）返回值，丢掉压栈参数）</p>
<h3 id="Types-of-Exceptions-and-Interrupts"><a href="#Types-of-Exceptions-and-Interrupts" class="headerlink" title="Types of Exceptions and Interrupts"></a>Types of Exceptions and Interrupts</h3><p>当一个进程在User Environment运行时，忽然遇到了一个中断：</p>
<ol>
<li>进程切换到被TSS定义的那个栈，在JOS中SS0是GD_KD（GDT中的kernel code），ESP0是KSTACKTOP。</li>
<li>进程把一些值push到这个kernel栈里面。</li>
<li>找到IDT entry，开始执行函数</li>
</ol>
<p>需要注意的是，就像上面已经讨论过的，有些中断/异常会push error code，而有的不会。</p>
<p>如果是在内核态发生了中断，就不需要进行换栈操作，这时旧的SS与ESP不会被保存。</p>
<p>怎么从内核态切换到用户态呢，其实方法是相似的。新开一个用户栈，存上中断以为的数据，随后iret，这样就降到了用户模式。</p>
<h3 id="Setting-Up-the-IDT"><a href="#Setting-Up-the-IDT" class="headerlink" title="Setting Up the IDT"></a>Setting Up the IDT</h3><p>现在来查看本实验中关于中断/trap的内容。</p>
<p>在<code>inc/trap.h</code>中定义了许多中断号，PushRegs结构以及TrapFrame结构。</p>
<p>TrapFrame结构中定义了trapnumer、es、ds等在值，这些值在特权级发生改变的时候会被压栈出栈保存，在后面还会用到。</p>
<p>为了完成Exercise4，首先分析trap.c以及trapentry.S中的代码：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/27936694.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/10236379.jpg" alt=""></p>
<p>这两个macro将会帮我们进行trapno的压栈操作，函数名的定义。第一个用于自动压栈errorcode的，后一个处理不自动压栈errorcode的。<br>找到每个中断类型的压栈方式：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/2785767.jpg" alt=""></p>
<p>这时应该明确，这时仍处于原来的特权级。</p>
<p>于是，使用上述两个macro来为trap添加一个入口点，这部分的代码：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/63275240.jpg" alt=""></p>
<p>然后考虑<code>/kern/trap.c</code>中的内容，在这之前，首先查看macro SETGATE的作用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//in inc\mmu.h</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SETGATE(gate, istrap, sel, off, dpl)			\</span></div><div class="line">&#123;								\</div><div class="line">	(gate).gd_off_15_0 = (<span class="keyword">uint32_t</span>) (off) &amp; <span class="number">0xffff</span>;		\</div><div class="line">	(gate).gd_sel = (sel);					\</div><div class="line">	(gate).gd_args = <span class="number">0</span>;					\</div><div class="line">	(gate).gd_rsv1 = <span class="number">0</span>;					\</div><div class="line">	(gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;	\</div><div class="line">	(gate).gd_s = <span class="number">0</span>;					\</div><div class="line">	(gate).gd_dpl = (dpl);					\</div><div class="line">	(gate).gd_p = <span class="number">1</span>;					\</div><div class="line">	(gate).gd_off_31_16 = (<span class="keyword">uint32_t</span>) (off) &gt;&gt; <span class="number">16</span>;		\</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个macro帮我们设置了IDT的Gate。</p>
<p>于是，根据前面对TRAPHANDLER_NOEC与TRAPHANDLER的描述以及SETGATE，写trap_init如下：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/96169964.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/5194488.jpg" alt=""></p>
<p>接下来考虑_alltraps。根据提示，写出如下代码：</p>
<p>提示信息：</p>
<p>Your _alltraps should: </p>
<pre><code>1. push values to make the stack look like a struct Trapframe
2. load GD_KD into %ds and %es
3. pushl %esp to pass a pointer to the Trapframe as an argument to trap()
4. call trap (can trap ever return?)
</code></pre><p>Consider using the pushal instruction; it fits nicely with the layout of the struct Trapframe. </p>
<p>代码：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/93817695.jpg" alt=""></p>
<p>进行makegrade检测：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/34710148.jpg" alt=""></p>
<p>Answer the following questions in your answers-lab3.txt: </p>
<pre><code>1. What is the purpose of having an individual handler function for each exception/interrupt? (i.e., if all exceptions/interrupts were delivered to the same handler, what feature that exists in the current implementation could not be provided?)

2. Did you have to do anything to make the user/softint program behave correctly? The grade script expects it to produce a general protection fault (trap 13), but softint&apos;s code says int $14. Why should this produce interrupt vector 13? What happens if the kernel actually allows softint&apos;s int $14 instruction to invoke the kernel&apos;s page fault handler (which is interrupt vector 14)?
</code></pre><p>回答：</p>
<ol>
<li><p>如果所有的中断都是一个响应函数，那么首先需要统一是不是要自动压栈errorcode，其次在SETGATE时就无法指定特权级，就不能为内核中断提供不同的保护。比如syscall允许用户程序产生，但是诸如divideerror等只可以由硬件产生，如果所有都是用同一个优先级，很容易被别有用心的用户程序取得内核权限。</p>
</li>
<li><p>pagefault14不允许用户程序直接发起，必须经由硬件产生。这种机制可以更好地保护内存。假如允许用户程序自己产生int14，则每引发一个缺页中断系统就需要分配一个虚拟页，可能会被恶意程序利用，使得内存崩溃。而int13则是general protection interrupt，保护自己不去管那些不允许用户自己产生的中断。<br>如果希望int14可以正常被用户程序直接产生，应该将其特权级设置为3.</p>
</li>
</ol>
<h2 id="Page-Faults-Breakpoints-Exceptions-and-System-Calls"><a href="#Page-Faults-Breakpoints-Exceptions-and-System-Calls" class="headerlink" title="Page Faults, Breakpoints Exceptions, and System Calls"></a>Page Faults, Breakpoints Exceptions, and System Calls</h2><h3 id="Handling-Page-Faults"><a href="#Handling-Page-Faults" class="headerlink" title="Handling Page Faults"></a>Handling Page Faults</h3><p>page fault是14号中断。当处理器捕获到14号中断的时候，它会在CR2中存储一个引起pagefault的线性地址。下面来处理这个中断。</p>
<p>在上一步分析到，在把es与ds分别都设置为GD_KD之后，这时调用trap函数，我们先来分析trap函数。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/42158612.jpg" alt=""></p>
<p>FL_IF是在inc/mmu.h中定义的中断标志。如果寄存器eflage中中断标志没有被置位，则不是一个中断。</p>
<p>在tf结构tf_cs的低位存储着优先级，假如优先级是3，则是在用户态。这时是无权处理中断函数的，应该<strong>首先升级成为内核态</strong>，然后再处理。<br>然后调用trap_diapatch，来分发处理各种不同的trap，处理完毕回来之后，如果没有什么异常就可以接着运行。</p>
<p>在trap_dispatch中添加下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(tf-&gt;tf_trapno==T_PGFLT)&#123;</div><div class="line">        page_fault_handler(tf);<span class="comment">//此时该函数尚未完成</span></div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这时去查看page_fault_handle，此函数尚未完成，但是对于用户态的trap已经给出了解决，可以看到一句代码<code>fault_va = rcr2();</code>。这就是前面提到的在CR2中储存引起pagefault的线性地址，随后的打印操作即可以打印出这事的信息。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/48273990.jpg" alt=""></p>
<h3 id="The-Breakpoint-Exception"><a href="#The-Breakpoint-Exception" class="headerlink" title="The Breakpoint Exception"></a>The Breakpoint Exception</h3><p>其实，breakpoint也只是一个异常，函数入口点的相关代码在前面都已经写出来了。<br>需要说的是，在我最早使用breakpoint作为该函数的名字时，运行<code>make run-breakpoint</code>一直不成功。如果breakpoint还有其他用处，希望可以发现。目前暂时搁置这个问题。</p>
<p>这里需要做的只是补充trap_dipatch，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == T_BRKPT) &#123;</div><div class="line">    monitor(tf);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Questions</p>
<pre><code>1. The break point test case will either generate a break point exception or a general protection fault depending on how you initialized the break point entry in the IDT (i.e., your call to SETGATE from trap_init). Why? How do you need to set it up in order to get the breakpoint exception to work as specified above and what incorrect setup would cause it to trigger a general protection fault?

2. What do you think is the point of these mechanisms, particularly in light of what the user/softint test program does?
</code></pre><p>回答：</p>
<ol>
<li><p>这个问题的答案与上一个相似。当特权级设置为0的时候，只允许硬件产生中断而不会允许用户自己去调用。</p>
</li>
<li><p>更好的保护机制。</p>
</li>
</ol>
<p>makegrade信息将在最后一同贴出。</p>
<h3 id="System-calls"><a href="#System-calls" class="headerlink" title="System calls"></a>System calls</h3><p>在JOS中，系统调用定义的中断号是48号，系统调用不能由硬件产生，因此需要允许用户程序来生成系统调用。这也是在SETGATE中最后一个参数是3的原因。system call在初步判断时与trap处理相同，但是处理过程更加复杂。应用程序将会把系统调用的号码以及参数放在寄存器里面，这样内核将不需要在用户环境的堆栈或指令流中找数据。sysno将会在寄存器eax之中，其他参数将会在edx , ecx , ebx , edi , esi之中。返回时的返回值将会存在eax之中。</p>
<p>首先查看<code>lib/syscall.c</code>，syscall的代码以及对应的汇编代码如下：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/41487023.jpg" alt=""></p>
<p>补充<code>kern/syscall.c</code>以及<code>kern/trap.c</code>，代码如下：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/24297553.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/69032262.jpg" alt=""></p>
<p>这里需要提出的是，在<code>kern/syscall.c</code>中有另一个未完成的函数<code>sys_cput</code>，这个函数要求检查内存是否可以被访问，而在后面的练习中有相关函数的补充，在这里先不贴出代码。</p>
<h3 id="User-mode-startup"><a href="#User-mode-startup" class="headerlink" title="User-mode startup"></a>User-mode startup</h3><p>用户程序开始运行时是在<code>lib/entry.S</code>，随后在<code>lib/libmain.c</code>中call libmain()。<br>在<code>lib/entry.S</code>中可以看到：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/45324538.jpg" alt=""></p>
<p>envs已经被定义了，因此下面进入<code>lib/libmain.c</code>来初始化thisenv。根据提示，查看<code>inc/env.h</code>中的ENVX，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ENVX(envid)     ((envid) &amp; (NENV - 1))</span></div></pre></td></tr></table></figure>
<p>为了得到当前的进程号，可以调用在<code>kern/syscall.c</code>中的<code>sys_getenvid</code>函数，该函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">envid_t</span></div><div class="line">sys_getenvid(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> curenv-&gt;env_id;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是，根据<code>inc/env.h</code>，env_id并不是一个完全的envs中的序号，</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/22708337.jpg" alt=""></p>
<p>根据注释，ENVX(eid)才是真正在envs中的偏移，于是，在libmain中的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">thisenv = envs+ENVX(sys_getenvid());</div></pre></td></tr></table></figure>
<p>其实，只有在这部分完成之后，才能正确的调用用户函数。这是因为在退出时需要访问thisenv-&gt;env_id，而先前这个变量并没有值。</p>
<p>在用户程序执行完成之后，就会调用<code>sys_env_destory</code>来退出自己。</p>
<h3 id="Page-faults-and-memory-protection"><a href="#Page-faults-and-memory-protection" class="headerlink" title="Page faults and memory protection"></a>Page faults and memory protection</h3><p>内存保护是操作系统的一个重要特性，确保一个程序中的错误不会破坏其他程序或破坏OS本身。OS通常依赖于硬件来保护自己，他知道哪块虚拟地址可用，哪块不可用，如果一个程序想要访问他没有权限访问的地址，会引发错误。如果这个错误可以被解决，OS会试图解决，如果不能解决，犯错的进程就不可以再运行了。</p>
<p>系统调用为内存保护提出了一个有趣的问题。大多数系统调用接口让用户程序将指针传递给内核。这些指针指向要读取或写入的用户缓冲区。内核然后在执行系统调用的时候去引用这些指针。这有两个问题：</p>
<p>1.内核中的页面错误可能比用户程序中的页面错误严重得多。如果内核页面在处理自己的数据结构的时候出错，这是一个内核错误，而且错误处理程序应该让内核（也就是整个系统）崩溃。但是当内核解引用用户程序给它的指针时，它需要一种方法来记住任何页面错误，这些解除引用实际上是代表用户程序。</p>
<p>2.内核通常拥有比用户程序更多的内存权限。用户程序可能会传递一个指向系统调用的指针，指向内核可以读或写的内存，但是程序不能。内核必须小心，不要被欺骗引用这样一个指针，因为这可能会泄露私有信息或破坏内核的完整性。</p>
<p>下面将处理对用户读写指针的访问权限处理，如果用户想要读写的地方表示允许，就允许，否则不允许。而内核，如果出现了page fault，立即崩溃。</p>
<p>在<code>kern/trap.c</code>中添加对内核发生了pagefault的处理，这也是上面提到的尚未完成的操作。<br>根据提示，由于tf_cs中的低位代表特权级，直接查看特权级：如果不是在用户态发生的，就直接panic。<br>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ((tf-&gt;tf_cs&amp;<span class="number">3</span>) == <span class="number">0</span>)</div><div class="line">    panic(<span class="string">"Kernel page fault!"</span>);</div></pre></td></tr></table></figure>
<p>接下来对<code>kern/pmap.c</code>中的<code>user_mem_check</code>以及<code>user_mem_assert</code>进行操作：</p>
<p>只需要按照说明检查内存中位置以及PTE_P和PTE_U等即可，直接贴出代码：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/79810310.jpg" alt=""></p>
<p>下面是<code>user_mem_assert</code>的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//检查进程env是不是允许访问这个区域</span></div><div class="line"><span class="comment">//如果可以就return</span></div><div class="line"><span class="comment">//不行的话env就死了，如果env是当前运行进程，就不返回了</span></div><div class="line"><span class="comment">//user_mem_check</span></div><div class="line"><span class="keyword">void</span></div><div class="line">user_mem_assert(struct Env *env, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len, <span class="keyword">int</span> perm)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span> (user_mem_check(env, va, len, perm | PTE_U) &lt; <span class="number">0</span>) &#123;</div><div class="line">		cprintf(<span class="string">"[%08x] user_mem_check assertion failure for "</span></div><div class="line">			<span class="string">"va %08x\n"</span>, env-&gt;env_id, user_mem_check_addr);</div><div class="line">		env_destroy(env);	<span class="comment">// may not return</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，对在实验1中写过的debuginfo_eip进行更改，使得backtrace可以使用。<br>将代码贴出：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/326256.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/93317967.jpg" alt=""></p>
<p>本实验的基础部分到这里结束。</p>
<p>最终的makegrade：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/36947975.jpg" alt=""></p>
<p>CHALLENGE：</p>
<p>完成了单步执行的challenge。</p>
<p>根据提示，查找EFLAGS信息，得到这样的信息：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/4368506.jpg" alt=""></p>
<p>于是为了能够单步执行，z在monitor中修改如下部分：</p>
<ol>
<li>添加指令si</li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/34291928.jpg" alt=""></p>
<ol>
<li>写函数mon_si并在.h中声明（声明略去）</li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/78360085.jpg" alt=""></p>
<ol>
<li>修改kern/trap.c，使得能够处理debug的中断信息</li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/25025088.jpg" alt=""></p>
<p>运行：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/52901081.jpg" alt=""></p>
<p>类似的，就可以加上c指令使继续运行到下一个breakpoint。</p>
<ol>
<li><p>添加指令c </p>
</li>
<li><p>写函数mon_c</p>
</li>
</ol>
<p>只是，这时需要将TF位置为0。</p>
<p>结果：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/25564738.jpg" alt=""></p>
<p>为了更好地查看si与c的结果，我将breakpoint.c修改为下：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/1130654.jpg" alt=""></p>
<p>最后，再次运行make grade：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-28/12202433.jpg" alt=""></p>
<p>本实验完成。代码已经提交到git.mobisys.cc。</p>
<p><a href="https://note.youdao.com/share/?id=940fc869a8dc1daa06e9e955495a80c6&amp;type=notebook#/EE533F3CCE0E4E579776693DB25883E1" target="_blank" rel="external">点击链接预览lab3工程代码~</a></p>
<p><a href="https://pan.baidu.com/s/1bppVmR9" target="_blank" rel="external">如果想要直接下载的话就点这个（这是百度的网盘）</a></p>
<p>yayi2456  &lt;(￣︶￣)↗[GO!]&gt;</p>
<p>最后，列出那些给过我帮助的网站！谢谢！（也便于我以后找到！</p>
<p><a href="https://github.com/Clann24/jos/" target="_blank" rel="external">一个学霸的自我修养 clann24</a></p>
<p>clann的实际代码与README代码不一样啊，而且明明clann的自己可以运行，加到我的代码上却不能运行了。<br>对clann的load_icode存疑。</p>
<p><a href="http://blog.csdn.net/woxiaohahaa/article/details/50550208" target="_blank" rel="external">朴实中透露着惊喜 mick_seu</a></p>
<p>可以说是很厉害了。代码简单易懂，正确率超高，超适用。</p>
<p><a href="https://www.kancloud.cn/wizardforcel/jos-lab/97520" target="_blank" rel="external">学习并快乐着 飞龙</a></p>
<p>飞龙的代码也很简单易懂！而且一看就是自己写的，与网上主流的都不一样。</p>
<p><a href="http://blog.163.com/tianhail@126/blog/static/140395915201021643354880/" target="_blank" rel="external">X86 CPU的EFLAGS寄存器各个标识位  伊凡</a></p>
<p><a href="https://stackoverflow.com/questions/1406783/how-to-read-and-write-x86-flags-registers-directly" target="_blank" rel="external">How to read and write x86 flags registers directly? stackoverflow</a></p>
<p>我需要BB一句。到了OS课的该是大三了。stackoverflow这个社区真的是强推，无数问题都是在这个社区找到的回答。嗯，强推。</p>
<p><a href="https://markdowntohtml.com/" target="_blank" rel="external">markdown to html md转html在线</a></p>
<p>emm其实效果一般…很不好….但是，毕竟在线，不想用的话，自己安装pandoc，费劲费空间。</p>
<p><a href="http://www.atool.org/html2markdown.php" target="_blank" rel="external">另外一个html与md</a></p>
<p><a href="http://www.oschina.net/question/100267_75314" target="_blank" rel="external">markdown的chrome插件</a></p>
]]></content>
      
        <categories>
            
            <category> OS </category>
            
            <category> MIT Lab </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机网络概述]]></title>
      <url>/2017/11/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</url>
      <content type="html"><![CDATA[<p>这是第一次课！时隔许久，也算是复习啦~</p>
<p>#</p>
<h1 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h1><h1 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h1><h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><p>在各种网络之中，端对端之间互相传送<strong>报文</strong>。为了从源系统项目地端系统发送报文，源端系统将报文分成若干的小数据块，成为<strong>分组</strong>。每个分组都通过源端系统与目的端系统之间的<strong>分组交换机</strong>（主要是<strong>路由器</strong>以及<strong>链路交换机</strong>）传送。分组以等于链路最大传输速率的速度通过通信链路，因此如果传输速度是R比特/s，那么传输L比特分组的时间是L/R比特/s。</p>
<h3 id="存储转发传输"><a href="#存储转发传输" class="headerlink" title="存储转发传输"></a>存储转发传输</h3><p>多数分组交换机在链路的输入端使用<strong>存储转发传输</strong>机制，它是指在交换机开始发送第一个比特之前，必须接收到整个分组。</p>
<p>我们看一个例子：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-22/26732713.jpg" alt=""></p>
<p>如果发送方要传送长是L的报文，两条链路传输速率都是Rbit/s，那么到达路由器之前不能转发，首先浪费了L/R s，这时全部到达了，然后转发出去，一共花费了2L/R。（没有考虑线路长度）</p>
<p>而如果数据一旦到达路由器就转发而不用等到全部到达，只需要L/R的时间。</p>
<p>现在计算发送三个分组，从源发送第一个分组到达目的地接收到全部三个分组的时间：<br>在L/R，第一个分组被转发出去，这时源也开始发出第二个分组，2L/R，第一个已经被路由器转发完毕，目的端收到，路由器开始接收第三个分组，源开始发送第三个分组，3L/R，路由器接收第三个分组完成，第二个分组已经送出去被目的接收到，源端发送完毕，4L/R第三个分组完全传送出去，目的端接收到第三个分组。一共4L/R时间。</p>
<p>考虑N条速率均为R的链路（所以一共有N-1个路由器），发送一个分组所需时间是$t=N*\frac{L}{R}$。</p>
<p>如果像上面一样分组发送：</p>
<p>一个长度L的包一次发出去，时间是$t=N*\frac{L}{R}$，如果分成c组，时间为：$t`=(c+N-1)*\frac{L}{c*R}$！！</p>
]]></content>
      
        <categories>
            
            <category> 计算机网络 </category>
            
            <category> 大三的课 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络课 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[网络编程一：UDP,CMD,TCP,WebServer]]></title>
      <url>/2017/11/15/%E7%AE%80%E5%8D%95udp%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0-java/</url>
      <content type="html"><![CDATA[<h1 id="UDP-CMD"><a href="#UDP-CMD" class="headerlink" title="UDP CMD"></a>UDP CMD</h1><p>今天写webserver的时候发现需要用到以前写的一些程序的知识。所以觉得最好总结一下。</p>
<p>woaibianyi,bianyibangwojiejueledaiamdewenti.xieixeni.</p>
<p>感觉像是…识别不出\n…行吧，myplace myrule，//必须以;结尾！</p>
<h2 id="UDP介绍"><a href="#UDP介绍" class="headerlink" title="UDP介绍"></a>UDP介绍</h2><p>UDP通信使用两个类：<strong>DatagramPacket</strong>与<strong>DatagramSocket</strong>。前者是对UDP包的一个封装，后者是完成两端之间的交流。<br>在UDP里面Server与Client地位同等，彼此没有区分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">DatagramPacket packet=<span class="keyword">new</span> DatagramPacket(buff,buff.length,addr,port);<span class="comment">//发送包;</span></div><div class="line">DatagramPacket packet=<span class="keyword">new</span> DatagramPacket(buff,buff.length);<span class="comment">//接收包;</span></div><div class="line">DatagramSocket socket=<span class="keyword">new</span> DatagramSocket(port);<span class="comment">//指定端口号的socket;</span></div><div class="line">DatagramSocket socket=<span class="keyword">new</span> DatagramSocket();<span class="comment">//自动分配一个可用端口号;</span></div></pre></td></tr></table></figure>
<p>不得不说端口号与进程、socket之间的关系：端口号与进程毛关系没有。一个udp socket只能绑一个端口，一个port只能被一个socket绑。这个原因是在多路复用与多路分解讲到的。否则不知道pck究竟该给谁。</p>
<h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><h3 id="Server的ip获取；获取client的ip与port"><a href="#Server的ip获取；获取client的ip与port" class="headerlink" title="Server的ip获取；获取client的ip与port"></a>Server的ip获取；获取client的ip与port</h3><p><strong>Server端获取Server的ip与port</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">InetAddress.getLocalHost();<span class="comment">//ip获取;</span></div><div class="line">socket.getLocalPort();<span class="comment">//socket绑定的port获取;</span></div></pre></td></tr></table></figure>
<p><strong>Server端获取Client的ip与port</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//pck是从client接收到的包;</span></div><div class="line">pck.getAddress();<span class="comment">//;</span></div><div class="line">pck.getPort();<span class="comment">//;</span></div></pre></td></tr></table></figure>
<h3 id="时间获取"><a href="#时间获取" class="headerlink" title="时间获取"></a>时间获取</h3><ol>
<li>定义：<code>Calendar cal;</code></li>
<li>每次获取时间前都应执行：<code>cal= Calendar.getInstance();</code></li>
<li>获取常用的数据：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> year = cal.get(Calendar.YEAR);</div><div class="line"><span class="keyword">int</span> month=cal.get(Calendar.MONTH)+<span class="number">1</span>;</div><div class="line"><span class="keyword">int</span> day=cal.get(Calendar.DATE);</div><div class="line"><span class="keyword">int</span> week = cal.get(Calendar.DAY_OF_WEEK)-<span class="number">1</span>;</div><div class="line"><span class="keyword">int</span> hour=cal.get(Calendar.HOUR_OF_DAY);</div><div class="line"><span class="keyword">int</span> minute=cal.get(Calendar.MINUTE);</div><div class="line"><span class="keyword">int</span> second=cal.get(Calendar.SECOND);</div></pre></td></tr></table></figure>
<h3 id="使用其他类访问同一可视化界面"><a href="#使用其他类访问同一可视化界面" class="headerlink" title="使用其他类访问同一可视化界面"></a>使用其他类访问同一可视化界面</h3><p>以本程序为例，在主类中创建了一个可视化界面，希望在Time类访问可视化界面的一个label：</p>
<p><strong>在Time类创建一个label，使用主类的label初始化这个label</strong>。</p>
<h3 id="主方法：监听client请求"><a href="#主方法：监听client请求" class="headerlink" title="主方法：监听client请求"></a>主方法：监听client请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">DatagramSocket socket=<span class="keyword">new</span> DatagramSocket(<span class="number">4444</span>);<span class="comment">//固定的一个socket，绑定固定的port;</span></div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">    <span class="keyword">byte</span>[]buff=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">256</span>];<span class="comment">//输入缓冲区;</span></div><div class="line">    DatagramPacket pck=<span class="keyword">new</span> DatagramPacket(buff,buff.length);<span class="comment">//每次都新建一个包，否则会产生缓冲区不干净发送数据错误的问题;</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        server.log.setText(server.log.getText()+<span class="string">"\ni'm at "</span>+InetAddress.getLocalHost()+<span class="string">" "</span>+socket.getLocalPort()+<span class="string">" and listenning~\n"</span>);</div><div class="line">        server.log.setCaretPosition(server.log.getText().length());<span class="comment">//设置目前的光标位置，在可视化界面具体讲;</span></div><div class="line">        socket.receive(pck);<span class="comment">//接收数据包：阻塞方法;</span></div><div class="line">        server.log.setText(server.log.getText()+<span class="string">"i've get a request from "</span>+pck.getAddress()+<span class="string">" "</span>+pck.getPort()+<span class="string">" "</span>+<span class="keyword">new</span> String(pck.getData())+<span class="string">"\n"</span>);<span class="comment">//;</span></div><div class="line">        server.log.setCaretPosition(server.log.getText().length());</div><div class="line">        Server newserver=<span class="keyword">new</span> Server(<span class="keyword">new</span> String(pck.getData()),pck,server);<span class="comment">//新开一个线程，专门负责与这个client的通信;</span></div><div class="line">        <span class="keyword">new</span> Thread(newserver).start();<span class="comment">//新线程开始运行;</span></div><div class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            <span class="comment">// TODO Auto-generated catch block;</span></div><div class="line">         e.printStackTrace();</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>pck.getData();</code>:获取pck包的data信息;<br><code>pck.getAddress();</code>获取包的源地址<br><code>pck.getPort();</code>获取包的源端口</p>
<p><code>InetAddress.getLocalHost();</code>:获取本地ip，可能抛出异常，需要处理<br><code>socket.getLocalPort();</code>获取socket绑定的端口号</p>
<p><code>socket.receive(pck);</code>:等待接收一个包<br><code>socket.send(pck);</code>:发送一个包</p>
<h3 id="String与Unix时间戳之间的转换"><a href="#String与Unix时间戳之间的转换" class="headerlink" title="String与Unix时间戳之间的转换"></a>String与Unix时间戳之间的转换</h3><p>format函数之中是一个Date对象，这个Date对象由一个long构造：list[i]是File类型。也许会说“过时”，没关系，这一整句代码打上去就不会提示了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String dates=<span class="keyword">new</span> java.text.SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(<span class="keyword">new</span> java.util.Date(list[i].lastModified()));</div></pre></td></tr></table></figure>
<p>多说一句SimpleDateFormat：</p>
<p> G 年代标志符<br>  y 年<br>  M 月<br>  d 日<br>  h 时 在上午或下午 (1~12)<br>  H 时 在一天中 (0~23)<br>  m 分<br>  s 秒<br>  S 毫秒<br>  E 星期<br>  D 一年中的第几天<br>  F 一月中第几个星期几<br>  w 一年中第几个星期<br>  W 一月中第几个星期<br>  a 上午 / 下午 标记符<br>  k 时 在一天中 (1~24)<br>  K 时 在上午或下午 (0~11)<br>  z 时区</p>
<p>可以说是十分实用了。</p>
<p>具体信息可以访问<a href="http://blog.csdn.net/gubaohua/article/details/575488" target="_blank" rel="external">这里：SimpleDateFormat使用详解</a></p>
<h3 id="获取本地文件信息"><a href="#获取本地文件信息" class="headerlink" title="获取本地文件信息"></a>获取本地文件信息</h3><p><strong>注意</strong>：没有解决的一个问题：包最后一定会用ASCII为0的char填充满255个，注意！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">File f=<span class="keyword">new</span> File(dirpath);</div><div class="line">File[] list=<span class="keyword">null</span>;</div><div class="line"><span class="keyword">if</span>(f.isDirectory())&#123;</div><div class="line">    list=f.listFiles();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取文件名信息：<code>list[0].getName();</code><br>是否文件？是否目录？:<code>list[0].isFile();list[0].isDirectory();</code><br>还有一系列方法：自己发现吧！</p>
<p>Server的java代码<a href="http://note.youdao.com/noteshare?id=de6b0e25562da7949d1b1b8a51ae865c&amp;sub=E0E99B97DC7A4AAEB00CC82204E767BC" target="_blank" rel="external">看这里</a></p>
<h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><h3 id="client的ip获取"><a href="#client的ip获取" class="headerlink" title="client的ip获取"></a>client的ip获取</h3><p><code>InetAddress.getLocalHost();</code>与Server差不多</p>
<h3 id="设置最大时延"><a href="#设置最大时延" class="headerlink" title="设置最大时延"></a>设置最大时延</h3><p>送出一个包：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">DatagramSocket socket=<span class="keyword">new</span> DatagramSocket();</div><div class="line">socket.setSoTimeout(<span class="number">10000</span>);</div><div class="line">socket.send(pck);</div></pre></td></tr></table></figure>
<p>新开一个线程中：等待接收一旦超时触发异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    socket.receive(pck);</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span>(SocketTimeoutException e)&#123;</div><div class="line">    e.printStackTrace();</div><div class="line">    ori=ori+<span class="string">"timeout!:"</span>+socket.getInetAddress()+<span class="string">" for "</span>+pck.getData().toString()+<span class="string">" has no response . try again!\n"</span>;</div><div class="line">    clientthis.tf.setText(ori);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用String设置指定IP"><a href="#使用String设置指定IP" class="headerlink" title="使用String设置指定IP"></a>使用String设置指定IP</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    <span class="keyword">int</span>[]ipaddr=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</div><div class="line">    String[] ipsplit=<span class="keyword">new</span> String[<span class="number">4</span>];</div><div class="line">    data=data.replace(<span class="string">'.'</span>, <span class="string">'-'</span>);</div><div class="line">    ipsplit=data.split(<span class="string">"-"</span>);<span class="comment">//这两步是当时不懂正则，使的一个小手段;</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(ipsplit[i]!=<span class="keyword">null</span> &amp;&amp; ipsplit[i].isEmpty())&#123;</div><div class="line">        cmd.setText(cmd.getText()+<span class="string">"format of ip addr wrong!split by .\n&gt;"</span>);</div><div class="line">        rows++;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    ipaddr[i]=Integer.parseInt(ipsplit[i]);</div><div class="line">    &#125;<span class="comment">//前面是为了验证给定的string是符合要求的int.int.int.int形式;</span></div><div class="line">    <span class="comment">//得到正确的ip;</span></div><div class="line">   <span class="comment">//转化为byte流;</span></div><div class="line">    <span class="keyword">byte</span>[]byteaddr=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</div><div class="line">    byteaddr[<span class="number">0</span>]=(<span class="keyword">byte</span>)ipaddr[<span class="number">0</span>];</div><div class="line">    byteaddr[<span class="number">1</span>]=(<span class="keyword">byte</span>)ipaddr[<span class="number">1</span>];</div><div class="line">    byteaddr[<span class="number">2</span>]=(<span class="keyword">byte</span>)ipaddr[<span class="number">2</span>];</div><div class="line">    byteaddr[<span class="number">3</span>]=(<span class="keyword">byte</span>)ipaddr[<span class="number">3</span>];</div><div class="line">    <span class="comment">//设置新ip;</span></div><div class="line">    addr=InetAddress.getByAddress(byteaddr);</div><div class="line">    System.out.println(data);</div><div class="line">    cmd.setText(cmd.getText()+<span class="string">"&gt;"</span>);<span class="comment">//先忽略就好;</span></div><div class="line">&#125;<span class="keyword">catch</span>(NumberFormatException e)&#123;<span class="comment">//根本不符合格式;</span></div><div class="line">    e.printStackTrace();</div><div class="line">    cmd.setText(cmd.getText()+<span class="string">" wrong:"</span>+command.substring(<span class="number">7</span>)+<span class="string">"wrong format of ip addr! split by . and only numbers are accept\n&gt;"</span>);</div><div class="line">    rows++;</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span>(UnknownHostException he)&#123;<span class="comment">//;</span></div><div class="line">    he.printStackTrace();</div><div class="line">    cmd.setText(cmd.getText()+<span class="string">"unknown host\n&gt;"</span>);</div><div class="line">    rows++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>client代码<a href="http://note.youdao.com/noteshare?id=45d994163c92b945960698ea27100a1b&amp;sub=3AE87C2D6AF44F2BA331DB9C7904A210" target="_blank" rel="external">看这里</a></p>
<h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><p>可视化部分也在上面的client代码里面。</p>
<h1 id="TCP-WebServer"><a href="#TCP-WebServer" class="headerlink" title="TCP WebServer"></a>TCP WebServer</h1><p>这是第二次作业，使用TCP，利用http1.1，实现一个可以与浏览器进行交互的小型的WebServer。</p>
<p>附加：tcp部分编码设置</p>
<p>String code=”utf-8”;<br>        try {<br>            InputStream instream= new java.io.FileInputStream(file);<br>            byte[] b = new byte[3];<br>            instream.read(b);<br>            instream.close();<br>            if (b[0] == -17 &amp;&amp; b[1] == -69 &amp;&amp; b[2] == -65)code=”utf-8”;<br>            else code=”GBK”;<br>        } catch (IOException e) {<br>            // TODO Auto-generated catch block<br>            e.printStackTrace();<br>        }<br>        return code;</p>
]]></content>
      
        <categories>
            
            <category> 计算机网络 </category>
            
            <category> 大三的课 </category>
            
            <category> 作业 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络课 </tag>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OS-各实验初讲]]></title>
      <url>/2017/11/14/OS/%E5%AE%9E%E9%AA%8C%E4%B8%B2%E8%AE%B2/</url>
      <content type="html"><![CDATA[<h1 id="Lab3：User-Environment"><a href="#Lab3：User-Environment" class="headerlink" title="Lab3：User Environment"></a>Lab3：User Environment</h1><h2 id="Pre：实验准备知识"><a href="#Pre：实验准备知识" class="headerlink" title="Pre：实验准备知识"></a>Pre：实验准备知识</h2><h3 id="GCC内联汇编"><a href="#GCC内联汇编" class="headerlink" title="GCC内联汇编"></a>GCC内联汇编</h3><h3 id="特权降级"><a href="#特权降级" class="headerlink" title="特权降级"></a>特权降级</h3><h4 id="基础知识准备"><a href="#基础知识准备" class="headerlink" title="基础知识准备"></a>基础知识准备</h4><p>切换到保护模式之后就会有不同的特权等级，这时默认在最高的特权等级上。这个时候为内核建立了页表结构，接下来将会跳转到用户程序。进行跳转的时候，应该注意：不可以再留着这个高级的运行权限了，因此需要进行特权级的降级。</p>
<p>系统在以上电时，各个资源管理都还没有建立，这个时候处于特权管理模式，在特权模式建立完毕所有的资源映射之后，再降级到通用模式，运行。</p>
<p>因此，一上电运行的指令一旦被不安全的程序接管，将不会降级，保护措施将形同虚设。因此，在智能手机等终端上都有一个叫做trustdo(?)的硬件，它是一个加密的模块，这个模块是系统上电之后运行的第一段代码，作用是验证将要运行的这段代码是不是被授权的，数字签名是否通过，若通过才会运行。trustdo会被做到CPU的芯片中，保证了即使上电后处于特权模式的代码是安全可靠的。</p>
<hr>
<p><strong>iret</strong>：系统指令，从中断中返回。<br><strong>ret</strong>：从函数中返回<br><strong>retf</strong>：与ret基本一样，从函数中返回。（弹出栈，拿出返回地址（就是下一条语句）返回值，丢掉压栈参数）</p>
<p>中断是一个硬件的事件，中断返回与函数返回不同。当一个中断来了，不管你当时在干嘛，就乖乖地保存一下现场去响应中断。这个<strong>保存现场</strong>，包括了硬件将会自动帮你保存的一些现场，比如CS、SS、Flag等等，这些是自动存下的，iret的作用就是自动地将这些东西都弹出。但是这些现场保存并不够，通用寄存器是不会帮你保存的。</p>
<p>ret、iret等等在汇编之中可以随意调用，并不需要其他约束。如果当你在汇编中不是函数（中断）的里面调用了这些，它会干些什么呢？<br>他会把自己认为的自己保存进去的那些东西弹出来，一个是返回地址给PC，一个是返回值给保存返回值的东西。即使没有调用函数，ret的行为也是固定的：<strong>从栈顶弹出两个值，一个给PC，一个给存储返回值的东西</strong>，iret的行为也是固定的，就是从栈顶弹出东西给那些变量。<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-14/87170051.jpg" alt=""><br>这就是保护现场之后的栈。<br>ret是弹出到eip，retf弹出到CS，iret弹出到CS（代码段）、EFLAGS，根据是否改变特权等级，iret会连下面的SS以及esp一起弹出来。</p>
<p>这样，如果一个程序在栈中事先在栈中存了一些数据，然后调用了iret，iret不管栈中究竟是什么，就会弹出5（3）个元素，给对应的寄存器。ret和retf也类似。因此，在汇编中ret们与高级语言的return们的作用不同，汇编中的ret们只是<strong>提供了一个批量修改寄存器的方法</strong>。</p>
<p>系统中有两种中断。中断可能在任意时间发生。在用户模式下与在特权模式下中断发生后系统的动作是不相同的。</p>
<p>在用户模式下，系统会保存这些东西：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-14/4474675.jpg" alt=""><br>还记得在“内存管理”的lab里面讲过的<strong>段选择子</strong>，其中有两个bit标识自己处在什么特权模式下的特权位。这里面有两个段选择子，一个是栈的，一个是代码段的，由于在用户模式下，可以看到CS代码段选择子与SS栈选择子的特权位RPL都是3。</p>
<p>在特权模式下，一旦发生中断：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-14/84089468.jpg" alt=""><br>这时保存的东西比较少。</p>
<p>无论在哪种模式下一旦调用iret，就把这些东西（其实不一定是这些东西，只是对应栈顶的几个数据）弹出去给对应的寄存器。</p>
<h3 id="正题：特权降级"><a href="#正题：特权降级" class="headerlink" title="正题：特权降级"></a>正题：特权降级</h3><p>考虑做完lab2，系统在特权级是0的模式下，这是需要现将自己降级成为特权3的模式，再去运行用户程序。怎么降？</p>
<p>要伪造一个场景：刚刚一个用户程序产生了一个中断所以我升级了，现在我要中断返回。于是我去伪造了一个栈，在栈里头存上了iret希望的那5个数据，每一个是32位。然后调用iret，这些就会从栈中弹出来到达对应的寄存器，然后我就回到了用户模式，那两个段选择子的特权级值就被改为了3。<br>这里需要注意的是，系统原来使用的特权级是0的栈，iret之后这个栈空掉了，但是系统不再使用这个栈，而是重新为用户态开避了一个新的栈，这个栈不再是以前的那个栈了，这个栈放在用户空间的数据段里，它的权限也是3。</p>
<blockquote>
<p>为什么要这样设计呢？在特权模式下，系统并不想和特权级更低的用户态共用一个特权级更高的栈。另一个方面从安全考虑，为了防止用户态随意弹出数据随意插入数据破坏内核运行。</p>
</blockquote>
<p>从特权模式到达用户模式，新创建了一个栈给用户程序使用，这是在刚上电的时候，还没有用户程序运行。用户程序运行过程中可能会有系统调用回到特权模式下，这是将会使用前面提到的系统用的那个栈，系统调用完成之后，不会再为用户程序创建新的栈了，一是占空间，一是以前的运行态不能就这样丢掉。就还让它回到自己原来的栈。</p>
<h2 id="特权级提升"><a href="#特权级提升" class="headerlink" title="特权级提升"></a>特权级提升</h2><p>中断、异常、系统调用：我需要更高特权的东西帮帮我。</p>
<p>在80386中，系统调用就是一个中断。异常是需要紧急处理的中断。</p>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>在32位机器上的中断是一个很复杂的机制，因为那时保护模式已经建立了起来，整个运行在虚拟地址空间上。所以当中段发生的时候，系统使用<strong>中断描述符表</strong>，写着自己所有的中断号。<br>中断描述符寄存器（IDTR）中存的就是中断描述符表（IDT）在内存中的位置以及大小。表按照中断号排序，每一个中断描述符在80386中被叫做一个门，<strong>中断门</strong>（中断），<strong>陷阱门</strong>（异常）。会根z中断发生的编号从表中取出对应的描述符（门），<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-15/43120327.jpg" alt=""><br>取回的描述符是这样的：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-15/96785647.jpg" alt=""><br>segment selector与offset用来描述在段机制下自己的中断响应函数的位置。segment selector负责在GDT里面找到对应的段，offset负责找对应的偏移量。找到函数之后，保存现场并执行响应函数。</p>
<p>在终端发生的时候，系统将会看一下产生中断的程序的特权级，决定应该怎样保护现场。如果在特权状态，不用换栈，只需要保存更少的东西，而处于用户状态下的程序在执行完中断响应函数之后还要从（？）退回到自己的用户栈，保存了更多的东西。</p>
<h3 id="正题：特权级提升"><a href="#正题：特权级提升" class="headerlink" title="正题：特权级提升"></a>正题：特权级提升</h3><p>从特权模式3切换到特权模式0，实际上就是响应一个中断，这就是上面图中的trap。</p>
<p>对于用户程序，os并不信任。当trap发生时，当前用户程序的运行状态会被存入到<strong>内核栈</strong>中，而用户栈并没有变化。这也是中断与普通函数调用的不同。<br>现在已经进入了特权模式，如果不作任何操作，只是调用一个iret，前面讲到的CS，SS特权级3又会被写入到寄存器里面，就又回到了用户态。为了能留在特权模式下，对栈进行伪造，假装在进入终端之前就是一个特权模式：也就是把上面提到的用户态发生中断的栈信息修改成特权模式发生中断的栈信息。这时iret，就可以留在特权模式下。</p>
<p>但是：在伪造的时候，SS被扔掉了。怎么回去呢？80386提供了一个<strong>TSS任务状态段</strong>，它几乎可以存下CPU上所有的寄存器的不止一份拷贝。TSS每个进程一个，会存下一个进程在切换特权状态的时候原特权状态下的SS的值。系统将会自己对TSS进行维护，以确保切换模式时栈的跳转。</p>
<p>TSS存在于哪里呢？在GDT里面有一个TSS的描述符：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-15/80552651.jpg" alt=""></p>
<p>80386中有4个特权模式，目前在虚拟化技术下只是用了3个。</p>
<p>有一个叫做TSR的寄存器，存着selector、base addr以及segment limit。便于直接找到TSS。</p>
<p>如果想要回到用户模式，进入trap，伪造一个从用户态过来的栈，iret即可。</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>用户程序可以通过系统调用访问内核服务，这个过程需要指定中断号，使用tarp或者特殊指令（SYSENTER/SYSEXIT）实现。</p>
<h2 id="关于这次实验"><a href="#关于这次实验" class="headerlink" title="关于这次实验"></a>关于这次实验</h2><p>这里的env就是课上讲的pcb。<br>父子进程的一个作用是父进程要为子进程收尸。</p>
<p>elf格式：linux下的可执行。<br>创建进程并执行elf：没有文件系统怎么办？<br>把指定的文件链接进目标文件，骗bootloader把程序也搬进内存。</p>
<p>-b binary path:-b帮我搬进来。binary这是个可执行程序。<br>然后重生成一个符号表。<br>把这个文件作为一个大数组缀到最后，然后直接使用这个数组。</p>
<p>编码的时候，这个数组还没有，链接的时候才有，怎么办？定义一个外部变量extern。<br>只需知道生成符号表的规则，然后按规则命名即可。</p>
<p>进来之后还只是一个大数组，还需要经过链接之后映射要对应的虚拟地址才能执行。</p>
<h1 id="Lab4-Preemptive-Multitasking"><a href="#Lab4-Preemptive-Multitasking" class="headerlink" title="Lab4-Preemptive Multitasking"></a>Lab4-Preemptive Multitasking</h1><p>lab3做完之后，当一个进程结束之后，就退出。在这个实验中，主要完成的是</p>
<p>本次实验主要是决定：在何时利用什么原则什么地方切换进程。<br>上下文怎么切换？其中一项：一定要把页表换掉，也就是把cr3中的页目录项换掉。之后，连接tlb也会失效，处理流水线，吧上一个进程的东西全部清理掉。</p>
<p>本实验大部分代码都已经写完了，主要是读代码。</p>
<p>如何实现更加有效的调度？更加频繁的调用schedule_yeid。</p>
<p>时钟中断的作用：打断正在执行的程序，调用sched_yield进行进程轮转</p>
<p>在本次实验中有一个时钟中断，你要做的就是在这个时钟中断的响应函数之中做一些事情，决定下一个进程怎么上去谁会上去（就是我们学习过的调度算法）</p>
<h2 id="多核处理器"><a href="#多核处理器" class="headerlink" title="多核处理器"></a>多核处理器</h2><p>一开始是因为没有在一个进程运行的时候调用另一个进程的机制，本实验中的多核只是实验的设计者希望我们体验一下在系统中有多个进程活动是一个什么样的状态，因此鼓励你去多弄几个核心。<br>只要是单核，其实每一个时刻只能有一个进程运行。</p>
<p>为什么会有多核处理器出现呢？在后摩尔时代，为了提升处理器的处理能力。</p>
<p>主核会在系统上电之后接管机器，他们的地位并不是平等的。</p>
<h3 id="现代处理器的休眠唤醒机制"><a href="#现代处理器的休眠唤醒机制" class="headerlink" title="现代处理器的休眠唤醒机制"></a>现代处理器的休眠唤醒机制</h3><p>现代处理器的模式一般有三种：active,idol,sleeping</p>
<p>CPU在关闭的时候，内存并不会关闭。休眠时，找到一个调度点，这时不调度了，存好有用的东西，然后cpu耗电量就会变得非常低。有一个cpu中的寄存器会标志自己刚刚是休眠了还是关机了。如果是休眠，那么内存里面所有的东西都还在，只需要调到该去的地方，然后进行一轮新的调度；如果不是休眠而是关机了，内存中的东西就被清空了，就是上电启动过程。</p>
<p>有时手机会坏掉，就是在锁屏（休眠）之后也会重新起动，这也就是cpu中的那个寄存器坏掉了。</p>
<p>那么，如果帮一个休眠的cpu准备好了它的休眠位以及内存，就可以让它认为它是一个刚刚休眠的cpu。</p>
<p>bsp是主核，在系统上电之后是只有主核启动，直到系统启动完之后，直到需要另外一个核心运行一个进程，bsp帮ap制造一个它刚刚在休眠的假象，然后唤醒它，这样这个ap就会认为自己是刚刚休眠的，然后继续执行。运行完之后，主核就会选择把这个核心给关掉，然后省电。</p>
]]></content>
      
        <categories>
            
            <category> OS </category>
            
            <category> MIT Lab </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[哈希]]></title>
      <url>/2017/11/12/%E5%93%88%E5%B8%8C/</url>
      <content type="html"><![CDATA[<hr>
<p>emmm…大二的时候DS只考了80，出来混的，总是要还的。</p>
<h2 id="不希望文件太多都小于512k，会占我的空间。"><a href="#不希望文件太多都小于512k，会占我的空间。" class="headerlink" title="不希望文件太多都小于512k，会占我的空间。"></a>不希望文件太多都小于512k，会占我的空间。</h2><h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><p>哈希其实没什么神秘的，不过是一群贪心的人的产物。</p>
<p>散列函数，将key转化为对应的value值得到索引。这个有诸如<strong>取模</strong>，<strong>ASCII平均</strong>，等等方法。橙皮书上有一种sfold，似乎性能会更好一些。</p>
<h2 id="开哈希"><a href="#开哈希" class="headerlink" title="开哈希"></a>开哈希</h2><p>开哈希类似于静态链表，每一个value对应一个链表，成为挂着的桶。</p>
<h2 id="闭哈希"><a href="#闭哈希" class="headerlink" title="闭哈希"></a>闭哈希</h2><p>闭哈希将node存储在给定的一个数组中。这个数组的下标将作为value的索引值，由于value可能重复，需要探查方式，有很多方式，比如线性探查与二次探查。</p>
<p>关于闭哈希的删除，其实不必真的每次都向前挪，而是增加一个“墓碑”，它代表这里没有数据可以被插入，但是又不是真的空因为需要继续向前探查。<br>当次数多了性能就会下降，一种解决方式是向前挪，另一种是重新散列。</p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[语言们的输出格式控制]]></title>
      <url>/2017/11/12/%E8%AF%AD%E8%A8%80%E4%BB%AC%E7%9A%84%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F%E6%8E%A7%E5%88%B6/</url>
      <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/leewiki/archive/2011/12/13/2286168.html" target="_blank" rel="external">待整理</a></p>
]]></content>
      
        <categories>
            
            <category> 语言 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 语言 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[编译原理——词法分析]]></title>
      <url>/2017/11/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>我有罪….我先是用学编译的时间逛了淘宝….然后又用学编译的时间逛了六维…..我有罪….\infty</p>
<blockquote>
<p>时间：1012cp3 3:15开始 词法分析器介绍</p>
<p>编译并不是一件轻松的事情，对于较大的系统，编译的速度并不理想，这也是为什么我们需要优化编译技术。</p>
</blockquote>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>词法单元（单词）</strong>：由一个词法单元名以及一个可选的属性值组成。名即是语法分析器的输入符号token。<br><strong>模式</strong>：一个词法单元的词素可能具有的形式。一个词素不能与两个或多个词法单元进行匹配（二义性）。<br><strong>词素</strong>：源程序中的字符序列，是程序中实际出现的字符串。</p>
<blockquote>
<p>在lex与yacc中，有时会有一个全局变量。他保存了当前词素（词法单元：关于这里，龙书里面的和wg写的不一样呢？）的属性值，这个属性值可以被记录在语法树上。</p>
</blockquote>
<h2 id="词法分析器要干些什么？"><a href="#词法分析器要干些什么？" class="headerlink" title="词法分析器要干些什么？"></a>词法分析器要干些什么？</h2><p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-12/6339247.jpg" alt=""></p>
<ol>
<li>读入源程序字符，生成词素，确定词法单元序列</li>
<li>与符号表进行交互</li>
<li>过滤掉源程序中的<strong>注释</strong>与<strong>空白</strong></li>
<li>将编译器生成的错误信息与位置联系</li>
<li>预处理：扫描阶段完成不需要生成词法单元的简单处理；词法分析阶段处理扫描阶段的输出并生成词法单元</li>
</ol>
<blockquote>
<p>跳过了一些东西</p>
</blockquote>
<h1 id="正则表达式（正规表达式、正规式）"><a href="#正则表达式（正规表达式、正规式）" class="headerlink" title="正则表达式（正规表达式、正规式）"></a>正则表达式（正规表达式、正规式）</h1><p>为什么需要正则表达式来描述字符串序列呢？<br>像在上下文无关文法中所描述的那样，因为字符们所组成的可能的字符串是<strong>无穷</strong>的。</p>
<p>单词是什么？单词的本质就是<strong>符号串的集合</strong>。正则表达式就是代替了自然语言对特定符号串集合的描述。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>符号表</strong>：符号的有穷集合<br><strong>符号串</strong>：字母表中符号构成的有穷序列。也成<strong>句子</strong>，<strong>字</strong>。<strong>|s|</strong>代表<strong>字符串s的长度</strong>，$\epsilon$是空字符串。<br><strong>语言</strong>：是一个给定符号表上的特定的符号串的集合。</p>
<p>比如：给定符号表{1,0}，有符号串01100010，一种语言是{0，1，00，11，000，111….}即串中只含一种字符的字符串集合。</p>
<p>特例：$\varnothing$是<strong>空语言</strong>。{$\epsilon$}是只含空串的语言。</p>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="符号串的运算"><a href="#符号串的运算" class="headerlink" title="符号串的运算"></a>符号串的运算</h3><p><strong>连接</strong>：x=hou y=se xy=house    s$\epsilon$=$\epsilon$s=s  (emmmm说好的不能这样写呢？)<br><strong>幂</strong>：$s^n=s^(n-1) * s^1$</p>
<h3 id="语言的运算"><a href="#语言的运算" class="headerlink" title="语言的运算"></a>语言的运算</h3><p>下表中运算符的优先级由低到高</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算</th>
<th style="text-align:center">定义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">并</td>
<td style="text-align:center">$L\cup M={ s \ s\in L 或 s\in M} $</td>
</tr>
<tr>
<td style="text-align:center">交</td>
<td style="text-align:center">$LM={ st \ s\in L 且 t\in M} $</td>
</tr>
<tr>
<td style="text-align:center">Kleen闭包</td>
<td style="text-align:center">$L^*=\cup_{i=0}^\infty L^i$</td>
</tr>
<tr>
<td style="text-align:center">正则闭包</td>
<td style="text-align:center">$L^*=\cup_{i=1}^\infty L^i$</td>
</tr>
</tbody>
</table>
<p>$$\color{red}{正则表达式&lt;-&gt;语言运算的简洁描述}$$</p>
<h2 id="正则表达式定义"><a href="#正则表达式定义" class="headerlink" title="正则表达式定义"></a>正则表达式定义</h2><p>字母表$\sum$上的正规式r的定义规则，以及r所表示语言L(r)定义：</p>
<ol>
<li>$\epsilon$是正规式，表示语言{$\epsilon$}</li>
<li>若$a\in \sum$则a是正规式，表示语言{a}</li>
<li>r , s是正规式，表示语言L(r)与L(s)，则：<ol>
<li>(r)|(s)是正规式，表示语言L(r)$\cup$L(s)</li>
<li>(r)(s)是正规式，表示语言L(r)L(s)</li>
<li>$(r)^*$是正规式，表示语言$(L(r))^*$</li>
<li>(r)是正规式，表示语言L(r)</li>
</ol>
</li>
</ol>
<p>第三条的四条，优先级从上到下依次升高。</p>
<blockquote>
<p>$(a|b)^*$={所有由a、b组成的符号串}</p>
</blockquote>
<p>正规式<strong>等价</strong>：r=s &lt;-&gt; L(r)=L(s)</p>
<p>正则运算的特性:<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-12/3363060.jpg" alt=""></p>
<p>可以像产生式那样，为正规式指定名字：</p>
<blockquote>
<p>num -&gt; r1<br>其实，上下文无关文法的描述能力包含了正则表达式的描述能力。所有可以被正则表达式描述的都可以被上下文无关文法描述，但是正则表达式并不能描述某些上下文无关文法可以描述的东西。<br>那么为什么需要正则表达式来实现词法分析器？</p>
<ol>
<li>简化编译器的设计：使每一阶段需要做的事情更加简单清晰</li>
<li>提高编译器的效率：使用专门的字符缓冲技术提高编译速度</li>
<li>增强编译器的可移植性：输入设备相关的特殊性被限制在词法阶段</li>
</ol>
</blockquote>
<p>下面举一个例子：</p>
<blockquote>
<p>无符号整数：<br>digit -&gt; 0|1|2|…|9<br>digits -&gt; digit digit*  其实也可以是$digit^+$<br>optional_fraction -&gt; .digits | $\epsilon$<br>optional_exponent -&gt; (E(+|-|$\epsilon$)digits)|$\epsilon<br>num -&gt; digits optional_fraction optional_exponent</p>
</blockquote>
<p><strong>符号简写：</strong></p>
<p><strong>+</strong>:一个或多个实例<br><strong>?</strong>:0或1个实例：$r?=r|\epsilon$$\rightarrow$$L(r)\cup {\epsilon}$<br><strong>[]字符集</strong>:[abc]=&gt;a|b|c、[a-z0-9]=&gt;a|b|..|z|0|1..|9</p>
<h2 id="非正规集"><a href="#非正规集" class="headerlink" title="非正规集"></a>非正规集</h2><p><strong>正规式无法描述的语言</strong>：{wcw|w是a、b组成的字符串}正规式无法描述平衡或嵌套的结构<br><strong>正规式只能表示</strong>：有限的重复、一个给定结构的无限重复</p>
<p>关于正规式的练习，参考<a href="http://blank" target="_blank" rel="external">第三章练习</a></p>
<h1 id="Lex"><a href="#Lex" class="headerlink" title="Lex"></a>Lex</h1><p>使用流程与yacc类似。</p>
<p>$\color{red}{ATTENTION!</p>
<p>在使用project wizard建立lex的时候你写的那个词法分析器的名字就是那个名字，</p>
<p>你最好别自己再修改，否则在VS里面运行不出来！！！}$</p>
<p>给的是字符流，出来的是单词流。</p>
<p>规则段放正则表达式与语义动作。</p>
<p>第四次作业词法分析器设计将会上传。<a href="http://blank" target="_blank" rel="external">click here to get</a></p>
<h1 id="有限自动机"><a href="#有限自动机" class="headerlink" title="有限自动机"></a>有限自动机</h1><p>有限自动机可以直接转换成程序。</p>
<h2 id="NFA"><a href="#NFA" class="headerlink" title="NFA"></a>NFA</h2><h1 id="从正则表达式到自动机"><a href="#从正则表达式到自动机" class="headerlink" title="从正则表达式到自动机"></a>从正则表达式到自动机</h1><p>从这之后，正是lex所做的事情。</p>
<p>在这一节里，将介绍两个过程：一个是正则表达式到NFA，另一个是NFA到DFA。之所以让NFA做一个过渡，是因为正则表达式直接到DFA的算法很复杂。本次更新掠过。</p>
<p>NFA与DFA的性能差别很大：NFA占用空间比较少，但是使用NFA进行词法分析需要在错误态停止，可能需要花费$O(2^n)$的时间复杂度；DFA占用空间很大（最坏情况下$O(2^n)$），但是使用它进行词法分析的时候接近线性时间。</p>
<h2 id="正则-gt-NFA"><a href="#正则-gt-NFA" class="headerlink" title="正则 -&gt; NFA"></a>正则 -&gt; NFA</h2><p>正则表达式构造NFA使用<strong>MacMaughton-Yamada-Thompson算法</strong>。简称<strong>Thompson算法</strong>。这个算法描述如下：</p>
<p><strong>基本规则：</strong></p>
<h2 id="自动机运转"><a href="#自动机运转" class="headerlink" title="自动机运转"></a>自动机运转</h2><blockquote>
<p>s $\leftarrow$ e -closure({s0});<br>c $\leftarrow$ nextchar;<br>while c $\neq$ eof do<br> s $\leftarrow$ e -closure(d(s,c));<br> c $\leftarrow$ nextchar;<br>end;<br>if S$\cap$F$\neq$ $\varnothing$ then return “yes”<br>         else return “no”</p>
</blockquote>
<hr>
<blockquote>
<p>s $\leftarrow$ s0;<br>c $\leftarrow$ nextchar;<br>while c $\neq$ eof do<br> s $\leftarrow$ d(s,c);<br> c $\leftarrow$ nextchar;<br>end;<br>if s is in F then return “yes”<br>            else return “no”</p>
</blockquote>
<p>前面提到了，NFA占空间更少，DFA识别字符串更快，贪心的人类啊希望能糅合这两者的优点。看前面的NFA代码，其实在第四行那句，实际上就是前面提到的构造DFA的过程。人们想到使用Cache。使用NFA，当NFA构造出DFA的一个状态时，就把这个状态构造的条件以及状态本身存到cache里面。当while进一个c的时候，首先看一看现今状态加上c到达的态是不是已经存在cache，如果存在里面，最耗时间的那一部分就不用运行了。cache的管理仍然是程序局限性原则。占用空间不会太大以期望达到折衷的效果。</p>
<p>如果要构造出一个Lax，需要将所有的正则表达式得到的NFA进行一个并操作（保留各自的终态以区分）。然后构造它的DFA。</p>
<p>值得注意的是，这样不能在一个终态停止，而是在错误态终止并退回到最近经过的那个终态（每经过一个终态，记录当前的<strong>输入指针</strong>以及<strong>匹配模式</strong>）。以防止找到前缀，产生错误。这种方法是<strong>最长前缀法</strong>，在前面已经提到过。</p>
<h1 id="DFA优化"><a href="#DFA优化" class="headerlink" title="DFA优化"></a>DFA优化</h1><p>DFA状态数其实不会太多的影响时间复杂度，当状态变少的时候，将会减少存储空间的消耗。</p>
<p><strong>区分：</strong>一个符号串可区分两个状态：这一个串<strong>从这两个状态出发</strong>在DFA上得到的结果一个是accept，一个是reject。在做区分的时候，其实可以看到：最终字符串得到的终态在不同集合，则他们是可区分的。</p>
<blockquote>
<p>Ex<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-9/60487283.jpg" alt=""><br>a不能区分状态A与B。而且还可以看到，以a开头的所有字符串都不可能区分A与B了。再进一步看到，a不可能区分任意两个，因为所有状态在经过a的状态迁移之后都到达了状态B。<br>同理，b不可能区分ACE，以b开头的都不能区分ACE。但是b却可以区分BD。<br>不要忘记，$\epsilon$可是可以区分的。而且他的区分应该被放在最前面，那是因为$\epsilon$区分了终态与其他状态。</p>
</blockquote>
<p>在区分的过程中发现了这样一个规律：如果对于串s，A状态与B状态经过了s都到达同一个状态C，那么以s做前缀的字符串都不可能区分A与B了。当所有字符串都不能区分A与B的时候，可以把A与B合并成同一个状态。但是对于无穷的字符串，怎么确定 “所有都不行” 呢？ 在前面，我们已经提出了一个解决方案——当前缀s不行的时候，所有的sx都不行了。但是，即使是有了这个规律，使用“不行”的这种方法解决问题仍会显得繁琐。</p>
<p>真正在执行的时候，实行的是<strong>分裂</strong>，这样，通过有顺序地枚举字符串，将能被区分开的状态分开。这样对于前面的<strong>不同集合</strong>的说法，也能更好地理解。</p>
<p><strong>算法描述：</strong>首先使用$\epsilon$区分终态与非终态，将它们分为两个集合。随后，像子集构造法那样，有顺序地枚举输入字符串，将那些经过状态迁移能到达终态（不同集合）的状态剔除出去组成一个新的集合（如果两者到达同一个集合，这两者是不能区分的，应该在同一个集合），对于那些含有多个元素的集合，如果经过一系列不同的状态迁移到达不同的集合，仍需要继续分开。直到不再产生新的集合。</p>
<blockquote>
<p>仍然使用上面的例子，进行分裂的过程：</p>
<ol>
<li>$\epsilon$ -&gt; {A,B,C,D}、{E}</li>
<li>a -&gt; {A,B,C,D}  ({B,B,B,B})-&gt;全部一样，以a打头的不用再试</li>
<li>b -&gt; {A,B,C}{D}  ({C,D,C,E})</li>
<li>b -&gt; {A,C}{B}{D}  ({C,C,D})  -&gt; 不同集合</li>
</ol>
<p>最终得到的最小DFA：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/65136532.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/4345780.jpg" alt=""></p>
</blockquote>
<p>最后使用新的状态进行迁移的时候，一定不会出现问题。</p>
<h1 id="补充：从自动机到正则表达式"><a href="#补充：从自动机到正则表达式" class="headerlink" title="补充：从自动机到正则表达式"></a>补充：从自动机到正则表达式</h1><p>可以从一个DFA或NFA得到对应的正则表达式。但是这种方式并不是总是简单的，他只是提供了一个模糊的思路，当一个DFA很复杂的时候，还是需要有聪明才智才行。<br>这里只是简单的给出这个方法，具体可查看<a href="http://note.youdao.com/noteshare?id=9fa52c6fcb1a6637fbdb36f669852abe&amp;sub=9A6AEF1D34C044E68D8BD1AD2057996E" target="_blank" rel="external">这个文件</a>。</p>
<p>为了使讨论更加简单，我们强制一个DFA/NFA应该有下列特性：</p>
<ol>
<li>初态可以到达任意其他状态，没有状态可以通过状态迁移到达初态</li>
<li>只有一个终态，终态不能通过状态迁移到达非终态</li>
<li>初态不能是终态</li>
<li>除了初态与终态，其他状态彼此相连</li>
</ol>
<p>这四个条件看起来很可怕，其实当我们引入了$\varnothing$并根据情况添加初态终态之后，很容易可以把一个DFA/NFA转为一个符合要求的有限自动机。</p>
<p>以一个例子来说明：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/17062978.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/80510309.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/99180281.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/86068172.jpg" alt=""></p>
<p>为了不让自己沾沾自喜，必须指出上面给出的例子很简单，看下面这个：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-10/70925658.jpg" alt=""></p>
<p>由于生成initstate的一个要求是，不能有进入initstate的箭头，好，像上面一样加一个init，加一个Ac，随即，在删除A的时候就会发现问题。这尼玛转来转去的究竟怎么写边上的正则表达式啊？！</p>
<h1 id="能不能与好不好"><a href="#能不能与好不好" class="headerlink" title="能不能与好不好"></a>能不能与好不好</h1><p>在龙书的第九章。</p>
<ol>
<li><p>流程可否更加简洁？ 正则 -&gt; DFA：本质上还是做子集构造法-吧正则的某些位置对应NFA里面状态，位置集对应NFA的状态集</p>
</li>
<li><p>优化结果？ 最小DFA</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 编译原理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[chap3-内存管理]]></title>
      <url>/2017/11/06/OS/chap3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="内存中的概念"><a href="#内存中的概念" class="headerlink" title="内存中的概念"></a>内存中的概念</h1><p><strong>地址空间</strong>：一个进程可用于寻址内存的一套地址集合。<br><strong>内存管理</strong>：逻辑地址与物理地址之间的映射<br><strong>内存管理的特性</strong>：</p>
<ol>
<li>高效：使得更多的地址可以被使用（其实都是骗–人–进程的）</li>
<li>合理：alloc、free、locate、protect</li>
<li>便利：？<br><strong>内存管理class</strong></li>
<li>简单机制：静态固定</li>
<li>复杂机制：交换、paging</li>
</ol>
<blockquote>
<p>为什么会有这种欺骗的行为存在呢？<br>程序员希望拥有一个又大又快又永久的存储器，希望他们的寻址方式是统一的；但是实际上，又快又大又永久的存储器目前还是不现实的。<br>现在我们有的是：</p>
<ul>
<li>cache：非常快，昂贵</li>
<li>内存：速度适中，价格适中</li>
<li>硬盘：慢，廉价</li>
</ul>
</blockquote>
<p>在计组课里面应该就学过一个各种存储器的速度金字塔。最快的寄存器甚至是按照字节来计算的存储设备。</p>
<p>于是提出问题：如何使用有限的高速存储设备以及较多的低速存储设备来提高的响应速度呢？</p>
<h2 id="内存管理的任务"><a href="#内存管理的任务" class="headerlink" title="内存管理的任务"></a>内存管理的任务</h2><ol>
<li>申请与撤回：资源管理</li>
<li>地址转换：映射管理</li>
<li>分享与保护</li>
<li>空间扩张：你本来不可能占4G的，你非说你占了4个G</li>
</ol>
<h3 id="动态重定位"><a href="#动态重定位" class="headerlink" title="动态重定位"></a>动态重定位</h3><blockquote>
<p>从接口中知道，CPU希望访问一个地址的时候，会给出对应的地址（上总线）以及对应的读写信号etc。</p>
<p>对程序员来说，每一个程序就是一方天地，并不想在程序里面去思考你os应该解决的存储问题，程序认为自己的地址都是从m开始，想访问哪里就访问哪里，但是os并不可以这样做。<br>就像在实验中提到的那样，程序的elf（exe）文件中会有自己的链接地址，这个地址表示程序假设自己被加载到内存的位置，os加载运行的时候需要进行<strong>重定位</strong>，对程序中相关的地址都经过变换。</p>
</blockquote>
<p>对于上述问题，使用两个寄存器来解决，一个是<strong>基址寄存器</strong>，一个是<strong>界限寄存器</strong>，它们在每一个CPU中都存在。基址寄存器存储当前进程的开始物理地址，界限寄存器中存储该程序长度。</p>
<p>当使用一个地址a的时候，首先判断a是否大于界限寄存器中存储的值，如果不是，再将a加上基址寄存器中的值，然后送到地址总线。这些动作都是CPU硬件完成的。</p>
<h2 id="monoprograming：单道程序处理"><a href="#monoprograming：单道程序处理" class="headerlink" title="monoprograming：单道程序处理"></a>monoprograming：单道程序处理</h2><h2 id="multiprogramming"><a href="#multiprogramming" class="headerlink" title="multiprogramming"></a>multiprogramming</h2><p>支持多个进程的os内存管理都需要做什么？</p>
<ol>
<li>申请空间、释放空间</li>
<li>地址转换、内存保护（several method）</li>
<li>CPU利用：MTF的表现</li>
<li>内存扩张：更加柔韧的内存管理</li>
</ol>
<p>使用partition来为每一个进程分配空间</p>
<hr>
<p><strong>动态分区分配</strong>：当程序被加载执行时，分配一个进程制定大小可变的分区，在此分区内地址连续<br>os需要维护所有进程的已分配数据结构以及空闲分区。<br>$$\color{red}{whats this}$$</p>
<h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><p>通常情况下内存是不够用的。仅仅Windows后台应用都会占据一些内存，更不用说开浏览器，开vs等等。为了处理这样的情况，需要，把某一些进程放到外存，为当前运行进程提供内存空间。</p>
<p><strong>交换</strong>：把一个完整的进程调入内存，使该进程运行一段时间，然后存回磁盘。<br>这里提到的交换还不是后面说到的页面置换。</p>
<p><strong>交换中的内存管理</strong>：</p>
<ol>
<li>数据结构与算法：如何描述内存的使用 ； 如何申请、free内存</li>
<li>函数执行：如何消除内存碎片</li>
<li>核心问题的方法？灵活性、稳定性、扩展性</li>
</ol>
<p>关于内存碎片：<br>每次移入内存都是固定的大小，但是有时会移出去，有时会移进来，最终可能会产生许多内存空洞。为了消除内存空洞，需要进行<strong>碎片整理（内存紧缩）</strong>，这个操作很花时间。</p>
<p><strong>碎片整理：紧缩</strong>：<br>什么时候移动？</p>
<p><strong>碎片整理：分区对换</strong>：<br>通过抢占并回收处于等待状态进程的分区，增大可用空间。</p>
<p>核心问题：<br>写程序肯定会经常new吧，这个new是动态分配的内存，只有在运行到这里的时候才会去帮你分配，这种空间是不可预知的，无法准确计算需要空间的最大值。于是在为没一个进程分配空间的时候都可以多分一点。<br>这种分法带来新的问题：<br>将进程换回外存的时候其实并不需要换那些没有有效数据的地址，这是一种浪费。</p>
<h3 id="交换的空闲内存管理"><a href="#交换的空闲内存管理" class="headerlink" title="交换的空闲内存管理"></a>交换的空闲内存管理</h3><h4 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h4><p>就像lab5中的bitmap一样，0代表没有占用，1代表占用。不同的是，这里一个bit代表可能是内存中的一个<strong>分配单元</strong>，可能是4byte，可能是其他。</p>
<p>但是使用位图的话，不利于分配连续的空间，因为需要查找连续的固定字节空间的时间可能比查找一个分配单元空闲多花更多时间。</p>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>这并不是lab2中使用的方法。</p>
<p>维护一个空闲内存段链表与已用内存段链表。在每一个节点标志其状态以及开始地址以及连续地址。</p>
<p>这种方式对上述问题友好。新的问题是如何进行节点的更新与回收，这需要节点的合并与删除、增加等操作<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/19805712.jpg" alt=""></p>
<p><strong>分区管理分配算法</strong>：</p>
<p>当进行内存申请的时候，希望能尽量避免做内存紧缩，这就需要更好的申请方式，而不是每次遇到剩余空间比自己更多的就决定要这个块。</p>
<ol>
<li>首次适配：时间性能好、但会容易导致内存碎片</li>
<li>下次适配：从上次分配的分区开始查找。时间性能好、空闲去分布均匀，较大的空闲分区不易保留</li>
<li>最佳适配：较大空间保留，碎片小而多</li>
<li>最坏适配：着更大的分配：较大分区不会被保留<blockquote>
<p>最佳适配与最坏适配都可以通过维护二级索引来实现更快的查找</p>
</blockquote>
</li>
<li>快速适配：链表的改变十分费劲。为常用大小的块提供专门的索引</li>
</ol>
<h3 id="总结：mono-multi-swap"><a href="#总结：mono-multi-swap" class="headerlink" title="总结：mono\multi\swap"></a>总结：mono\multi\swap</h3><ol>
<li>位图连续空闲空间寻找</li>
<li>链表的空洞</li>
<li>交换的缺点：<ol>
<li>内存碎片</li>
<li>内存的动态增长</li>
<li>如何利用小空间运行大进程？</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Mono</th>
<th style="text-align:center">MFP</th>
<th>Swapping</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Size of proc</td>
<td style="text-align:center">total mem</td>
<td style="text-align:center">partion size</td>
<td>total size of free mem</td>
</tr>
<tr>
<td style="text-align:center">Alloction</td>
<td style="text-align:center">static</td>
<td style="text-align:center">static</td>
<td>dynamic</td>
</tr>
<tr>
<td style="text-align:center">multi-programming</td>
<td style="text-align:center">unsupported</td>
<td style="text-align:center">supported</td>
<td>supported</td>
</tr>
<tr>
<td style="text-align:center">mem space</td>
<td style="text-align:center">continuous</td>
<td style="text-align:center">continuous</td>
<td>continuous</td>
</tr>
<tr>
<td style="text-align:center">mem growth</td>
<td style="text-align:center">unsupported</td>
<td style="text-align:center">un</td>
<td>supported</td>
</tr>
</tbody>
</table>
<p>除了上述的碎片整理，还有<strong>覆盖</strong>技术：（程序员控制</p>
<ol>
<li>划分功能区（ifelse）</li>
<li>确定模块之间的覆盖关系</li>
<li>执行之前预先加载并交换</li>
</ol>
<p>其实是很不好完成的，基础就不好完成，不好判断功能模块，要求的编程技巧太高。</p>
<p>但是，从覆盖技术引出了一个：虚拟内存</p>
<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><ol>
<li>进程的程序段、数据段、堆栈段的总和可以大于物理存储空间</li>
<li>进程不必完全装入内存</li>
<li>os定时将暂且不用的信息换出内存</li>
<li>os负责将换出去的换回来</li>
</ol>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><ol>
<li>页：描述进程逻辑空间的单元</li>
<li>页框：描述物理内存中对应的单元</li>
<li>页表：页与页框之间的映射</li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/6075684.jpg" alt=""></p>
<p>在标准的4KB页面中，位数分别是10-10-12</p>
<p>页转换在mmu中完成，CPU访问到的，在程序之中执行的都是虚拟地址。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/6791125.jpg" alt=""></p>
<p>还记得在计组实验中还被问到了1/0是干吗的，至今难忘。</p>
<p>可能会有是否越界的比较（在标准中不存在，这是因为数据都是正好的）</p>
<hr>
<p>为了考试…</p>
<p>虚拟地址（英语：Virtual address space）在電腦的专用术语中是指标识一个虚拟（非物理地址）的实体地址。虚拟地址这个术语常用在虚拟内存和虚拟网络地址当中。from <a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80" target="_blank" rel="external">wiki</a></p>
<p>在计算机科学中，物理地址（英语：physical address），也叫实地址（real address）、二进制地址（binary address），它是在地址总线上，以电子形式存在的，使得数据总线可以访问主存的某个特定存储单元的内存地址。from <a href="https://zh.wikipedia.org/wiki/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80" target="_blank" rel="external">wiki</a></p>
<p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如RAM）的使用也更有效率。from <a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98" target="_blank" rel="external">wiki</a></p>
<hr>
<h3 id="页表项结构"><a href="#页表项结构" class="headerlink" title="页表项结构"></a>页表项结构</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><strong>page number</strong>：逻辑空间中的页id，<br><strong>frame num</strong>：物理空间中页框的id<br><strong>p/a</strong>：页是不是在内存里面<br><strong>protected</strong>：r/w/e，记录页允许的访问<br><strong>modified</strong>：是不是被修改（脏位<br><strong>referenced</strong>：这个页有没有被使用<br><strong>disable caching</strong>：页面禁用高速缓存</p>
<blockquote>
<p>why 禁用高速缓存？<br>对于那些映射到<strong>设备寄存器</strong>而不是普通物理内存的页面来说，不希望在自己等待设备对自己刚发出去的指令做反应的时候自己的导向地址竟然是cache而不是外部接口。</p>
</blockquote>
<p>in ppt:</p>
<table>
<thead>
<tr>
<th style="text-align:center">page num</th>
<th>p/a</th>
<th>frame num</th>
<th>protected</th>
<th>disable caching</th>
<th>referenced</th>
<th>modified</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h4 id="Design-issue"><a href="#Design-issue" class="headerlink" title="Design issue"></a>Design issue</h4><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/52513606.jpg" alt=""></p>
<h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>10-10-12</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/10468357.jpg" alt=""></p>
<p>除了修改位，每集页表项都是一样的。在非底层页表中，取值为0</p>
<p>其实还可以更多级。</p>
<h3 id="加速分页过程：TLB"><a href="#加速分页过程：TLB" class="headerlink" title="加速分页过程：TLB"></a>加速分页过程：TLB</h3><p>快表：一个将虚拟地址直接映射到物理地址的小型硬件设备，通常在MMU中，其中的项基本不超过64个。</p>
<p>将虚拟地址放在MMU中进行转换时，首先查快表：将该页面号与TLB中所有项同时（并行）进行匹配，如果命中，而且不违反保护位，页框号可以直接从TLB拿出，不必再进行内存访问（访问存储有页表项的内存），如果保护位不允许，就会发生一个页面访问错误。</p>
<p>如果不命中MMU就从内存中找页表项，并将最终找到的页号与页框号等拿出，淘汰tlb中某一个项并添加新来的项。</p>
<p>当从tlb中淘汰值的时候，记得将tlb中存储的修改位换到页面。</p>
<p>tlb表项（示例）</p>
<table>
<thead>
<tr>
<th style="text-align:center">有效位</th>
<th style="text-align:center">虚拟页面号</th>
<th style="text-align:center">修改位</th>
<th style="text-align:center">保护位</th>
<th style="text-align:center">页框号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">123</td>
<td style="text-align:center">1</td>
<td style="text-align:center">RW</td>
<td style="text-align:center">31</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">87</td>
<td style="text-align:center">0</td>
<td style="text-align:center">RX</td>
<td style="text-align:center">87</td>
</tr>
</tbody>
</table>
<p>…</p>
<p>既然TLB这么厉害，为什么不搞一个很大很大的TLB呢。<br>TLB属于高速设备，功耗非常大。</p>
<h3 id="加速分页过程：软件TLB"><a href="#加速分页过程：软件TLB" class="headerlink" title="加速分页过程：软件TLB"></a>加速分页过程：软件TLB</h3><p>当tlb失效的时候，mmu将会告诉os，让os找到要找的页面，从tlb删除一个页面，把这个页加上去。<br>必须在有限的指令内完成，因为tlb失效更加频繁。</p>
<p>但是，当tlb更大一些，这种机制就会变得很有效。这样做的好处是得到一个简单的mmu，从而为CPU其他性能改善提供了空间。</p>
<p>os可以“直觉”那些页面要被使用，然后预先加载到tlb。</p>
<p>《？》<br>在内存固定位置维护大的tlb表项的软件高速缓存。首先检查这个缓存，os可以实质性地减少失效。</p>
<p><strong>软失效</strong>：页面在内存中但是映射不在tlb。<br><strong>硬失效</strong>：页面本身不再内存（当然也不在tlb<strong>so为什么是这样</strong>）</p>
<h3 id="针对大内存：反置页表"><a href="#针对大内存：反置页表" class="headerlink" title="针对大内存：反置页表"></a>针对大内存：反置页表</h3><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/42494861.jpg" alt=""></p>
<p>为什么会出现反置页表？<br><a href="http://kejiao.cntv.cn/20110905/100155.shtml" target="_blank" rel="external">在64位系统下内存</a><br>64位系统，如果仍然保持一个页是4K，那么一共需要有$2^52$个页，只是存储这些页就花费几百G的空间，显然是不合理的。</p>
<p>而目前面临的状态是实际的内存很小，于是可以为每一个页框记录一个页表项。这样对于4K的页以及1G的ram只需要$2^18$个页表项即可。<br>页表项中记录哪一个(进程,虚拟页面)对应于该页框。<br>虽然节省空间，但是不足也是很明显的：<br>将虚拟地址转换为物理地址变得困难</p>
<p>可以使用tlb。但是当tlb失效的时候就很难。<br><strong>基于hash</strong>：把虚拟页号与进程号作为输入，得到的散列值来寻找。</p>
<p><strong>hahs冲突</strong></p>
<p><strong>虚拟存储的基本特征</strong>：</p>
<ol>
<li>不连续（$\color{red}{啥叫虚拟地址空间使用非连续？是说各个区分开吗}）</li>
<li>大用户空间：提供给用户的虚拟地址空间可以大于实际的物理内存</li>
<li>部分交换：虚拟存储只对部分虚拟地址进行调入调出。（不会像交换一样一下一个进程）</li>
</ol>
<p><strong>虚拟页式存储的外存管理</strong>：</p>
<ol>
<li>在哪里保存没有被映射的页？<ol>
<li>需要可以方便的找到在外存中的页面内容</li>
<li>交换空间（磁盘或文件）：采用特殊格式保存没有被映射的页面</li>
</ol>
</li>
<li>虚拟页式存储中的外存选择<ol>
<li>代码段：可执行二进制文件</li>
<li>动态加载的共享式程序段</li>
<li>其他段：交换空间</li>
</ol>
</li>
</ol>
<p><strong>虚拟页式存储的性能</strong>：有效存储访问时间</p>
<p>EAT=访存时间*(1-p)+缺页异常处理时间*缺页率p</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/82455336.jpg" alt=""></p>
<h2 id="pagingsys的工作流程"><a href="#pagingsys的工作流程" class="headerlink" title="pagingsys的工作流程"></a>pagingsys的工作流程</h2><ol>
<li>全局pgtable初始化</li>
<li>创建进程</li>
<li>获取首指令<ol>
<li>pgfault</li>
<li>加载页</li>
<li>更新pgtable</li>
<li>更新tlb</li>
</ol>
</li>
<li>页替换<ol>
<li>pgfault</li>
<li>选择一个页，写回磁盘</li>
<li>把新页换到这里</li>
<li>更新tlb</li>
</ol>
</li>
</ol>
<h2 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h2><ol>
<li>如果内存还有剩余页，分配；把希望访问的页从disk装到这个物理空间，把这个页对应页表的a/p置为1，物理地址映射到新分配的物理地址，重新执行引起缺页中断的指令</li>
<li>如果内存没有剩余的页面，依据页面置换算法选择一个将会被替换的物理页，如果这个物理页的值被修改过，把内存中的值写回外存，把对应逻辑页的a/p置为0，把希望访问的物理页装到这个空间，修改物理页对应的逻辑页面的指示物理页地址以及存在位，重新执行却页指令。</li>
</ol>
<blockquote>
<p>我现在认为，前面提到的挂起状态与现在说的“为了腾内存空间而将一些进程存储的东西先存到外存”是不一样的。<br>挂起的意思应该是pcb都被移动到了外存，根本无法找到这个进程的运行情况，地址空间等；但是这里仅仅是为了节省内存空间，将某些页换到了外存，该进程还是可以继续运行的。只是在需要用这些页的时候可能会引发缺页中断。<br>挂起存在的理由不仅仅是为了节省内存，还有一点是为了更有效的调度，因为所有调度算法考虑的都是就绪队列的进程。</p>
</blockquote>
<h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ol>
<li>缺页中断：需要的页不存在内存之中</li>
<li>页替换：当所有的物理页都被占用；选择一个页被换出去</li>
<li>表现：<ol>
<li>抖动：耗时，低效率</li>
<li>预测：在需要之前就把页面加载进来</li>
<li>最优方案：最远将来（不现实）</li>
</ol>
</li>
</ol>
<p>页面置换算法的功能与目标：</p>
<ol>
<li>功能：当出现缺页异常并且物理内存已经被占满，调出一个物理页给新需要的页使用</li>
<li>设计目标：极可能减少页面的调入调出次数</li>
</ol>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><h3 id="最优页面置换算法"><a href="#最优页面置换算法" class="headerlink" title="最优页面置换算法"></a>最优页面置换算法</h3><p>通常是衡量置换算法的标准</p>
<p>置换在未来最长时间内不访问的页面</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/96462944.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/314073.jpg" alt=""></p>
<h3 id="最近未使用：NRU"><a href="#最近未使用：NRU" class="headerlink" title="最近未使用：NRU"></a>最近未使用：NRU</h3><p>发生pgfault的时候，检查所有页面，将页面分为四类：</p>
<ol>
<li>没有访问 没有修改</li>
<li>没有访问 已经修改该</li>
<li>已经访问 没有修改</li>
<li>已经访问 已经修改</li>
</ol>
<p>需要替换的时候按照首先替换0的规则进行替换。</p>
<p>这是因为每次访问页面都会引发中断：写R/W位，于是os可以利用这个时间做一些事。定时把R位清零来区别最近没有被访问的和已经访问的。</p>
<h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><p>替换最先被换进来的。</p>
<p>通过维护一个记录所有位于内存的逻辑页面链表，将该链表按驻留时间排序，联手最长，连伟最短。缺页的时候进行置换，新页面加到链尾</p>
<p>实现简单，可以用硬件实现，但是性能很差，基本不会单独使用这个算法。</p>
<p><strong>Belady</strong>现象：</p>
<p>分配的物理也数增加，但是却也次数也会增加的现象。</p>
<p>原因：FIFO的置换特征与进程访问内存的动态特征矛盾<br>被他置换出去的不一定是近期不会访问的。</p>
<h3 id="LRU：最近最少使用页面算法"><a href="#LRU：最近最少使用页面算法" class="headerlink" title="LRU：最近最少使用页面算法"></a>LRU：最近最少使用页面算法</h3><p>最近经常访问的页面可能在以后也会经常访问，最近不经常访问的页面可能以后也不会访问。于是选择最长时间没有被访问过的页面替换出去。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/30845425.jpg" alt=""></p>
<blockquote>
<p>这是最优置换算法的一种近似</p>
</blockquote>
<p>虽然可以实现，但是代价很高<br>——需要一个全面的链表，最少使用的在前，最多使用的在后。<br>——需要一个栈，访问页面的时候将这个页号压入栈，并把栈内相同的页号抽出，缺页时拿栈底</p>
<p>使用一个n*n矩阵表示所有页框的信息，当k被访问的时候，把k行设置为1，k列设置为0，一段时间后，每一行的二进制值最小的就是最近最少使用的。</p>
<p><strong>Simple Implementation</strong>：页表项上的计数器<br><strong>硬件实现</strong>：为n<em>n矩阵，使用了特殊的寄存器<br><em>*软件实现</em></em>：NFU</p>
<h3 id="最不常用算法：LFU-NFU"><a href="#最不常用算法：LFU-NFU" class="headerlink" title="最不常用算法：LFU/NFU"></a>最不常用算法：LFU/NFU</h3><p>是对LRU的软件实现。</p>
<p>将每个页面与一个计数器关联，取计数值最小的页面替换</p>
<p>LFU的缺点是他从来不会忘记。以前频繁使用的页面很大可能不会被调出去。：<strong>通过计数器定时右移来改正</strong>-&gt;老化算法<br>LRU关注的是多久未访问而LFU关注的是访问次数，是不一样的。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/89846367.jpg" alt=""></p>
<h3 id="时钟算法"><a href="#时钟算法" class="headerlink" title="时钟算法"></a>时钟算法</h3><p>环状结构，当一个缺页中断到来的时候，首先检查指针所在位置页面的访问位，如果是0就淘汰这个页面，否则置为0，转圈，转到的，如果是0就淘汰，如果是1就变成0，知道找到第一个0。</p>
<p>是LRU与FIFO的折中。<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/9967853.jpg" alt=""></p>
<h3 id="改进的时钟算法"><a href="#改进的时钟算法" class="headerlink" title="改进的时钟算法"></a>改进的时钟算法</h3><p>在页面添加修改位，并在访问时进行相应修改：<br>新改的：RW。<br>每次扫过都将：如果R是1，把R置为0；如果R是0，如果W是1，写这页，写完之后W=0，接着找，如果R=0W=0，就是这个了。</p>
<p>缺页时修改页面标志位，以跳过有修改的页面。<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/7051850.jpg" alt=""></p>
<hr>
<p>上述的都是<strong>局部页面置换算法</strong>。<br>局部页面置换算法选择范围仅仅限于当前进程占用的空间，不考虑进程访存差异。<br><strong>全局页面置换算法</strong>可以逼出其他进程的物理页面：工作集算法、缺页率算法<br>需要动态确定好给每一个进程的物理页面数。</p>
<hr>
<p>CPU利用率达到极致以后，再增加并发进程数iu会出现内存抖动。<br>进程数少时，提高并发进程数，可提高CPU利用率<br>并发进程导致内存访问增加<br>并发进程的内存访问会降低了访存的局部性特征<br>局部性特征的下降会导致缺页率上升和CPU利用率下降</p>
<h3 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h3><h3 id="缺页率置换算法"><a href="#缺页率置换算法" class="headerlink" title="缺页率置换算法"></a>缺页率置换算法</h3><p>缺页次数 / 内存访问次数 或 缺页平均时间间隔的倒数</p>
<p><strong>影响缺页率</strong>：</p>
<ol>
<li>页面置换算法</li>
<li>分配给进程的物理页数目</li>
<li>页面大小</li>
<li>程序的编写方法</li>
</ol>
<p>可以通过调整常驻集的大小，使每一个进程的缺页率保持在一个合适的值。<br>若进程缺页率过高，则增加常驻集以分配更多的物理页面<br>若进程缺页率过低，则减少常驻集以减少它的物理页面数</p>
<blockquote>
<p>为每一个页面计数，达到-m的时候，回收，你要页面就给页面。</p>
</blockquote>
<p>普通访问不做任何事情，缺页的时候，算一下多久没有缺页了，如果数值比较大，看一看是不是有的页面已经没用了，在这期间没有访问的页面被释放。如果小一些，看看是不是需要补一些页面。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/45924471.jpg" alt=""></p>
<p><strong>页替换过程</strong></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/94487722.jpg" alt=""></p>
<h1 id="段机制"><a href="#段机制" class="headerlink" title="段机制"></a>段机制</h1><p><strong>段</strong>：一个程序的逻辑分区<br><strong>页机制缺点</strong>：复杂，消耗资源</p>
<p>地址映射：段中的addr +段中的偏移<br>内存分配：全局段表+本地段表<br>调度：需要时加载段<br>段+分页：用段技术组织节目内容，用分页技术组织物理内存</p>
<h2 id="段地址空间"><a href="#段地址空间" class="headerlink" title="段地址空间"></a>段地址空间</h2><p>进程的段地址空间由多个段组成 ：<br>主代码段 子模块代码段 公用库代码段 堆栈段 堆数据(heap) 初始化数据段 符号表等</p>
<p>段式存储管理的目的：<strong>更细粒度和灵活的分离与共享</strong>一般用于权限控制</p>
<p>段一般是一种段是连续的。有起始地址以及段内偏移量。</p>
<p><strong>段</strong>：表示访问方式和存储数据等属性相同的一段地址空间</p>
<h2 id="段页结合"><a href="#段页结合" class="headerlink" title="段页结合"></a>段页结合</h2><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/3276497.jpg" alt=""></p>
<p>内存共享：通过指向相同的页表基址，实现进程之间的段共享。</p>
<h2 id="link-of-segments"><a href="#link-of-segments" class="headerlink" title="link of segments"></a>link of segments</h2><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-16/41368943.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> OS </category>
            
            <category> 课 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OS </tag>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[chap2-进程与线程]]></title>
      <url>/2017/11/06/OS/chap2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h1 id="导"><a href="#导" class="headerlink" title="导"></a>导</h1><p>进程模型的进化：</p>
<ol>
<li>第一代：relay , vacuum tubes and plugboards。没有程序与进程的概念</li>
<li>第二代：批处理系统：一个程序完成所有工作。</li>
<li>带三代：mutiprogramming and timesharing。CPU可以切换运行。</li>
<li>第四代：现代OS：进程模型更加成熟，进程调度与相互交流更加成熟，内存保护与管理更加成熟。</li>
</ol>
<p><strong>进程</strong>：计算机上所有可以运行的软件，通常也包括操作系统，被组织成若干顺序进程，简称进程。它包括输入输出程序与状态。</p>
<p>需要区分进程与程序。</p>
<p>进程创建：系统初始化、运行进程的创建进程系统调用被执行、用户请求、批处理作业初始化。</p>
<p>进程终止：正常退出、出错退出（自愿）、严重错误、被杀死（非自愿）</p>
<p>在unix中，每个进程有自己的父进程，有着明显的层次结构，但是在Windows中，虽然也有“句柄”来标识父进程，拥有句柄即可控制及对应的子进程，但是这个“句柄”可以被转让，就不存在明显的层次关系了。</p>
<h2 id="为什么要并发（Cocurrency）？"><a href="#为什么要并发（Cocurrency）？" class="headerlink" title="为什么要并发（Cocurrency）？"></a>为什么要并发（Cocurrency）？</h2><p><strong>whats os?</strong><br>    A special kind of system software that can manage computer in  efficient and reasonable way. It is in charge of managing hardware resource, controlling the running of programs and providing useful services. It is a convenient platform for people to use computer</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h2><ol>
<li>使用cpu的基本数据结构<ol>
<li>逻辑程序：被用户设计实现（envs）</li>
<li>cpu指令序列：</li>
<li>进程：程序与指令之间的数据结构</li>
</ol>
</li>
</ol>
<p><strong>进程</strong>：进程是某一个特定程序的运行实例，包括输入输出程序与状态。在分时操作系统（time-sharing os）中，CPU被多个进程分享，复杂的算法将被用于进程之间的调度。</p>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p>基本状态：</p>
<ol>
<li>running：真正占用CPU</li>
<li>ready：可以运行，等待CPU的使用权</li>
<li>blocked：不能继续运行，等待外部事件（输入输出等）</li>
</ol>
<p>其他状态：</p>
<ol>
<li>new：进程的数据结构已经准备好，但是程序镜像尚未完成装载（env_create到icode_load之前，此时还不可以调用env_run）</li>
<li>exit：程序已经完成了所有工作，但是还没有回收进程的数据结构（exit gracefully之后，free之前）</li>
<li>suspend：运行镜像已经被换到硬盘里面了</li>
</ol>
<blockquote>
<p>为什么block不能直接过渡到running：你都阻塞了，想回来啊？等吧。<br>为什么ready不能直接block？你都没有运行，怎么直到自己要等待一个外部事件去block？</p>
</blockquote>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-14/82449429.jpg" alt=""></p>
<p>那么为什么会<strong>挂起</strong>呢？</p>
<p>挂起是由于：1.等待时间过长 2. 物理地址空间不足。导致该进程所需运行资源被切换到外存。</p>
<p>页面置换是一件很麻烦的事情，需要进行一系列的硬盘操作，硬盘是一个极其慢的设备，那么为什么还要有挂起状态？（废话如果内存也能有120G那么多空间谁会给他换到硬盘啊）</p>
<ol>
<li>提高处理机效率：就绪进程表示空的时候，提交新进程，以提高处理机效率（<em>哈？</em>）</li>
<li>为运行进程提供足够多的内存</li>
<li>便于调试：在调试时，挂起被调试进程对其地址空间进行读写。</li>
</ol>
<p>什么时候会挂起呢？在进程等待外部事件（阻塞）的时候，有可能被挂起。</p>
<p>除此之外的双挂起模型：<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-14/87376882.jpg" alt=""></p>
<p><strong>等待-&gt;等待挂起</strong>：没有进程处于就绪状态或者是就绪进程需要更多的内存资源。(???)<br><strong>就绪-&gt;就绪挂起</strong>：有高优先级的等待进程和低优先级的就绪进程（这是就绪进程被换到外存）<br><strong>运行-&gt;就绪挂起</strong>：对于抢先式分时系统，有高优先级的等待挂起进程因事件出现而进入就绪挂起。<br><strong>等待挂起-&gt;就绪挂起</strong>：等待的事件到了<br><strong>就绪挂起-&gt;就绪</strong>：没有就绪进程或者是就绪挂起进程的优先级比所有就绪进程的优先级都高<br><strong>等待挂起-&gt;等待</strong>：有一个进程释放了内存，一个等待挂起进程的优先级很高</p>
<p>值得一提的是，winxp用的就是上面的双挂起模型。</p>
<p><a href="http://blog.csdn.net/freeelinux/article/details/53562592" target="_blank" rel="external">对挂起的详细分析</a></p>
<blockquote>
<p>为什么要双挂起呢，os真的那么缺内存吗？<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-14/11990991.jpg" alt=""><br><a href="https://github.com/GcsSloop/Note/tree/master/OperatingSystem" target="_blank" rel="external">from:gcssloop/note</a></p>
</blockquote>
<p>linux下使用的进程模型是：</p>
<ol>
<li>TASK_RUNNING</li>
<li>TASK_INTERRUPTIBLE：进程被挂起，直到某些条件变成真。（产生一个中断，在中断中释放一些该进程等待的系统资源，传递唤醒该进程的信号）<br>$$\color{red}{shenme玩意}$$</li>
<li>TASK_UNINTERRUPTIBLE：除了信号不能使它的状态发生变化之外与前一个相同</li>
<li>TASK_STOPED</li>
<li>TASK_TRACED：进程运行被debugger打断</li>
<li>EXIT_ZOMBIE：程序运行已经结束了，但是他的父进程还没有调用一个wait4()或是waitpid()系统调用来返回死掉进程的信息。</li>
<li>EXIT_DEAD</li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-14/55177783.jpg" alt=""></p>
<p>$$\color{red}{so why… kill之后为什么不死}$$</p>
<p>不同的os，其状态设置的差异很大。</p>
<h2 id="进程数据结构"><a href="#进程数据结构" class="headerlink" title="进程数据结构"></a>进程数据结构</h2><p><strong>PCB：进程控制块</strong>：<br>这就是在jos里面的envs那个大数组了，它由操作系统内核维护，也叫进程描述符。（经过了jos的洗礼，其实不用说太多）</p>
<p>所有pcb都在一个特定的内存空间之中。pcb表的size决定了os的并发度。不同状态的进程数据被存在不同的pcb表中。</p>
<p>在一个正经系统中的pcb比env中的项更多，列为：<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-14/88783439.jpg" alt=""></p>
<p>为了将不同运行状态的pcb区分开，可以有两种方法，一种是：<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-14/92773297.jpg" alt=""><br>另一种是：<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-14/64758197.jpg" alt=""></p>
<p>其中第一种是在jos中使用的方式。</p>
<h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><p>进程切换就是我们的sched函数了。<br>切换之前，需要保存在cpu运行程序的山下文（tf内容、pgdir等），切换之后，把新上来的进程的上下文恢复。</p>


<iframe height="363" width="565" src="http://oysmkdi7t.bkt.clouddn.com/%E5%AA%92%E4%BD%932.mp4" frameborder="0" allowfullscreen>
</iframe>


<p>比如说sleep的实现：一个进程运行到了sleep，os去处理这个sleep，此时cpu的掌管权在kernel手里，随后设置一个硬件的时钟中断，然后保护现场，最后os就schedule，把运行权交给了另一个进程，另一个进程运行了一段时间之后硬件的时钟中断raise，打断了另一个进程的运行，于是os处理这个时钟中断保护现场，剥夺了另一个进程的运行权，再一次schedule，进程1开始运行。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-14/62249836.jpg" alt=""></p>
<h2 id="运行镜像（process-image）"><a href="#运行镜像（process-image）" class="headerlink" title="运行镜像（process image）"></a>运行镜像（process image）</h2><p>运行镜像就是☞进程的整个生存周期的描述。</p>
<p><strong>process image的内容</strong>：</p>
<ol>
<li>用户层面：该进程的用户地址空间，比如说程序、堆栈、数据段</li>
<li>寄存器层面：pc、pcw、ir，栈指针其他寄存器</li>
<li>系统层面：pcb等、动态内核指针</li>
</ol>
<p>（emm个人觉得，其实就是pcb里面保存的那些东西，以及那些指针指向的那些空间）</p>
<h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><p>p82</p>
<p>简述：</p>
<p><strong>Q</strong>：什么时候调度？<br>    进程被创建、进程退出<br>    进程阻塞<br>    出现io中断</p>
<p><strong>Q</strong>：为什么要调度？<br>    做更好的选择：优先级、运行时长<br>    保证CPU的效率</p>
<p><strong>Q</strong>：怎么做调度？<br>    使用特定的方式选择一个进程占用CPU<br>    在切换的时候切换上下文</p>
<p><strong>A</strong>：注意：</p>
<ol>
<li>调度的频率是非常重要的</li>
<li>有抢占式调度与非抢占式调度</li>
<li>CPU-bound（计算密集型）与i/o-bound（io密集型）进程</li>
</ol>
<p>CPU资源的时分复用 ：</p>
<ol>
<li>进程切换：CPU资源占用者切换</li>
<li>处理机调度：从就绪队列中挑选进程、从CPU中挑选可使用的CPU</li>
<li>调度程序：调度策略、调度时机</li>
</ol>
<h3 id="when-and-why"><a href="#when-and-why" class="headerlink" title="when and why"></a>when and why</h3><p>上述的调度时间是一个笼统的说法：</p>
<ol>
<li>内核运行调度程序的条件<br> 进程退出<br> 进程从运行态切换到等待</li>
<li>非抢占系统中<br> 当前进程主动放弃CPU</li>
<li>可抢占系统<br> 当前进程时间片用完<br> 中断请求被服务例程响应完成时</li>
</ol>
<p>其实在写完jos的sched函数之后，对何时调度应该有一个认识：无论是何时调度，都是os编写人员决定的（或是用户程序主动放弃）。os为了避免用户程序不自觉，提供了时间中断（timer interrupt），在每一个时间终端的处理中指定schedule。<br>再比如上面提到的io中断，这部分也是os决定的sched，因为trap(jos)是属于kernel部分。</p>
<p>调度的目标：不同的系统中目标是不同的</p>
<ol>
<li><p>在所有系统中：</p>
<ol>
<li>公平性：给每一个进程一个公平使用CPU的机会</li>
<li>策略强制执行:seeing thatstated policy is carried out</li>
<li>平衡：保持整个系统都是有事可干</li>
</ol>
</li>
<li><p>批处理系统：</p>
<ol>
<li>吞吐量：使单位时间的工作量达到最大</li>
<li>周转时间（turnaround time）：在任务提交与任务完成之间时间尽可能小</li>
<li>CPU利用率：让CPU一直有事可干</li>
</ol>
</li>
<li><p>交互系统：</p>
<ol>
<li>响应时间</li>
<li>Proportionality：达到用户期望值</li>
</ol>
</li>
<li><p>实时系统：</p>
<ol>
<li>meet deadline：别丢数据</li>
<li>可预测：在多媒体系统中别有质量上的降低</li>
</ol>
</li>
</ol>
<h3 id="goal"><a href="#goal" class="headerlink" title="goal"></a>goal</h3><p>那么给定一个调度算法，怎么比较他们之间的优劣呢？</p>
<ol>
<li>CPU使用率</li>
<li>吞吐量：单位时间内完成进程的数量</li>
<li>周转时间：进程从初始化到结束绝对时间</li>
<li>等待时间：进程在<strong>就绪</strong>中的时间（不算等待状态的时间，因为这个时间其实是必须花费的）</li>
<li>响应时间：从提交请求到请求响应时间</li>
</ol>
<p><strong>吞吐量与响应时间之间的区别</strong></p>
<p>吞吐量是什么呢？其实就是希望通过合理的调度使规定时间内完成更多的进程，比如说文件传输的时候希望<strong>高带宽</strong>（10M/s与10k/s你想要哪个？）。<br>响应时间是什么呢？就是希望进程对某一个动作尽可能快的作出反应，比如点击按钮搜索之后多久才响应。</p>
<p>吞吐量与响应时间其实是很不同的两个概念，两者我认为在某种情况下是此消彼长的。吞吐量描述的是整体，响应时间描述的特定。</p>
<p><strong>响应时间目标</strong>：</p>
<ol>
<li>减少响应时间 </li>
<li>减少平均响应时间的波动<br>在交互是系统中，减少平均响应时间波动其实更加重要。</li>
</ol>
<p>响应时间是os的计算延时。</p>
<p><strong>吞吐量目标</strong>：</p>
<ol>
<li>增加吞吐量：减少os开销（减少上下文切换）、系统资源的高效利用（CPU、io）</li>
<li>减少等待时间：减少每个进程在就绪呆的时间<br>os需要保证吞吐量的提高不会影响交互体验（os必须不时地进行调度，即使存在许多交互式任务）</li>
</ol>
<p>吞吐量是os的计算带宽</p>
<h3 id="批处理系统中的调度算法"><a href="#批处理系统中的调度算法" class="headerlink" title="批处理系统中的调度算法"></a>批处理系统中的调度算法</h3><p>吞吐量、周转时间、CPU利用率</p>
<ol>
<li>先来先服务：非抢占式<br> 笨蛋算法、简单，某些情况下也合理、io密集型系统中对CPU利用率低到令人发指</li>
<li>最短任务优先：非抢占式<br> 周转时间短、在现实的os中并不会是最优的</li>
<li>最短剩余时间优先：抢占式<br> 将新任务的时间与当前任务的剩余运行时间做对比，如果新任务时间短就让新任务占据CPU、不现实啊</li>
<li>三层调度<br> admission scheduler<br> memory scheduler<br> CPU scheduler</li>
</ol>
<h4 id="先来先服务（FCFS）"><a href="#先来先服务（FCFS）" class="headerlink" title="先来先服务（FCFS）"></a>先来先服务（FCFS）</h4><p>就是先来先运行，也没有抢占，运行到结束就行了。</p>
<p>优点是非常简单，但是缺点更加明显。</p>
<ol>
<li>平均等待时间波动很大，短进程可能会在长进程后面</li>
<li>资源利用率低（一直运行一个你说利用率能高吗），CPU密集型导致io闲置，io密集型导致CPU闲置。</li>
</ol>
<blockquote>
<p>说到这里就想起来一个题外话。上编译课的时候编译老师说他上学那会儿用的编译器是非常老的编译器，性能也不好。一般都是晚上离开实验室的时候把写的东西运行上，第二天回来实验室的时候能出结果都已经很不错了。<br>os课的时候老师说，假如你买了一个服务要去运行自己的程序，本来你就是一个hello world，前面那个人的程序可能特别庞大需要一天来运行，你倒霉催的正好排在那人后面，你可能几秒就完事了，但是那个服务器好巧不巧用的FCFS，那你可就等吧。</p>
</blockquote>
<h4 id="最短时间优先算法（SPN）"><a href="#最短时间优先算法（SPN）" class="headerlink" title="最短时间优先算法（SPN）"></a>最短时间优先算法（SPN）</h4><p>每次选择就绪队列中的运行时间最短的进程来执行，就绪队列按照预期的执行时间来排序。</p>
<p>非常容易就可以想到的是，SPN必定具有<strong>最短平均周转时间</strong>。（如果学过贪心算法，应该很清楚这一点）（吞吐量可不会，SPN是非抢占，只能串行运行的）</p>
<p>缺点也非常明显，你一直运行hello world，人家正儿八经的要运行一天的大程序什么时候才能开始运行啊？<br>可能会导致<strong>饥饿</strong>。</p>
<p>还有一个需要解决的问题是<strong>如何预测程序运行</strong>，不太可能准确预测一个程序需要的执行时间，尤其是当ifelse while等语句十分的情况下，这种运行时间一般都需要在运行时才能确定。<br>不能预测这个算法还有什么好实现的？<br>还有一种方法是问用户，你不能保证用户都是诚实的，但是你可以最多分配用户指定的时间，超出时间就杀死。但是这种方法真的太不友好太不专业了，程序运行中的状况很多，用户也不一定知道运行时间。</p>
<p>所以这种方法其实是不太可行的。</p>
<h4 id="最短剩余时间优先算法（SRT）"><a href="#最短剩余时间优先算法（SRT）" class="headerlink" title="最短剩余时间优先算法（SRT）"></a>最短剩余时间优先算法（SRT）</h4><p>是SPN的可抢占改进版，允许当新进程进入时新进程如果运行时间很短可以代替老进程运行。</p>
<p>其实这才改是真正的最短平均周转时间。（即使是可抢占，也与吞吐量高无缘，又不会在等待的时候调度）。</p>
<p>缺点也差不多与SPN差不多。</p>
<h4 id="最高响应比优先算法（HRRN）"><a href="#最高响应比优先算法（HRRN）" class="headerlink" title="最高响应比优先算法（HRRN）"></a>最高响应比优先算法（HRRN）</h4><p>选择就绪队列中响应比R值最高的进程。不支持抢占。</p>
<p><strong>响应比</strong>：R=(等待时间+执行时间)/执行时间</p>
<p>那也就是等待的时间越长越容易被选中。是在短进程优先算法基础之上的改进，防止无止境地等待。</p>
<h4 id="三层调度"><a href="#三层调度" class="headerlink" title="三层调度"></a>三层调度</h4><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-14/65249341.jpg" alt=""></p>
<h3 id="交互式系统中的调度"><a href="#交互式系统中的调度" class="headerlink" title="交互式系统中的调度"></a>交互式系统中的调度</h3><ol>
<li>时间片轮转：抢占式<br> 时间片耗尽时触发调度、进程等待（阻塞）时触发调度</li>
<li>多级队列：<br> 有多种优先级class，美哟中class存在同一个队列、根据优先级选择进程、高优先级低时间片保证公平</li>
<li>优先级调度：抢占式<br> 每个进程有自己的优先级、CPU选择最高优先级、动态优先级来避免饥饿</li>
</ol>
<p><strong>处理机资源的使用模式</strong>：</p>
<p>进程在CPU计算与io之间进行交替：每次调度决定在下一个CPU计算时将那个工作交给CPU，在时间片机制下，进程可能在结束当前CPU计算之前放弃CPU。</p>
<h4 id="时间片轮转-（RR）"><a href="#时间片轮转-（RR）" class="headerlink" title="时间片轮转 （RR）"></a>时间片轮转 （RR）</h4><p>每当时间片结束，就会引发一个调度，每当进程自己要等待，引发一个调度。每当下去，自觉排在队尾。</p>
<p>时间片轮转的问题是：</p>
<ol>
<li>额外的上下文切换开销</li>
<li>时间片选择问题</li>
</ol>
<p>其实归根结底是时间片选择问题，额外的上下文切换是一定必须的。<br>如果时间片选择太大，就失去了调度的灵活性，等待时间变长，这在交互式系统中可能是不可忍受的。甚至在极限情况下，就退化成了上述的FCFS。<br>如果时间片选择太短，将会浪费大量的时间在上下文切换。比如在linux，上下文切换一次可能需要1ms，如果4ms是时间片长度，那么整个系统中有20%的时间都在做上下文切换。这是没有意义的浪费。<br>经验上，一般将浪费控制在1%，实践篇一般设置在20-50ms。<br>当n（就绪队列长度）比较大的时候，可以把某一些就绪状态的进程给传到就绪挂起。</p>
<h4 id="多级队列调度算法（MQ）"><a href="#多级队列调度算法（MQ）" class="headerlink" title="多级队列调度算法（MQ）"></a>多级队列调度算法（MQ）</h4><p>就绪队列被划分为多个独立的子队列（终端、io、前台交互、后台批处理）<br>每个队列可以有自己的调度策略（前台RR，后台FCFS等）<br>队列之间的调度：</p>
<ol>
<li>固定优先级：可能导致饥饿</li>
<li>时间片轮转：每个队列得到一个确定的能偶用于调度其进程的CPU总时间（比如前台80%后台20%）</li>
</ol>
<h4 id="多级反馈队列算法（MLFQ）"><a href="#多级反馈队列算法（MLFQ）" class="headerlink" title="多级反馈队列算法（MLFQ）"></a>多级反馈队列算法（MLFQ）</h4><p>进程可以在不同队列之间移动的多队列算法。时间片大小可以随着优先级级别增加而减小，如果进程在当前的时间片没有完成，降到下一个优先级。</p>
<p>其特点是：CPU密集型的进程优先级下降很快，而io密集型进程停留在高优先级。</p>
<h4 id="优先级算法（PS）"><a href="#优先级算法（PS）" class="headerlink" title="优先级算法（PS）"></a>优先级算法（PS）</h4><p>是多级队列算法的改进，平衡各进程对响应时间的要求。<br>分为抢占式与非抢占式。<br>通常可以控制其时间片长度。<br>如果io完成，提高优先级，如果时间片用完，将低优先级。</p>
<p><strong>静态优先级</strong>：<br>在创建进程的时候，他的优先级就被确定，直到进程终止之前都不会改变。<br>（系统进程优先级高、io密集型优先级高）</p>
<p><strong>动态优先级</strong>：<br>优先级在创建的时候被赋予，但是在进程运行的过程中可以被改变：</p>
<ol>
<li>在就绪队列中，等待时间延长优先级高。</li>
<li>进程每执行一个时间片就降低这个进程的优先级。</li>
</ol>
<p>对于不同类型的进程：<br><strong>io密集型进程</strong>：他是最高级优先。<br>为什么io密集的优先级比较高呢？这是因为io密集型一般只会占用一小会儿CPU，随后就会等待io外部操作去了。最好的做法是，io一旦就绪就赶紧用一下CPU，然后就可以去等io事件了。如果io密集型进程的优先级比较低，将会浪费很多时间在就绪的等待上。<br>CPU密集型时常需要CPU资源，由于优先级低，可以使用更大的时间片，减少上下文切换的浪费。</p>
<p>动态处理：<br>对于io密集型，尽量别减小优先级。（如果是MLFQ，这是几乎可以保证的，因为io密集，可能在给定的时间片中没有用完时间片就自己进入阻塞状态了）（me）<br>对于cpu密集型，在它的io完成之后，放回io请求时离开的队列，以免每次都回到最高优先级再逐次下降。</p>
<h4 id="最短进程优先"><a href="#最短进程优先" class="headerlink" title="最短进程优先"></a>最短进程优先</h4><h4 id="保证调度"><a href="#保证调度" class="headerlink" title="保证调度"></a>保证调度</h4><p>向用户做出明确的性能保证，然后去实现它。</p>
<p>初始：每个进程同等的share CPU。<br>随后：计算每个进程理应获得的时间与实际获得的时间之比。<br>结果：倾向于运行比率更低的进程，直到它的radio超过他的接近竞争者。</p>
<h4 id="彩票调度"><a href="#彩票调度" class="headerlink" title="彩票调度"></a>彩票调度</h4><p>就是os卖彩票，给每个进程一个彼此不同的彩票，一旦需要调度，就抽彩票，看看谁中奖，中奖的哪个进程获得资源。<br>”所有进程是平等的，但是有一些进程更平等一些“<br>给某些重要的进程额外的彩票，增加他们中奖的几率。</p>
<p>允许进程之间交换彩票，比如客户机进程获得了运行权，然后阻塞等待服务器的响应，这时客户机可以把自己的彩票给服务器机进程，以增加服务器及进程被选中的机会。（实际上，如果没有客户机进程，服务器及进程的存在就是一个错误）</p>
<h3 id="调度实现"><a href="#调度实现" class="headerlink" title="调度实现"></a>调度实现</h3><p>unix：动态优先级算法<br>5.3BSD：MQ<br>Windows：优先级算法<br>Linux：抢占式调度（preemptive scheduling）</p>
<h3 id="调度机制设定"><a href="#调度机制设定" class="headerlink" title="调度机制设定"></a>调度机制设定</h3><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/81651596.jpg" alt=""><br>$$\color{red}{什么鬼这是}$$</p>
<p>在oskernel设计调度算法，就像我们的schedule函数在kernel中完成，并封装用户接口供用户调用。</p>
<p>除了时间片，允许用户也做出调度的决定，完成调度策略设置。</p>
<p><strong>可以参考lab4的文档</strong></p>
<h2 id="进程之间的通信"><a href="#进程之间的通信" class="headerlink" title="进程之间的通信"></a>进程之间的通信</h2><p>消息、管道、消息队列、共享内存</p>
<p>可以参考lab4文档，里面有ipc以及lab5中有共享内存。</p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p><strong>线程</strong>是进程中一个相对独立的、具有可调度特性的<strong>执行单元</strong>。</p>
<p>线程一定不是陌生的，早在大二上学期，就在Java中接触了线程。线程作为实现进程中的并发而存在。</p>
<p>系统提供了线程库Pthread：<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/74457502.jpg" alt=""></p>
<h2 id="线程库"><a href="#线程库" class="headerlink" title="线程库"></a>线程库</h2><p>线程库是针对那些不提供多线程支持的os而设计的在用户态下的库，线程库的处理对这些os是透明的。</p>
<p>即使提供了核心线程支持的os，也有必要提供线程库，可以简化或有利于线程机制的使用。</p>
<p>线程库提供：</p>
<ol>
<li>合适的多线程编程的接口</li>
<li>记录线程状态和调度各个线程的运行机制</li>
</ol>
<p>在系统内部可以使用多种方式实现线程机制：</p>
<ol>
<li>ULT纯用户级线程：线程管理全部由用户程序完成，kernel只管理进程，增加”线程库“概念。</li>
<li>KLT核心级线程：线程有kernel管理，kernel为用户提供系统调用。</li>
</ol>
<p><strong>ULT</strong>：<br>进程表在kernel，线程表在用户空间，使用线程库。线程表由运行时系统管理。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/40601574.jpg" alt=""></p>
<p>ult的优点是：</p>
<ol>
<li>线程切换不需要陷入内核：比陷入内核快一个数量级</li>
<li>允许进程制定自己的调度算法而不会影响os的调度算法程序</li>
<li>ult管理模式可以在任何os下运行，不需要修改内核，只需要线程库。</li>
</ol>
<p>ult的不足是：</p>
<ol>
<li>系统调用会引起进程阻塞</li>
<li>不利于多处理器并行（<strong>why？？？</strong>）</li>
</ol>
<blockquote>
<p>关于系统阻塞的问题：<br>os并不知道进程里还有线程，当一个线程在尚未发生键盘操作的时候读键盘，将会引发阻塞。这时可能整个进程都会被os的调度算法调度下来，整个进程都会阻塞。而要使用线程，应该允许每个线程都能够阻塞调用，而不影响其他线程的运行。现在显然是不行。<br>有两种解决方法，一是修改read在没有外部事件时返回0，但是对read语义的改变休要大量代码的修改。<br>另一种是允许进行阻塞检查，仅在外部事件发生时才进行系统调用，否则先让出使用权给其他线程运行。这种方式一点都不好看，但是也没有其他的方法了。</p>
<p>还有一个问题是进程的无休止运行。没有时间片操作。<br>对ult最大的争论是程序员一般只会在经常发生线程阻塞的程序中才会大量使用线程。</p>
</blockquote>
<p><strong>klt</strong>：<br>线程与进程都在用户空间完成（what？）<br>进程表与线程表都在kernel</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/46110689.jpg" alt=""></p>
<p>优点：<br>线程在kernel中有信息，系统调用基于线程（不存在上述的阻塞）<br>可以克服ult的阻塞与并行度差的缺点，并且kernel也可以使用多线程。</p>
<p>缺点：<br>每次进行线程调度都需要陷入内核</p>
<h2 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h2><p><strong>线程</strong>使劲蹭的一部分，描述指令流执行状态，是进程中的指令执行最小单元，是CPU调度的基本单位。</p>
<p>在进程与线程机制中，进程作为<strong>资源分配</strong>角色，包括地址空间、打开文件等；线程作为<strong>处理机调度</strong>角色，描述进程资源环境中的指令执行序列状态。</p>
<p>进程的表叫做<strong>TCB</strong>。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/26479287.jpg" alt=""></p>
<p>为什么进程有自己独立的栈？<br>进程描述了指令执行状态，而栈中数据与之前执行的指令有关，因此每一个线程都应该有自己的栈。保证执行指令的独立性。</p>
<ol>
<li>调用函数返回</li>
<li>errorno</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">进程中内容</th>
<th style="text-align:center">线程中内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">地址空间</td>
<td style="text-align:center">程序计数器</td>
</tr>
<tr>
<td style="text-align:center">全局变量</td>
<td style="text-align:center">寄存器</td>
</tr>
<tr>
<td style="text-align:center">打开文件</td>
<td style="text-align:center">堆栈</td>
</tr>
<tr>
<td style="text-align:center">子进程</td>
<td style="text-align:center">状态</td>
</tr>
<tr>
<td style="text-align:center">即将发生的报警</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">信号与信号处理程序</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">账户信息</td>
</tr>
</tbody>
</table>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/51773333.jpg" alt=""></p>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>|进程|线程|<br>|资源分配单位|CPU调度单位|<br>|有完整的资源平台|只独享指令执行的必要资源|<br>|基本状态与其他状态与转换|就绪等待运行状态与转换|</p>
<p>线程：减少并发执行的时间与空间开销</p>
<ol>
<li>创建时间比进程短（why）</li>
<li>终止时间比进程短</li>
<li>同一进层内的线程切换时间更短</li>
<li>同一进程之间的线程共享内存与文件，不需要通过内核进行通信。</li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/87331439.jpg" alt=""></p>
<p><strong>what is 多对多</strong></p>
<h2 id="轻权进程"><a href="#轻权进程" class="headerlink" title="轻权进程"></a>轻权进程</h2><p>内核支持的用户线程。</p>
<p>一个进程可以有一个或者多个轻量级进程，每个轻权进程由一个单独的内核线程支持。<br>太过复杂，最后被抛弃。<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/47608393.jpg" alt=""></p>
<h1 id="经典IPC问题"><a href="#经典IPC问题" class="headerlink" title="经典IPC问题"></a>经典IPC问题</h1><p>进程之间的通信，可以参见lab4ipc。</p>
<h2 id="进程之间通信"><a href="#进程之间通信" class="headerlink" title="进程之间通信"></a>进程之间通信</h2><ol>
<li><p>进程之间通信将产生什么问题？</p>
<ol>
<li>异步：从一个进程传递信息到另一个</li>
<li>排外：与其他进程争夺资源</li>
<li>同步：维护适当的运行序列</li>
</ol>
</li>
<li><p>进程之间通信的难处：</p>
<ol>
<li>信息的格式：signal、switch、message</li>
<li>排外与同步：合作问题</li>
</ol>
</li>
<li><p>金字塔规则</p>
</li>
</ol>
<p><strong>竞争条件</strong>：两个或多个进程读写某些共享数据，而最后的果取决于进程运行的精确时序。</p>
<p>书上有一个打印机的例子， 就是说A与B都需要使用打印机，打印机维护in与out指针，供所有进程去访问。假设某一时刻A想打印东西，于是去查找out指针的值，存在临时变量next_free里面，这时时间片来了B上来了，B也要打印东西，于是正常的完成了将东西放在out的位置，out++。这时A回来了，他发现自己next_free是原out值，于是覆盖了B的文件数据，然后把next_free加一，存到out里面。</p>
<h2 id="生产者与消费者问题"><a href="#生产者与消费者问题" class="headerlink" title="生产者与消费者问题"></a>生产者与消费者问题</h2><p>固定大小buffer，生产者加数据，消费者拿数据，更新count，当count是0的时候，消费者休眠，是N的时候生产者休眠。每个进程检查唤醒。</p>
<p>——在数据更新的过程中访问了数据！</p>
<p>概念：<br><strong>race condition</strong>：两个或更多进程竞争同一项资源，在一个进程占用资源的时候其他进程不应该访问。<br><strong>critical region</strong>：对共享内存进行访问的程序片段<br><strong>优秀结果标准</strong>：</p>
<ol>
<li>不可以有两个进程同时处于临界区</li>
<li>不应对CPU的数量与速度有要求</li>
<li>临界区外运行的进程不能阻塞其他进程</li>
<li>进入临界区时不能无限等待</li>
</ol>
<p>《甘特图：临界区》</p>
<p>实际程序中，可以将所有代码根据是否访问共享区域分为四个部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">entry section</div><div class="line">    critical section</div><div class="line">exit section</div><div class="line">    remainder section</div></pre></td></tr></table></figure>
<h3 id="家庭采购协调问题"><a href="#家庭采购协调问题" class="headerlink" title="家庭采购协调问题"></a>家庭采购协调问题</h3><table>
<thead>
<tr>
<th style="text-align:center">时间</th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">3:00</td>
<td style="text-align:center">看冰箱 没面包</td>
<td style="text-align:center">–</td>
</tr>
<tr>
<td style="text-align:center">3:05</td>
<td style="text-align:center">离开家去商店</td>
<td style="text-align:center">–</td>
</tr>
<tr>
<td style="text-align:center">3:10</td>
<td style="text-align:center">到达商店买面包</td>
<td style="text-align:center">看冰箱 没面包</td>
</tr>
<tr>
<td style="text-align:center">3:20</td>
<td style="text-align:center">到家，放面包</td>
<td style="text-align:center">去商店</td>
</tr>
<tr>
<td style="text-align:center">3:25</td>
<td style="text-align:center">–</td>
<td style="text-align:center">到商店买面包</td>
</tr>
<tr>
<td style="text-align:center">3:30</td>
<td style="text-align:center">–</td>
<td style="text-align:center">到家，放面包</td>
</tr>
</tbody>
</table>
<p>我们分析这个问题：</p>
<ol>
<li>如何保证买面包动作的成功与高效：有且仅有一个人去买</li>
<li>可能的解决：加锁 导致的问题：无法取到冰箱中其他东西<br>（具体查看PPT，时间有限）</li>
</ol>
<p>关于临界与外部事件发生：可以将等待临界空闲的进程转到阻塞态。</p>
<h3 id="忙等待"><a href="#忙等待" class="headerlink" title="忙等待"></a>忙等待</h3><p>设计思路：通过全局变量保存临界区状态供进程参考</p>
<h4 id="屏蔽中断（disabling-interrupts）"><a href="#屏蔽中断（disabling-interrupts）" class="headerlink" title="屏蔽中断（disabling interrupts）"></a>屏蔽中断（disabling interrupts）</h4><p>基本思想是在进入临界区之前关中断，这就导致时钟中断也会被关闭，从而没有进程可以打断它。</p>
<p>问题：</p>
<ol>
<li>不支持多CPU</li>
<li>把关中断权限交给用户是不明智的选择</li>
</ol>
<p>但是对于内核来说，关中断是一种很好的方法，可以用来维护多线程（如果支持）或者多CPU之间对就绪队列等的访问<br>（别都选到一个进程就尴尬了，在jos里这会发生错误）（话说，在jos里面实现多CPU的时候可有内核锁机制，下面来看一看锁都加在了哪里）</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/64321100.jpg" alt=""></p>
<h4 id="锁变量（Lock-variable）"><a href="#锁变量（Lock-variable）" class="headerlink" title="锁变量（Lock variable）"></a>锁变量（Lock variable）</h4><p>保存一个名为lock之类的全局变量供各个进程进行检查，实际上无济于事——这不也是临界区吗</p>
<h4 id="严格轮换法（Strict-alertnation）"><a href="#严格轮换法（Strict-alertnation）" class="headerlink" title="严格轮换法（Strict alertnation）"></a>严格轮换法（Strict alertnation）</h4><p>要求进程轮流进入临界区。看了代码就会明白：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">    <span class="keyword">while</span>(trun!=<span class="number">0</span>);<span class="comment">//A进程必须等待turn是0的时候才能进去</span></div><div class="line">    critical_region();</div><div class="line">    turn=<span class="number">1</span>;</div><div class="line">    noncritical_region();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">    <span class="keyword">while</span>(turn!=<span class="number">1</span>);<span class="comment">//B进程必须等到turn是1</span></div><div class="line">    critical_region();</div><div class="line">    turn=<span class="number">0</span>;</div><div class="line">    nocritcal_region();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不是一个很好的方案。</p>
<p>缺点：</p>
<ol>
<li>违反了“进程不应该被处于非临界区的进程阻塞”</li>
<li>浪费CPU时间：忙等待时间</li>
</ol>
<p>很明显啊，他们在轮转的时候，如果A这时需要进入临界区但是B在运行非临界区的程序，A可以被放到阻塞态，这时违反了规则3<br>A可以继续循环，这时每次A上去CPU都会浪费时间空循环，还不如去阻塞态。</p>
<p>还有，如果A需要多次进入临界区，而B主要时间在非临界区，A的效率就变得非常低，绝大多数时间都是在空转。</p>
<p><strong>自旋锁</strong>：用于忙等待的锁。</p>
<p>PPT另有两种，都是失败的方法。暂且不提。</p>
<h4 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h4><p>1981-满足线程之间互斥的经典基于软件的解法</p>
<p>似乎仅用于两个进程：<br><a href="https://zh.wikipedia.org/wiki/Peterson%E7%AE%97%E6%B3%95" target="_blank" rel="external">wiki</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></div><div class="line"><span class="meta">#deine N 2 <span class="comment">//进程数量</span></span></div><div class="line"></div><div class="line"><span class="keyword">int</span> turn;<span class="comment">//轮到进程编号</span></div><div class="line"><span class="keyword">int</span> interested[N];个各进程是不是想去临界区，是不是已经在临界区</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">enter_region</span><span class="params">(<span class="keyword">int</span> process)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> other;<span class="comment">//在临界区的</span></div><div class="line">    other=<span class="number">1</span>-process;</div><div class="line">    interested[process]=TRUE;<span class="comment">//我想进去l临界区</span></div><div class="line">    turn=other;<span class="comment">//</span></div><div class="line">    <span class="keyword">while</span>(turn==other &amp;&amp; interested[other]==TRUE);<span class="comment">//</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">leave_region</span><span class="params">(<span class="keyword">int</span> process)</span></span>&#123;</div><div class="line">    interested[process]=FALSE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行到while处可能会挂起。</p>
<p>怎么使用呢？在每个进程进入临界区之前调用critical_region，退出之后调用leave_region。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/88550095.jpg" alt=""></p>
<p><strong>扩展到N个线程的互斥filter算法</strong>：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/67570267.jpg" alt=""></p>
<h4 id="TSL"><a href="#TSL" class="headerlink" title="TSL"></a>TSL</h4><p>指令：TSL RX LOCK</p>
<p>将lock给rx然后往lock中存一个非0值：保证原子操作，锁内存总线。</p>
<p>代码：<br>    enter_region:<br>        TSL REGISTER , LOCK//原值在寄存器，新值在内存<br>        CMP REGISTER,#0<br>        JNE enter_region<br>        RET//原来是0，可以进去了<br>    leave_region:<br>        MOVE LOCK , #0<br>        RET</p>
<p>一个可以代替tsl的是xchg（是不是很眼熟！）<br>xchg完成的操作是交换两个位置的内容。</p>
<pre><code>enter_region:
    MOVE REGISTER,#1
    XCHG REGISTER,LOCK
    CMP REGISTER,#0
    JNE enter_region
    RET
leave_region:
    MOVE LOCK, #0
    RET
</code></pre><p>锁是一个抽象的数据结构，有方法Acquire与Release。</p>
<p>在获取所的时候，如果锁目前被别人拥有，就等待。<br>释放锁的时候，通知那些等待的进程你们等的锁到了。</p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>使用TSL实现自旋锁：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Lock::Acquire()&#123;</div><div class="line">    <span class="keyword">while</span>(test-<span class="keyword">and</span>-<span class="built_in">set</span>(value));</div><div class="line">&#125;</div><div class="line">Lock::Release()&#123;</div><div class="line">    value=<span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Acquire:不停地区获取锁的值并将锁的值赋为1，直到锁的值变为0。（说明有进程从临界区出来了）</p>
<p>忙等待确实可以解决2个进程之间互斥运行的问题，但是缺点也很多，浪费CPU时间，编程困难，可能会造成优先级错乱。</p>
<h4 id="无忙等待锁"><a href="#无忙等待锁" class="headerlink" title="无忙等待锁"></a>无忙等待锁</h4><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/30861938.jpg" alt=""></p>
<h3 id="睡眠与唤醒"><a href="#睡眠与唤醒" class="headerlink" title="睡眠与唤醒"></a>睡眠与唤醒</h3><p>进程间通信<strong>原语</strong>，在无法进入临界区的时候进入阻塞状态而不是忙等待。</p>
<p>当一个进程发现自己不能进入临界区的时候，就系统调用sleep，阻塞去。另一个进程要离开临界区，就调用wakeup将她唤醒。<br>sleep\wakeup(pid);</p>
<h4 id="简单睡眠唤醒机制"><a href="#简单睡眠唤醒机制" class="headerlink" title="简单睡眠唤醒机制"></a>简单睡眠唤醒机制</h4><p>正如上述。</p>
<p>悲惨的是，假如wakeup信号丢失了，没有被唤醒的进程还在阻塞，假如剩余一个进程进入临界区需要该进程的作用，就都阻塞。</p>
<p>对MCPU不支持：使用进程号。</p>
<p>终于，现在可以考虑一下生产者消费者的解决了：</p>
<p>略。可见书或PPT</p>
<p>这是失败的解决，可能会导致wakeup信号丢失结果二人都去阻塞。</p>
<h3 id="信号量解决"><a href="#信号量解决" class="headerlink" title="信号量解决"></a>信号量解决</h3><p>P-&gt;down V-&gt;up</p>
<p><strong>信号量</strong>：一种新的变量类型，表示唤醒操作剩余次数。（所有相关线程引起的总竞争条件检查次数）<br><strong>信号</strong>是一个抽象数据类型，由一个整形变量与两个原子操作组成。</p>
<p>down：对某个信号量down是检查他的value，如果不是0，就减一，如果是0就去sleep。<br>up：对某个信号量的值加1。如果睡眠，就唤醒。</p>
<p>信号量是被保护的，在初始化完成之后，只能通过pv修改，而pv操作是被保证的原子操作。</p>
<p>通常嘉定信号量是公平的，也就是说不会一直被阻塞在p操作。（假设先进先出）</p>
<p>信号量的实现与前面说到的无忙等待锁很像：<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/30861938.jpg" alt=""><br>其实block也相当于被调度了。<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/8720151.jpg" alt=""></p>
<p>区别在于前面说的无忙等待锁并不是原子性的。</p>
<p><strong>解决方案</strong>：<br>每一个临界区设置一个信号量对象，初值是1代表初始时可以进入一个到临界区去。<br>p在进入之前，v在进入之后。必须成对出现。</p>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>同步可能会被调度序列打乱。（？）</p>
<p>同步与互斥的区别：</p>
<ol>
<li>互斥值放值其他进程进入cr</li>
<li>同步是指实现一个合理的逻辑序列</li>
</ol>
<p>whats this<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/11688740.jpg" alt=""></p>
<h4 id="ipc问题分析——使用信号量解决生产者消费者问题"><a href="#ipc问题分析——使用信号量解决生产者消费者问题" class="headerlink" title="ipc问题分析——使用信号量解决生产者消费者问题"></a>ipc问题分析——使用信号量解决生产者消费者问题</h4><p>1.ipc问题产生 原因：</p>
<ol>
<li>物理序列依赖于调度</li>
<li>逻辑序列依赖应用层需的意愿</li>
<li>竞争条件排斥资源获取</li>
</ol>
<p>在内核态以及用户态都有ipc问题，在内核态是io设备的管理，在用户态是网络应用、数据库等的管理。</p>
<p>ipc问题的关键在于：</p>
<ol>
<li>理解逻辑与物理序列  </li>
<li>逻辑序列依赖于调度</li>
<li>逻辑序列可以被用户控制</li>
</ol>
<p>whats that…..</p>
<p>使用信号量可以实现条件同步。</p>
<p><strong>生产者消费者问题</strong>：<br>一共需要三个信号量：mutex\full\empty。<br>首先，buffer是一个临界区，无论核心进入临界区出来临界区都需要一个信号量，其次，当buffer满的时候（N），生产者不可以进去buffer，需要消费者消费之后up才能进，消费者同理。<br>我认为，后两者实际上是在利用信号量的特点完成程序的逻辑部分，而不仅仅是对临界区的进入控制。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/97276693.jpg" alt=""></p>
<h4 id="monitor-solution"><a href="#monitor-solution" class="headerlink" title="monitor solution"></a>monitor solution</h4><p>信号量的一个缺点是对编程者来说不好写出代码。</p>
<p>monitor（管程）是一对过程、变量、数据结构的集合，（可以被看作是编译器），他们组成一个特殊的模块或软件包</p>
<p>应用：任意时刻管程中只能有一个活跃进程（有效完成互斥）<br>wait and signal：就像pv、du一样<br>不足：只有很少的语言支持。</p>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>组成：一个锁（管程代码互斥）、0或多个条件变量（管理共享数据的并发访问）</p>
<p>进入管程时的互斥由编译器完成</p>
<p><strong>条件变量</strong>：（像是信号量一样的东西）是管程内的的等待机制，允许在进程无法继续运行的时候被阻塞。<br><strong>wait</strong>：无法继续运行时调用，将自己阻塞并掉一个互斥访问进管程<br><strong>signal</strong>：指示一个呼哧进程开始运行，自己退出管程。</p>
<p>wait与signal很像是在之前的sleep与wakeup。但是关键的区别是，这里管程保证了互斥，不允许在wait之前切换进程进入管程。（其实存疑）</p>
<h4 id="条件变量实现"><a href="#条件变量实现" class="headerlink" title="条件变量实现"></a>条件变量实现</h4><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/49329583.jpg" alt=""></p>
<h4 id="管程解决生产者-消费者问题"><a href="#管程解决生产者-消费者问题" class="headerlink" title="管程解决生产者-消费者问题"></a>管程解决生产者-消费者问题</h4><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/21915703.jpg" alt=""></p>
<h4 id="hansen与hoare"><a href="#hansen与hoare" class="headerlink" title="hansen与hoare"></a>hansen与hoare</h4><p><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-15/51508560.jpg" alt=""></p>
<p>hansen主张signal只能是管程过程最后一个语句，二hoare则认为不一定，主张signal之后就应该自己阻塞让新的进程进入管程运行。</p>
<p>也是因为这样，，hansen的判断方式使用while而hoare判断使用if。</p>
<p><a href="http://www.cnblogs.com/xybaby/p/6516387.html" target="_blank" rel="external">并发与同步-xybaby</a></p>
<blockquote>
<p>同步互斥，就是在并发的前提下保证一些操作的原子性。</p>
</blockquote>
<h2 id="IPC问题：哲学家就餐"><a href="#IPC问题：哲学家就餐" class="headerlink" title="IPC问题：哲学家就餐"></a>IPC问题：哲学家就餐</h2><p><strong>对互斥访问有限资源的竞争建模</strong></p>
<blockquote>
<p>进程同步也是进程之间直接的制约关系，是为完成某种任务而建立的两个或多个线程，这个线程需要在某些位置上协调他们的工作次序而等待、传递信息所产生的制约关系。进程间的直接制约关系来源于他们之间的合作。</p>
<p>from：<a href="http://www.cnblogs.com/CareySon/archive/2012/04/14/Process-SynAndmutex.html" target="_blank" rel="external">浅谈进程同步与互斥的概念-宋沄剑</a></p>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>互斥：相邻哲学家只有一个人可以使用筷子</p>
<p>同步：</p>
<ol>
<li>想要进餐的哲学家应该拿到两个筷子</li>
<li>同一时刻至多有两个哲学家一同进餐</li>
<li>死锁与饥饿避免</li>
</ol>
<p>ppt</p>
<h2 id="IPC问题：读者与写者"><a href="#IPC问题：读者与写者" class="headerlink" title="IPC问题：读者与写者"></a>IPC问题：读者与写者</h2><p><strong>为数据库访问建模</strong></p>
<p>（会不会产生问题：在不是writer想要放弃的时候强迫writer放弃）——理解错误，<br>P：可不可以得到资源？可以，OK继续执行：不可以OK我去阻塞<br>这个“我”指的是“调用P的那个过程。</p>
<p>保证公平这个，concur是什么？是</p>
<p>##IPC问题：睡觉的理发师</p>
<h2 id="猴子过索桥"><a href="#猴子过索桥" class="headerlink" title="猴子过索桥"></a>猴子过索桥</h2><h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3>]]></content>
      
        <categories>
            
            <category> OS </category>
            
            <category> 课 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OS </tag>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JUnit之一]]></title>
      <url>/2017/11/05/JUnit%E4%B9%8B%E4%B8%80/</url>
      <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/ai92/article/details/302844" target="_blank" rel="external">这是一个简单的JUnit入门介绍</a>。</p>
<p>junit是一个测试框架，把一个java工程按照JUnit运行的时候会启动这些检测，但是这并不影响这个项目作为一个JAVA程序的本质。这个程序仍然可以以Java Application来运行。</p>
<h2 id="在eclipse中使用Junit4进行单元测试"><a href="#在eclipse中使用Junit4进行单元测试" class="headerlink" title="在eclipse中使用Junit4进行单元测试"></a>在eclipse中使用Junit4进行单元测试</h2><p>安装eclipse的时候，应该已经有了junit的jar包，如果没有，可以自己去<strong>maven仓库</strong>搜索下载。</p>
<p><a href="http://tech.sina.com.cn/s/2010-01-18/14081218926.shtml" target="_blank" rel="external">在eclipse中使用Junit4进行单元测试</a></p>
<p>为了方便，我会把上述的方法自己实践并写在下面：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/17569873.jpg" alt=""></p>
<p>不要直接finish。点击next，你将可以选择对哪些方法进行测试，eclipse就会自动帮你命名（which is very essential）</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/14409795.jpg" alt=""><br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/45619270.jpg" alt=""></p>
<p>看！</p>
]]></content>
      
        <categories>
            
            <category> 计算机网络 </category>
            
            <category> 实验室 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 实验室 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 模拟器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机网络番外三]]></title>
      <url>/2017/11/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%95%AA%E5%A4%963/</url>
      <content type="html"><![CDATA[<h1 id="第二次书面作业"><a href="#第二次书面作业" class="headerlink" title="第二次书面作业"></a>第二次书面作业</h1><ol>
<li>在目前的报文交换网络中（如Internet），主要采用存贮转发式交换。源主机通常将应用层较长的消息（例如，图像、视频等）分成小的报文段在网络中进行传输，接收端再将报文段组合成原始的消息，提交给应用层。下面我们给出了消息直接传输（不分报文段）和分成报文段传输的示意图，假设消息长度为8×106 bits，每条链路的传输速率为2Mbps，忽略传播延时、排队延时和处理时间。请回答下列问题：</li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-22/59555628.jpg" alt=""></p>
<p>1)    如图a所示，如果消息不进行分段直接进行传输，每台交换设备均采取存储转发式交换，请计算消息从源主机发出到目的主机完全接收所需的时间；</p>
<p>答：$t=3*8Mb/2Mbps=12s$</p>
<p>2)    如图b所示，如果消息被分成800个报文段进行传输（忽略各层的封装），每个报文段长10000 bits，请计算消息从源主机发出到目的主机完全接收所需的时间；</p>
<p>答：$t=3*10000/2M+799*10000/2M=802*0.01M/2M=4.01s$</p>
<p>3)    比较消息交换和报文交换的优缺点，除了传输延时方面的考虑，采用报文交换还有哪些其他方面的考虑？ </p>
<p>答：<br>消息交换省去了对分片数据进行处理合并的时间、减少了首部的数据传输，但是时延长，可能会长时间占用路由器的大量缓存空间。<br>报文交换大大减少了时延，同时由于数据的减少检错也变得更加容易，错误发生率减小，可靠性提升，但是需要额外传送首部数据，并且需要注意报文的顺序合并，还会带来排队时延。<br>采用报文交换除了对时延方面的考虑，还有对发送优先级以及数据可靠性的考虑。另外，过长的消息堵塞路由器可能导致其他消息不能及时送往目的地而带来一系列问题。</p>
<ol>
<li>发送者A和接收者B之间使用TCP协议进行通信（A发送数据，B回送ACK）。假设TCP连接建立之后A立即开始发送数据（第一个数据段随三次握手中的最后一个ACK一同发送，初始序列号为1）。链路带宽（传输速率）为100 Mbps，往返延迟RTT为10ms，MSS为1000字节，最初的拥塞窗口设成1个MSS，假设接收端有足够大的缓存空间，拥塞控制的初始阈值设为64。试回答下列问题：<br>1)    假设A缓冲区中有7000字节数据要向B发送，发送的每个数据段均包含1000字节数据，请画出A、B之间的交互过程，并计算所需的时间（从发起连接开始计算，要求给出计算过程）。</li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-22/23395607.jpg" alt=""></p>
<p>从图中可以看出：一共经过了4次RTT以及3段将数据报送出的时间，加上TCP/IP首部字节数认为是40，因此：<br>时间：$t=4*RTT+3*((40+1000)*8/100M)=40+0.2496ms=40.2496ms$</p>
<p>2)    快速重传机制是对TCP性能的优化，考虑第一问中的传输情况，如果传输过程中有数据段丢失，那么第几个数据段的丢失有可能触发A的快速重传？解释原因。</p>
<p>答：承载数据的第四（seq=3002）个：如果第一个数据包发生丢失，B不会发送ACK，将会因此超时引发慢启动；如果第二个丢失，只会发送一个冗余ACK，然后超时进入慢启动。如果第三个丢失，接下来可以连续发送2个报文段，由于第三个包无法被确认，只能回收两个冗余ACK。如果第四个丢失，5、6、7都正确到达，将会引起3个冗余ACK，会引发快速重传。五、六、七丢失都不能引发快速重传了。</p>
<p>3)    假设发送端发送一系列数据段（1、2、3……n），但A一直未收到任何确认（ACK），正常情况下，第一个数据段的重传定时器会首先超时，A将TCP的拥塞窗口设置成1个MSS，并重传第一个数据段。如果我们现在修改TCP协议，在上述情况下不重传第一个数据段，而改为发送第n+1个数据段，请你分析在什么情况下这种做法有利，在什么情况下不利。</p>
<p>答：如果接收方其实全部收到了包，只是发送方的定时器时间设置太短或是突然拥挤的网络导致包传输减缓，这时发送第n+1个数据段是有利的。因为这时前面数据段的ACK会相继到达，n+1包是最终一定会发送出去的包，因此所有工作都不是无用功；如果重传1包，那么在1包原本的ACK到达之后，这个被重传的包就是冗余包，将会被丢弃还会浪费资源。<br>在其他情况下，比如有部分包甚至全部包没有收到，这种机制似乎并不能有效地解决问题：比如有一个包x（0&lt;=x&lt;=n）未收到，这时无论重传多少次n+1包，最终可能收到的都是ACK=x，陷入无尽的循环。</p>
<h1 id="第三次书面作业"><a href="#第三次书面作业" class="headerlink" title="第三次书面作业"></a>第三次书面作业</h1>]]></content>
      
        <categories>
            
            <category> 计算机网络 </category>
            
            <category> 大三的课 </category>
            
            <category> 作业 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络课 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机网络应用层之番外二]]></title>
      <url>/2017/11/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82%E7%95%AA%E5%A4%96%E4%BA%8C/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>其实这里该是运输层番外….但是这是应用层作业啦。</p>
<p>多用户并发访问与可靠文件传输，不能有下载大小的限制。</p>
<p>为了用UDP实现多用户并发访问，一定是需要使用多个socket。仿照FTP的协议设计：使用一个UDP的socket在master进行监听，这个socket绑定一个确定的端口号，用户客户机连接服务器发请求使用。</p>
<p>考虑的请求比较小，可以使用一个包传送完成：</p>
<p>Server在端口号X进行监听。</p>
<p>将有一个N。<br>一个client要求连接，发送请求之后立即fork一个子进程，仍然使用这个socket，立即进入准备接收的状态。Server收到了，立即fork一个子线程，master继续监听，确保其他client的请求能被接收到。子线程新建一个UDP的socket，准备进行接收。由于UDP的不可靠，希望在传输数据的时候，Server应该首先，在fork出子线程之后立即对命令请求进行分析，告诉client一共要穿多少个包。（因为在n结束之后，client的子线程就会结束。如果不采用n结束子线程就结束，肯定需要有一个例如，里最后一个包recv之后多久end。这样应该是不太可靠的…对于server，需要有超时重传。emmmm</p>
<p>其实这样也行：</p>
<p>client子线程立即等待server传回的数据。同时启动一个定时器，如果超过了一定时间，反正也是同一个socket，就再重传，然后去等。</p>
<p>server呢，在子线程fork出之后就去分析命令，然后开始传包。每一个包有一个序列号。采用选择重传的机制进行文件信息的传输。当发送端的所有发出的包已经发送完毕并且所有的一发送包都得到回执确认之后，向接收端发送最终的发送完毕包。这个包在发送完之后，client接受到之后必须给ACK。server收到ACK之后才能关闭。</p>
<p>有状况：<br>如果client没接到信息或者信息错了，按照选择重传，不会有动作，server重传没毛病；如果client给的ACK丢了，server不能确定client已经收到，也会重传，所以client不可能在发送完ACK就关闭，而是影该等待server的回执，让server知道我已经知道我拿到完整的包了。一旦等到，立即关闭。<br>所以client这边对于最后一个包的动作是：recv-&gt;收到错报，不动，等重传/收到对的包，回复ACK同时启动一个超时重传机制，开始接收server的回执，不管接受到了什么，关闭。（因为这个时候server只要收到了client的东西就证明client肯定已经知道包已经传完了）<br>因为server最终只发送一次，如果client连着很多次超时重传都没有收到回应，很大可能已经server关闭了，为了不陷入无休止的重传，client关闭。</p>
<p>server的动作是-&gt;发送最后一个结束包-&gt;超时重传/接收到client的信息-&gt;发送一个ACK，关闭。</p>
<p>server也知道client这时server也已经关闭</p>
<h1 id="最终交付"><a href="#最终交付" class="headerlink" title="最终交付"></a>最终交付</h1><h2 id="计算机网络书面作业：网络协议设计"><a href="#计算机网络书面作业：网络协议设计" class="headerlink" title="  计算机网络书面作业：网络协议设计 "></a><center>  计算机网络书面作业：网络协议设计 </center></h2><center>yayi2456</center>

<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;本协议仿照了FTP协议以允许多客户机的并行操作，使用选择重传的方法在UDP的基础上进行一定程度的可靠性的保证与效率的保证，加入其他机制保证大文件的可靠传输。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;server端的主socket绑定一个端口号，进行对客户请求的监听。一旦监听到客户机的请求，立即fork一个子线程，在子线程中重新绑定一个socket，由这个socket与客户机进行通信。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;client端根据程序并行度可选择是否需要在子线程发出请求，这取决于不同的应用程序的动作，不做讨论。提到client的动作时，并不指定是在哪个进程。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>将该协议描述如下：</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;server监听端口A，一旦监听到client的请求，立即fork子线程。在子线程中对该请求进行分析，并决定需要发送给client的数据。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;client向server发送请求，并启动一个定时器，当超过一定时间仍未收到server传回的第一个包，client重新发送请求信息。使recvbase为0，收到第一个数据包之后，<code>recv=(recv+1)%(2*N)</code>，该定时器关闭。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>注</strong>：在server收到请求之后，并没有立即发送ACK通知client自己已经收到了请求。原因在于server最终一定会发送数据给client，只需要把第一个数据包作为server收到的确认信息即可，同时也减少了可靠性保证所花费的额外的时间。但是由于server对准备发送的数据需要做一定的处理，这个时延可能会稍长。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;server开始向client发送包。采用选择重传机制，server为每一个包附上一个<strong>序号</strong>，同时利用UDP头本身具有的checksum字段进行一定程度的检错判断。server每次最多传送N个报文段，协议中具有2*N个序号。初始时，发送缓冲区中的sendbase是0，server每传送一个报文段就会启动一个对应于该报文段的定时器，当某个报文段的定时器超时之后，server对该报文段进行重传；当server收到了某个序号的报文段的ACK之后，将该序号置为“已确认”，如果该序号是sendbase，那么将<code>sendbase=(sendbase+1)%(2*N)</code>，如果sendbase是“已确认”，再将<code>sendbase=(sendbase+1)%(2*N)</code>，直到sendbase是“已发送但未确认”或是“可用”。同时，当sendbase改变时，如果包尚未发送完，则可以使用新的“可用”来发送新的报文段。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;client接受到第一个数据包之后关闭第一个定时器，并向服务器发送对第一个数据包对应的序号的ACK，随后开始接收其他数据包，每接收到一个检验和没有错的数据包，返回一个对应该数据包序号的ACK包。无论是不是server端没有接收到上一个对应该序号的ACK，返回一个ACK，对于最大为2*N的空间来说，是没有问题的。对于在[recvbase,recvbase+N-1]空间中的序号对应的包加以解析送给应用层使用或者是缓存之后将对应的序号标为“接收已确认”，而另外的序号对应的数据包只返回ACK，对数据包直接丢弃。每次接收到一个被“接收已确认”的数据包，如果该数据包的序号是recvbase，<code>recv=(recv+1)%(2*N)</code>，如果这时recvbase对应序号仍是“接收已确认”，<code>recv=(recv+1)%(2*N)</code>，直到recvbase对应序号是“期待但未收到”或是“可用”。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在所有的有用数据包传送完成之后，server需要告知client，有用的数据已经传送完了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;场景分析如下：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;当server的所有发出的包已经发送完毕并且所有的已发送包都得到回执ACK之后，向client发送最终的发送完毕包。这个包在发送完之后，client接收到之后必须给ACK。server收到ACK之后才能关闭，否则可能导致client不知道自己已经拿到完整的数据而陷入空转。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;如果client没接到最终包信息或者信息错了，按照选择重传，client不会有动作，server等待超时之后重传；如果client回复的ACK丢了，server不能确定client已经收到，必须重传来确认client已经知道自己可以关闭连接了，所以client不可能在发送完ACK就关闭，而是该等待server的回执，让server知道client已经知道client拿到完整的包了，否则可能会使server陷入无尽的重传。一旦等到server的回执，client立即关闭。若许久都未等到回执，关闭。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;下面对最后的动作进行描述：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;server的动作是：发送最后一个结束包，启动定时器，若超时则进行重传；直到接收到client的信息之后，关闭定时器，server发送一个ACK，立即关闭。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;client最终的动作是：等待接收数据，如果收到错误的包，等重传；如果收到对的包，回复ACK同时启动一个定时器，启动超时重传机制，并开始接收server的回执，不管接受到了什么，关闭。若超时一定次数之后仍未接收到server的回执，因为server最终只发送一次，如果client连着很多次超时重传都没有收到回应，很大可能已经server关闭了，为了不陷入无休止的重传，client关闭。</p>
<p>从宏观的角度来看，客户机与服务器的交互是：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-5/15535425.jpg" alt=""></p>
<p><strong>扩展FSM：</strong></p>
<p><strong>server：</strong></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-5/73814791.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-5/41957911.jpg" alt=""></p>
<p><strong>client：</strong></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-5/90929804.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 计算机网络 </category>
            
            <category> 大三的课 </category>
            
            <category> 作业 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络课 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[覆千秋1]]></title>
      <url>/2017/11/03/%E8%A6%86%E5%8D%83%E7%A7%8B1/</url>
      <content type="html"><![CDATA[<h1 id="夜色凉"><a href="#夜色凉" class="headerlink" title="夜色凉"></a>夜色凉</h1><p>将军府的海棠开了。</p>
<p>粉粉嫩嫩，一簇一簇的，细风吹来，花朵轻轻落在地上，把这个小园衬出几分诗意。</p>
<p>只是府上光景却不如这海棠繁盛。</p>
<a id="more"></a>
<p>前日里前线传回来消息，说是这宅院的主人被俘了。被俘了，是不要紧，要紧的是他帮着敌军截断了己方粮草，杀了一名副将。</p>
<p>皇帝知道之后龙颜大怒，直接下令封了将军府。<br>管你是真降还是假意。</p>
<p>大臣们都以为，功高盖主，老将军即使不降，回来也风光不了几日了，没差。</p>
<p>平民慷慨激昂，市面上的书里，茶馆里，甚至风月里都是对老将军叛国的不耻，这些模糊的面孔在舌灿莲花的时候，选择性的忘记了老将军当年战绩的辉煌。</p>
<hr>
<h2 id="当街月色应如水"><a href="#当街月色应如水" class="headerlink" title="当街月色应如水"></a>当街月色应如水</h2><p>“千霜——”，打扮精致的女人独自从廊中走来，在几步之外站定，唤。</p>
<p>坐在小亭中的女孩循着声音忽地回头，抬着脸叫：“娘——”。</p>
]]></content>
      
        <categories>
            
            <category> 我的故事 </category>
            
            <category> 枯骨流沙 </category>
            
            <category> 覆千秋 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 千霜 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机网络网络层]]></title>
      <url>/2017/11/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
      <content type="html"><![CDATA[<p># </p>
]]></content>
      
        <categories>
            
            <category> 计算机网络 </category>
            
            <category> 大三的课 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络课 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机网络运输层]]></title>
      <url>/2017/11/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/</url>
      <content type="html"><![CDATA[<blockquote>
<p>这些东西是很简单，可是想来想去还是决定记录一下，以免以后遇到像C++语法不知道一样的尴尬。</p>
</blockquote>
<h1 id="概述与运输层服务"><a href="#概述与运输层服务" class="headerlink" title="概述与运输层服务"></a>概述与运输层服务</h1><p>运输层的协议提供的是<strong>逻辑通信</strong>，并不是直接相连的。</p>
<p>现在我们聊的是<strong>对等层通信</strong>，本机的运输层发数据给其他机器的运输层。运输层协议在端系统里面，并不是在路由器里。</p>
<p>实际上，当应用程序希望能与其他设备进行通信，调用运输层，给运输层一堆信息。运输层可能会把这些信息分段，然后加上头部信息成为<strong>报文段</strong>。报文段交给网络层，网络层再封装成<strong>数据报</strong>再向目的地发送。到了目的地之后做一个相反的动作，送给应用层使用。需要区分清楚的是，制定目的地、决定报文段怎么产生、决定报文段如何合并都是运输层的工作，网络层相当于送信的邮差，只负责传输。但是话又说回来了，网络层更加底层，网络层提供了怎样的服务、有多大的带宽都限制了运输层的服务。</p>
<p>现在<strong>因特网</strong>的运输层主要有两个协议：UDP、TCP。UDP是不可靠的、多目的地的、无序的传输；TCP是面向连接的可靠的传输。具体特性将在后面讲到。</p>
<p>因特网的网络层协议是IP协议（网际协议）。IP非常不可靠，他是<strong>尽力而为交付服务</strong>，一不确保报文段的交付，二不保证报文段交付的按序，三不保证报文段交付的完整性，被称为<strong>不可靠服务</strong>。</p>
<p>TCP与UDP的基本职责是将两个端系统之间的IP交付服务扩展为运行在两个端系统之上的两个进程之间的信息交付服务。将主机之间的交付扩展为进程之间的交付就是<strong>运输层的多路复用与多路分解</strong>。</p>
<h1 id="运输层的多路复用与多路分解"><a href="#运输层的多路复用与多路分解" class="headerlink" title="运输层的多路复用与多路分解"></a>运输层的多路复用与多路分解</h1><p>多路复用与多路分解服务是所有计算机网络都需要的。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/43018259.jpg" alt="复用与分解机制"></p>
<p>我们知道，实现运输层的服务需要借助于socket，一个进程可以对应一个或几个socket（？）。在send端，运输层在报文段中加了首部信息之后，把各进程产生的数据无差别的交给网络层；在rev端，运输层从网络层那里拿出数据，解析报文段的首部信息从而==定位socket==，把<strong>分解后的</strong>报文段信息给对应的socket。</p>
<p>为了实现这种服务，在首部信息里面一定封装有<strong>端口号</strong>。<br>端口号是一个16bit的数，在0-65535之间，其中0-1023的端口号是周知端口号，他们被保留给周知应用层协议来使用。一般来说，服务器端都是一个固定的端口号，而客户端则是随机分配。<br>关于端口号的更多信息，可以访问<a href="http://www.iana.org" target="_blank" rel="external">RFC 3232</a>获得。</p>
<h2 id="1-无连接的"><a href="#1-无连接的" class="headerlink" title="1. 无连接的"></a>1. 无连接的</h2><p>首先了解UDP的套接字标志方法：UDP的socket以一个二元组(dstaddr,dstport)来标识，与源信息无关。也就是说，虽与一个机器无论是从什么地方发送过来的数据，只要给的是同一个port，都将被同一个socket处理。这样，容易理解，在UDP中，每一个port会对应一个自己的缓冲区。</p>
<p>关于这个缓冲区，<del>UDP不可靠也会体现在这里</del>，在发送UDP包的时候不能过大，也是出于对缓冲区大小的考虑。如果新到来的包太大了、不能塞进缓冲区了，这个包会被直接抛弃。app层不会知道，只有通过发送端的超时重传机制对包进行重传。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/79842537.jpg" alt="UDP复用与分解机制"></p>
<h2 id="2-面向连接的"><a href="#2-面向连接的" class="headerlink" title="2. 面向连接的"></a>2. 面向连接的</h2><p>TCP的套接字标志方法与UDP不同，TCO使用(srcaddr,srcport,dstaddr,dstport)，这样，只有四个值都相同才会被定向到同一个socket，放到同一个缓冲区。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/6848958.jpg" alt="TCP复用与分解机制"></p>
<blockquote>
<p>这里只是简单一提：关于安全性的问题。攻击者可以利用在某个端口监听的有缺陷的应用程序攻陷目的主机。我不了解安全，这里只是复述了《自顶向下方法》中的解释。</p>
<p>使用<a href="http://nmap.org" target="_blank" rel="external">nmap</a>既可以扫描到<strong>因特网</strong>中任一台主机，顺序的扫描主机的各个端口，对TCP/UDP，寻找能接收TCP连接/能对UDP报文段进行处理的端口号，并返回打开的、关闭的、不可达的端口号列表。</p>
</blockquote>
<h2 id="3-Web-Server与TCP"><a href="#3-Web-Server与TCP" class="headerlink" title="3. Web Server与TCP"></a>3. Web Server与TCP</h2><p>其实没什么新东西，列举：</p>
<ol>
<li><p>连接套接字与进程之间并非一一对应的关系。先进的高性能Web server只有一个进程，但是为每一个连接的<strong>新客户</strong>（不是客户机喔）创建一个新的线程。</p>
</li>
<li><p>非持续HTTP会严重影响web server的性能。（在应用层中涉及），有些OS技巧可以减轻这个问题的影响。（参见[Nielsen 1997,Nahum 2002]）</p>
</li>
</ol>
<p>他的复用与分解是这样的：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/41975538.jpg" alt="Web"></p>
<h1 id="UDP概述"><a href="#UDP概述" class="headerlink" title="UDP概述"></a>UDP概述</h1><p>UDP很弱，除了上一节提到的复用分解机制以及少量的差错检验之外，基本没有功能了，如果程序员选择了UDP，那基本上就是在与IP打交道了。</p>
<blockquote>
<p>以一个DNS查询为例：应用层给出了一个查询报文交给运输层，UDP加了首部段，交给网络层，网络层将他封装进一个IP数据报，发送给一个名字服务器。DNS如果没有收到对方的回应，要么向另一个服务器发送请求，要么告知调用它的应用程序没有响应。</p>
</blockquote>
<h2 id="1-UDP特点"><a href="#1-UDP特点" class="headerlink" title="1. UDP特点"></a>1. UDP特点</h2><ul>
<li><p>无连接：</p>
<ol>
<li>两个UDP之间没有握手；</li>
<li>UDP报文段彼此独立</li>
</ol>
</li>
<li><p>不可靠：</p>
<ol>
<li>没有确认接收；</li>
<li>没有重传；</li>
<li>没有检查包丢失与包失序</li>
<li>检验和只覆盖部分信息</li>
<li>没有拥塞控制</li>
</ol>
</li>
</ul>
<p>UDP很弱，为什么不使用更加可靠的TCP呢？</p>
<ol>
<li><p>关于何时发送什么样的数据的控制更为精细。UDP是只要应用层交付，UDP就立即给网络层，而TCP有一个拥塞控制机制，可能会遏制发送方，是数据传输变得缓慢。</p>
</li>
<li><p>无需建立连接，减少时延。</p>
</li>
<li><p>无连接状态，不需要维护连接状态。连接状态包括接收和发送数据缓存、拥塞控制参数、序号以及确认号的参数等。某些应用程序运行在UDP之上可以支持更多的活跃用户。</p>
</li>
<li><p>分组首部开销小</p>
</li>
</ol>
<p>UDP的这些特点使得：</p>
<ol>
<li>DNS简单查询；</li>
<li>流媒体应用；</li>
<li>P2P应用</li>
<li>网络管理应用：通产工作在高压状态之下；</li>
<li>路由转换协议</li>
</ol>
<p>等将有更佳的适用度。</p>
<blockquote>
<p>现今，由于出于安全考虑，某些机构阻塞UDP流量，而且当丢包率低时，TCP将更多的用于流媒体应用。</p>
<p>然而，由于UDP没有拥塞控制机制，当网络繁忙时，路由器会有大量的分组溢出，几乎没有UDP分组能够成功通过路由器到达目的地。而且，具有拥塞控制机制的TCP发送方会减慢自己的速率。UDP没有拥塞控制机制不仅造成了UDP会话之间的高丢包率，也挤垮了TCP会话。很多研究人员已经提出了新的机制，使所有数据源执行自适应的拥塞控制。</p>
<p>希望使用UDP实现可靠传输的话需要在应用层协议上加上可靠性保证。这种方法既可以保证可靠传输，又可以拒绝拥塞控制的影响。</p>
</blockquote>
<p>表1：流行的因特网应用及其下协议</p>
<table>
<thead>
<tr>
<th>应用</th>
<th>应用层协议</th>
<th>下层运输协议</th>
</tr>
</thead>
<tbody>
<tr>
<td>电子邮件</td>
<td>SMTP</td>
<td>TCP</td>
</tr>
<tr>
<td>远程终端访问</td>
<td>Talnet</td>
<td>TCP</td>
</tr>
<tr>
<td>Web</td>
<td>HTTP</td>
<td>TCP</td>
</tr>
<tr>
<td>文件传输</td>
<td>FTP</td>
<td>TCP</td>
</tr>
<tr>
<td>远程文件服务器</td>
<td>NFS</td>
<td>通常UDP</td>
</tr>
<tr>
<td>流式多媒体</td>
<td>通常专用</td>
<td>UDP或TCP</td>
</tr>
<tr>
<td>因特网电话</td>
<td>通常专用</td>
<td>UDP或TCP</td>
</tr>
<tr>
<td>网络管理</td>
<td>SNMP</td>
<td>通常UDP</td>
</tr>
<tr>
<td>路由选择协议</td>
<td>RIP</td>
<td>通常UDP</td>
</tr>
<tr>
<td>名字转换</td>
<td>DNS</td>
<td>通常UDP</td>
</tr>
</tbody>
</table>
<h2 id="2-UDP报文"><a href="#2-UDP报文" class="headerlink" title="2. UDP报文"></a>2. UDP报文</h2><p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/9685377.jpg" alt="UDP头信息"></p>
<p>长度：指明了包括首部信息在内的UDP报文段长度（单位：字节：Byte）；</p>
<p>下面重点说<strong>检验和</strong>：</p>
<p>在计组里面就学了几个检错方法，对于一个检错机制：数据=冗余位  实际数据。决定检错能力的是冗余位数与算法。对于UDP，他提供的是一个很简单的检错机制，而且只能检错，不能修改错误。</p>
<h3 id="Persudo-Header"><a href="#Persudo-Header" class="headerlink" title="Persudo Header"></a>Persudo Header</h3><p>persudo header结构是这样的：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/92376358.jpg" alt=""></p>
<p>在发送端，首先会将报文段中的checksum清零，然后把报文段与persudo header的数据当作16bit的很多数据，对他们进行求和运算，将得出的16bit结果求反给checksum字段。</p>
<p>在接收端，产生新的伪首部，然后只需要将这些数据全部求和，最终如果是16个1，说明<strong>可能</strong>是没错的，但是也可能<strong>发生的错误已经超出了检错能力</strong>，如果不是16个1，那说明一定是错了。</p>
<p>checksum有什么用呢？对于明确错误的信息，UDP会要么丢弃；要么把数据给应用层，但是给应用层警告说数据是错的。</p>
<blockquote>
<p>其实伪首部破坏了分层结构，在运输层产生了网络层的信息。</p>
<p>UDP校验和覆盖的范围超出了UDP数据报本身，使用伪首部的目的是检验UDP数据报是否真正到达目的地，正确的目的地包括了特定的主机和该主机上特定的端口</p>
<p>checksum机制在ipv4下是可选的，但是在ipv6下是必须的。</p>
</blockquote>
<p>在checksum中看到了<strong>端对端原则</strong>。端对端原则是一个被受赞扬的原则，该原则表述为某种功能必须基于端对端实现：”与在较高级别提供这些功能的代价相比，在较低级别上设置的功能可能是冗余或几乎没有价值的。“<br>在这里，由于不能保证从网络到物理到链路都有有效的检错机制，甚至在某些路由器的内存中也可能引入比特差错，实现端对端的错误检测机制是有必要的。</p>
<h1 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h1><p>在这一节里，将所有的底层数据传输视为不可靠的，可能会发生数据的丢失、差错、失序等。</p>
<p>这里讨论的是普遍的计算机网络使用的理论，将以<strong>分组</strong>代替<strong>报文段</strong>被使用。同时，只考虑<strong>单向数据传输</strong>，其实<strong>双向数据传输</strong>并不会更难。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/10707246.jpg" alt=""></p>
<h2 id="构造可靠数据传输协议"><a href="#构造可靠数据传输协议" class="headerlink" title="构造可靠数据传输协议"></a>构造可靠数据传输协议</h2><h3 id="rdt1-0：信道完全可靠"><a href="#rdt1-0：信道完全可靠" class="headerlink" title="rdt1.0：信道完全可靠"></a>rdt1.0：信道完全可靠</h3><p>假如信道完全可靠，UDP完全可靠。发送方只要接收到rdt_send就做处理并调用udp_send，接收方只要接收到rdt_rcv就处理。有限状态机（FSM）图如下：</p>
<p>发送端：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/67644025.jpg" alt=""></p>
<p>接收端：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/29594625.jpg" alt=""></p>
<h3 id="rdt2-0：信道具有比特差错"><a href="#rdt2-0：信道具有比特差错" class="headerlink" title="rdt2.0：信道具有比特差错"></a>rdt2.0：信道具有比特差错</h3><p><strong>自动重传请求</strong>（Automatic Repeat reQuest）：在接收方确认接收到正确的报文之后给出<strong>肯定确认</strong>，接受到不正确的报文之后给出<strong>否定确认</strong>。</p>
<p>实际上，这种机制需要其他的支持：</p>
<ol>
<li>差错检测</li>
<li>接收方反馈：如果正确，返回ACK，不正确返回NAK。</li>
<li>重传：发送方在接收到NAK时重传。</li>
</ol>
<p>FSM：</p>
<p>发送方：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/62528979.jpg" alt=""></p>
<p>接收方：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/18789362.jpg" alt=""></p>
<p>但是，如果ACK或者NCK的包错误了怎么办呢？<br>一般有三种解决方法：</p>
<ol>
<li>发送请求，询问上一个差错包的内容。这样很容易陷入询问的死循环。</li>
<li>增加足够的检错纠错能力。导致冗余数据过多。</li>
<li>直接重传。可能会引入冗余分组，使得接收方不知道这个包是新包还是重传包。</li>
</ol>
<p>对于第三种方法，可以引入<strong>序列号</strong>的概念来解决问题。对于我们现在讨论的停等协议，只需要两个序号即1bit即可。</p>
<p>这个版本是<strong>rdt2.1</strong>，新的FSM是这样的：</p>
<p>发送方：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/35627137.jpg" alt=""></p>
<p>接收方：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/21016547.jpg" alt=""></p>
<p>其实，如果不使用NAK，而是对上次的接收再发送一个ACK，也能起到同样的效果，这样，有了<strong>rdt2.2</strong>版本：</p>
<p>发送方：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/79622017.jpg" alt=""></p>
<p>接收方：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/43136886.jpg" alt=""></p>
<h3 id="比特交替协议——rdt3-0：信道可能丢包、产生比特差错"><a href="#比特交替协议——rdt3-0：信道可能丢包、产生比特差错" class="headerlink" title="比特交替协议——rdt3.0：信道可能丢包、产生比特差错"></a>比特交替协议——rdt3.0：信道可能丢包、产生比特差错</h3><p>如果产生了丢包，接收端是不会知道的，只能在发送端处理这个问题。一个是发送端主动发送的数据丢失，和接收端没有关系，一个是接收端已经收到了包，但是发送的确认信息丢失。</p>
<p>发送方需要<strong>重传</strong>，应该做到：</p>
<ol>
<li>每次发送数据之后启动一个定时器</li>
<li>响应定时器中断</li>
<li>停止定时器</li>
</ol>
<p>在重传中，延时时间的设置是很重要的。过长的延迟时间将影响应用层的体验，果断的延迟时间将会引入<strong>冗余数据分组</strong>。rdt2.2已经有能力处理冗余数据分组：当在等待1的时候又传来了0，接收端会直接丢弃这些数据。而对于停等协议，不会有在等1的时候正好发送了1的冗余包的情况。</p>
<p>发送方：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/29153183.jpg" alt=""></p>
<h2 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h2><p>rdt3.0对于错误处理已经比较完善了，但是他的问题在于他是一个停等协议。停等协议对链路的利用率低到令人发指！</p>
<blockquote>
<p>对于一个速度是1Gbps的链路，发送一个大小1000Byte的包：</p>
<p>进入所需时间：$$t=\frac{L}{R}=\frac{8000bit/pkt}{10^9bit/s}=8us/pkt$$</p>
<p>假设传输所需时间是15ms，那么信道的利用率是：</p>
<p>$$U_sender=\frac{\frac{L}{R}}{RTT+\frac{L}{R}}=\frac{0.008}{30.008}=0.00027$$</p>
</blockquote>
<p>为了提高传输效率，停等协议需要被摒弃。现在使用的技术被称为<strong>流水线</strong>。<br>使用流水线技术，1个bit的序号是不够用的，在后面我们将讲到对于n个同时发出的包，需要2*n个序列号。而且，在发送端和接收端都需要有缓存机制来暂时存储：发送端需要存储已经发送但是没有确认接收的数据，接收端需要存储已经正确接收的数据。</p>
<p>这一节并没有完整的讨论流水线机制下的协议，从下一小节开始，对缓存的处理、序列号的处理进行讨论。</p>
<h2 id="回退N步：GBN"><a href="#回退N步：GBN" class="headerlink" title="回退N步：GBN"></a>回退N步：GBN</h2><p>允许发送方连续发送N个数据包，接收方按序接收数据包，失序的包会被丢弃。（这时由于没有考虑双向传输，而且接收端的机制，在接收端的结构暂且不提）</p>
<p>在发送方将会有一个缓冲区，把结构抽象成这样：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/82326531.jpg" alt=""></p>
<p>在这次传输的过程中只能使用[send_base,sendbase+N-1]之间的序号。扩展FSM如图：</p>
<p>发送端：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/56361901.jpg" alt=""></p>
<p>接收端：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/32672336.jpg" alt=""></p>
<p>在这个FSM中存在变量，初始化是需要的。<br>在发送端，当上层请求发送数据时，有一个判断：如果还可以继续发送（nextseqnum&lt; base+N），就继续发送，如果在发送这个之前所有的包都已经被确认过了，就需要开一个定时器，<strong>从这里可以看出：计时器以最左边界启动</strong>。如果不能再发送了，拒绝发送数据。这时可能有三种处理方式：将该数据返回给上层，隐含地表示已经不能再传了；缓存这些数据；使用同步机制只允许上层在窗口不满的时候才能调用rdt_send。<br>数据发送出去之后，如果按时接收到了一个ACK，比如说是ACK(i)，那么说明从base到i都已经被确认了。假如这时已经没有未确认包了，计时器停止，否则，重新为新的最左包启动一个定时器。<br>如果ACK损坏了，什么也不做。因为有定时装置，只需等待重传。这与rdt3.0的机制是相同的。<br>好了，timeout了，将现在所有的未确认全部重传，然后重启定时器。</p>
<p>在接收端，同样初始化。<br>接收端只会等待需要等待的按序的包，如果不是按序的，不予接收，并将上一个确认信息给发送方。类似于rdt2.0的处理方式。发送方收到的这个包并不会对发送方有什么影响，只是由于timer不能被停止或重启，一定时间之后便会触发重传。但是对于那些ACK丢失的包有重大意义：推动sendbase向前。<br>如果接受端收到了一个按序的、在检错能力之内没有错误的包，才对他进行处理，更新自己的期望包序号，并向发送方发出自己的确认信息。</p>
<p>这种方式的弊端在于失序数据的丢弃。</p>
<p>假如发送方一口气发送了N个包，恰巧第一个包坏了，其他都好的，由于接收端拒绝接受第一个坏的包，其他包也被丢弃了，只能重传所有的N个包。<br><del>或者，其实这N个包都好好的到了接收端，接收端返回了N个确认包。</del> emmm其实这里做的比较好，因为反回了N就代表N以及以前的都已经收到了。</p>
<p><a href="https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/go-back-n-protocol/index.html" target="_blank" rel="external">Go-Back-N动画</a></p>
<h2 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h2><p>对上一小节最后提出的回退N步的弊端，在选择重传之中得到了解决。但是应该知道，功能的增强需要结构的复杂作为代价。</p>
<p>允许失序，接收方会对一些失序的包进行缓存。这样，确认接收的机制也需要进行修改、接收方也需要拥有一个缓存区来实现。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/94806677.jpg" alt=""></p>
<p>在这种方式中，其实在上一节最后说的那点优点是不可能存在了，因为需要选择重传，必然是选择确认。而且，每个分组都必须有自己的定时器，而不能像上面一样按最左来做定时器。</p>
<p>在发送端，base只能移动到没有已发送但未确认的最右。对于上图，发送端的绿色必定对应接收端的粉色或者无色，接收端的灰色必定对应发送端的黄色，在sendbase右边不可能有对应接收端灰色的色块。</p>
<p>发送方的动作与前面类似，只是需要将确认机制修改成单独确认，接收方的动作如下：</p>
<ol>
<li>如果收到了[recvbase,recvbase+N-1]内的包，是正常的，把收到的包的对应序号ACK，如果在这之内的某个包出了问题不用管，丢掉。如果等于recvbase了，就更新recvbase。（这也使得2.是必要的）</li>
<li>收到了[recvbase-N,recvbase-1]之内的包，可能是这之内的包已经被接收端ACK了，但是没有被发送端ACK，一定需要传一个ACK包给发送端，否则会使得sendbase无法前进。</li>
<li>其他情况忽略即可。</li>
</ol>
<p>情况2.也说明了为什么需要2*N个序号：</p>
<p>尴尬的情况：究竟是重复包还是新包？<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/59249922.jpg" alt=""></p>
<blockquote>
<p>在书中提到了<strong>分组重排</strong>，我不是十分理解：</p>
<p>分组重拍的一个表现是具有确认号x的旧副本可能会在网络中出现，即使现在发送端与接收端的窗口中可能都包含x。对于分组重排，信道可被基本看成是在缓存分组，并在将来的任意时刻自然地释放这些分组。因为序列号要被重用，所以这种情况要十分小心。<br>实际采用的一个方法是直到发送方确认网络中不会在存在x分组。这通过设置一个分组在网络中的最大存活时间来限定。<br>在高速网络的TCP扩展中，一般是3min。<br>[sunshine 1978]描述了一种使用序号的方法，可以使重新排序问题完全被避免。</p>
</blockquote>
<p><a href="https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html" target="_blank" rel="external">Selective Repeat动画</a></p>
<p>这些都搞清楚了之后，<strong>TCP</strong>隆重登场~</p>
<h1 id="TCP：Transport-Control-Protocol"><a href="#TCP：Transport-Control-Protocol" class="headerlink" title="TCP：Transport Control Protocol"></a>TCP：Transport Control Protocol</h1><p>TCP是面向连接的协议，这是因为TCP在传输数据之前需要进行三次“握手”，它传输的是<strong>字节流</strong>，也就是收TCP并不管传输内容的有意义的分割，只是够了可以出发的字节数（或者不够，这是其他的机制）就会将这个报文段发出，这就要求了接受的数据必须能够按序排列好。</p>
<p>TCP的传输有以下特点：</p>
<ol>
<li>流量控制</li>
<li>拥塞控制</li>
<li>点对点</li>
<li>全双工服务</li>
<li>流水线机制</li>
</ol>
<p>TCP称得上是最复杂的协议之一，由于TCP的底层是IP协议，而上面已经提到IP协议是“尽力而为”服务，几乎没有可靠性的保证，我们只能假设底层是完全不可靠的服务，由此构建出了TCP协议。</p>
<h2 id="基本概念介绍"><a href="#基本概念介绍" class="headerlink" title="基本概念介绍"></a>基本概念介绍</h2><p>TCP连接并不是一条实际的连接或是一条虚电路，所谓的TCP连接只是存储在端到端系统中的连接状态，而路由器、链路层交换机对TCP连接完全视而不见，他们看到的只是数据报。</p>
<p><strong>全双工服务</strong>（full-dumplex service）：指的是只能AB之间互相传输，是<strong>点对点</strong>，不可能有第三者加入的情况出现。与<strong>多播</strong>有明显不同。</p>
<p><strong>客户进程</strong>：发起连接的进程；<strong>服务器进程</strong>：接收连接的进程</p>
<p><strong>三次握手</strong>：客户首先发一条特殊报文，服务器用另一个特殊报文来响应，最后客户用第三个特殊报文响应。$\color{red}{前两个报文不承载有效载荷，而最后一个可以有}$</p>
<p>当app层给运输层TCP一些数据，会被放入<strong>发送缓存</strong>里，<strong>在TCP方便的时候</strong>，就会从缓存中拿出一些数据发送。</p>
<p><strong>最大报文段长度MSS</strong>（Max Segment Size）常根据<strong>最大传输单元</strong>设置，典型值是1460<strong>字节</strong>。注意不包括各种首部，只包括应用层数据大小。TCP/IP首部一般是40bytes。</p>
<p><strong>最大传输单元MTU</strong>（Max Transmission Unit）：本地主机发送的最大链路层帧长度</p>
<p><strong>TCP报文段</strong>：TCP将这次要发送的数据用一个TCP首部进行封装。</p>
<p>就像前面说到的，MSS限制了TCP报文段的最大长度。当一个大文件被发送的时候，它将被分为许多长度为MSS的报文段发出。<br>另一方面，对于那些不需要传递大量数据的交互应用，也可以发送较小的数据段。<br>那么什么叫<strong>TCP方便的时候</strong>呢？一般来说，TCP会在三种情况下发送数据：</p>
<ol>
<li>segment full</li>
<li>超时</li>
<li>app层的push</li>
</ol>
<p><a href="https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/flow-control/index.html" target="_blank" rel="external">发送与接收动画</a></p>
<p>个人觉得（未经过资料查证，只是陈述想法），TCP连接就只是一种连接状态：recv与send都知道对方时刻准备着接受自己的数据，自己发出的数据可以说送到正确的地方，这就够了。<br>TCP连接组成包括：这对主机各自的：缓存、变量、进程连接的套接字。</p>
<h2 id="TCP报文段"><a href="#TCP报文段" class="headerlink" title="TCP报文段"></a>TCP报文段</h2><p>与UDP的报文段对比起来，TCP报文段可以说是非常复杂了。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-20/76751662.jpg" alt=""></p>
<p><strong>源端口号、目的端口号</strong>：TCP使用四元组确定一个连接，该信息用于复用分解。<br><strong>序号、确认号</strong>：像前面讨论到的保证可靠性的机制一样，TCP使用序号来确定每一个<strong>字节</strong>，注意TCP为每一个字节分配一个序列号，而不是像rdt一样为每一个包分配一个序号。这个机制将在后面提到。确认号：TCP确认已按序收到的下一个字节。<br><strong>接收窗口</strong>：用于流量控制，接收方告知发送方醉倒还能给我发送多少字节。<br><strong>首部长度</strong>：一般是20字节，比UDP多12字节（Byte）。<strong>选项</strong>可令TCP首部长度发生改变，首部长度按照32bit的字为单位。<br><strong>因特网检验和</strong>：同UDP。checksum<br><strong>紧急数据指针</strong>：指向app层标识的紧急数据的尾字节。当紧急数据存在并存在紧急数据指针的时候，TCP必须通知上层。该字段一般不用。<br><strong>选项</strong>：用于双方协商MSS的大小、时间戳等。可参考RFC 854与RFC 1323了解细节。<br><strong>URG</strong>：urgent，紧急。指示存在紧急数据。<br><strong>ACK</strong>：指示该报文段包括一个对已经被成功接收的报文段的确认。<br><strong>PSH</strong>：要求将数据立即给APP层。<br><strong>RST</strong>：在连接出现问题时重置。<br><strong>SYN</strong>：连接建立请求。<br><strong>FIN</strong>：终止连接请求。</p>
<p>需要注意的是：TCP的确认是<strong>累积确认</strong>，也就是只会确认到有序的字节流的下一个。对于那些失序的包，选择权交给了实现TCP的编程人员：</p>
<ol>
<li>立即丢弃</li>
<li>缓存：这是实际中做的。</li>
</ol>
<p>$\color{green}{关于究竟缓存是怎么实现的，需要再查阅资料。}$</p>
<p><strong>稍带确认</strong>：一方向另一方发送信息时顺带确认另一方向自己发送的信息。每一次发送的TCP报文段都必须有SEQ与ACK字段。当没有新数据到达时，SEQ就为下一个期待的字节的序号。<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-21/13245774.jpg" alt=""></p>
<h2 id="往返时间估计与超时"><a href="#往返时间估计与超时" class="headerlink" title="往返时间估计与超时"></a>往返时间估计与超时</h2><p><strong>往返时间</strong>（RTT）的估计是为了能够设置一个良好的超时重传的时间，以避免时间太短带来的不必要的重传以及时间太长而影响应用层的体验。</p>
<p><strong>SampleRTT</strong>指的是某TCP报文段从被发出到收到确认之间的时间间隔。</p>
<p>TCP在任意一个时刻，只为当前已经发送但仍未确认的一个TCP报文段计算SampleRTT，得到一个新的SampleRTT值。<br>TCP不会为重传的报文段计算RTT，它只会对第一次上传输的报文段计算，这是为什么？</p>
<p><strong>由于路由器的阻塞以及系统负载的变化，SampleRTT将会随之波动</strong>，因此采取了一种对SRTT取平均的方法，委会一个EstimatedRTT。<br>$$ERTT=(1-\alpha)*ERTT+\alpha*SRTT$$</p>
<p>$\alpha$通常取0.125，故：<br>$$ERTT=0.875*ERTT+0.125*SRTT$$</p>
<p>这种<strong>指数加权平均移动</strong>将使得之前的SRTT的权值快速减小。</p>
<p><strong>DevRTT</strong>是RTT的偏差，用于估算SRTT偏离ERTT的程度：</p>
<p>$$DRTT=(1-\beta)*DRTT+\beta* | SRTT-ERTT|$$</p>
<p>$\beta$通常取值0.25，故：</p>
<p>$$DRTT=0.75*DRTT+0.25*|SRTT-ERTT|$$</p>
<p>$$\color{red}{千万不要忘记给公式里面的markdown符号加转义谢谢}$$</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-21/72463943.jpg" alt=""></p>
<p>最终的超时时延应该设置为：$$TimeoutInterval=ERTT+4*DRTT$$</p>
<p>推荐的初始TI是1s。</p>
<blockquote>
<p>快速重传：当发送方连续三次收到对同一个字节的确认消息，默认为是对下一个字节的NAK，将会忽略定时器，立即对下一个报文段进行重传。<br>对于有问题的报文段，TCP并不管是丢失、数据错误、ACK损坏，都以重传报文段来解决问题。<br>TCP使用流水线，可以显著的增加吞吐量。<br>一个发送方可以具有的未被确认的报文段数量由流量控制与拥塞控制机制决定。</p>
</blockquote>
<h2 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h2><p>TCP的可靠数据传输服务保证另一个进程从其接收缓冲中读出的数据无损坏无间隔非冗余的按序字节流。</p>
<p>提出问题：对于那些被接收方缓存但是由于无序不能确认的包，有什么机制呢？（这个不同于回退N步，亦不同于选择重传（选择重传N个定时器））</p>
<h3 id="简化的TCP发送方动作"><a href="#简化的TCP发送方动作" class="headerlink" title="简化的TCP发送方动作"></a>简化的TCP发送方动作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">sendbase = initial_sequence number </div><div class="line">nextseqnum = initial_sequence number </div><div class="line"></div><div class="line">loop (forever) &#123; </div><div class="line">    <span class="keyword">switch</span>(event) </div><div class="line">   <span class="comment">/* event: data received from application above </span></div><div class="line"><span class="comment">    create TCP segment with sequence number nextseqnum </span></div><div class="line"><span class="comment">    compute timeout interval for segment nextseqnum</span></div><div class="line"><span class="comment">    start timer for segment nextseqnum </span></div><div class="line"><span class="comment">    TCP只会为第一个设置一个定时器</span></div><div class="line"><span class="comment">    pass segment to IP */</span></div><div class="line">     ;</div><div class="line">    nextseqnum = nextseqnum + length(data) ;</div><div class="line">    <span class="comment">/*event: timer timeout for segment with sequence number y </span></div><div class="line"><span class="comment">    retransmit segment with sequence number y </span></div><div class="line"><span class="comment">    compute new timeout interval for segment y </span></div><div class="line"><span class="comment">    restart timer for sequence number y */</span> </div><div class="line">    <span class="comment">//event: ACK received, with ACK field value of y ;</span></div><div class="line">    <span class="keyword">if</span> (y &gt; sendbase) &#123; <span class="comment">/* cumulative ACK of all data up to y */</span> </div><div class="line">        cancel all timers <span class="keyword">for</span> segments with sequence numbers &lt; y ;</div><div class="line">        sendbase = y ;</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">else</span> &#123; <span class="comment">/* a duplicate ACK for already ACKed segment 快速重传机制*/</span> </div><div class="line">        increment number of duplicate ACKs received <span class="keyword">for</span> y ;</div><div class="line">        <span class="keyword">if</span> (number of duplicate ACKS received <span class="keyword">for</span> y == <span class="number">3</span>) &#123; </div><div class="line">        <span class="comment">/* TCP fast retransmit */</span> </div><div class="line">            resend segment with sequence number y ;</div><div class="line">            restart timer <span class="keyword">for</span> segment y ;</div><div class="line">        &#125; </div><div class="line">    &#125;  <span class="comment">/* end of loop forever */</span> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="超时间隔加倍"><a href="#超时间隔加倍" class="headerlink" title="超时间隔加倍"></a>超时间隔加倍</h3><p>前面讲到TimeoutInterval根据ERTT与DRTT推导出，其实这只是在首次发出报文段的时间间隔。之后每超时一次，这个时间间隔都会被设置为原来的2倍。这也算是拥塞控制的一部分，因为当数据报丢失时，很可能是因为网络的拥堵。在后面将会更加详细的介绍TCP拥塞控制机制。</p>
<h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p>就像前面已经提到的，3个对同一数据的冗余ACK激发快速重传。</p>
<h3 id="GoBackN-or-Selective-Repeat？"><a href="#GoBackN-or-Selective-Repeat？" class="headerlink" title="GoBackN or Selective Repeat？"></a>GoBackN or Selective Repeat？</h3><p>TCP看起来更像是Go Back N，因为只有一个定时器，但是TCP又会在接收方提供缓存机制，而且<strong>每次重传都只会重传一个报文段</strong>。</p>
<p>对TCP提出的一种修改意见是<strong>选择确认</strong>，也就是允许TCP对失序报文段有选择的确认。这种机制我们不讨论。</p>
<p><strong>云巽</strong>：yunxun，意外发现了一个很好听的词！</p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>emmm这里是想直接嵌入js的，没想到失败了。就先这么放着，在文章最后可以看到。</p>

<div id="map-wrap" style="height: 500px;width:800px;"></div>
 <script type="text/javascript" src="/js/echarts.min.js"></script>
    <script src="/js/flow-control.js"></script>

<p>需要注意的一点是，流量控制与拥塞控制并不是同一个概念。流量控制是为了使接收方的缓存区不会溢出，拥塞控制则是为了降低网络的负担。</p>
<p>TCP的发送端维护<strong>接收窗口</strong>rwnd，接收窗口将指示给发送方接收方还能最多收到多少字节的数据。<br>定义：<br><strong>LastByteRead</strong>：接收方的应用进程从缓存中读出的最后一个字节的编号。<br><strong>LastByteRcvd</strong>：从网络到达接收方并放入接收缓存的最后一个字节的编号。<br><strong>接收缓存RecvBuffer</strong>。<br>由于TCP不允许溢出：LastByteRcvd-LastByteRead&lt;=RecvBuffer<br>接收窗口的大小：rwnd=RecvBuffer-(LastByteRcvd-LastByteRead)</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-21/83120235.jpg" alt=""></p>
<p><strong>LastByteSent</strong>：发送方维护的已经发送的最后一个字节的编号。<br><strong>LastByteACKed</strong>：被确认的最后一个字节的编号。</p>
<p>根据接收方的动作，由于被Read的一定是已经接收方被ACKed的（但是发送方可能会因为其他问题还没有被ACK），因此，只需要保证LastByteSent-LastByteACKed&lt;=rwnd，这样就可以保证接收方的缓冲区不会溢出。</p>
<p>动作：接收方每次ACK，都告诉发送方自己的rwnd，发送方将最多发送rwnd字节的数据。</p>
<blockquote>
<p>仔细想一想，其实这个真的是有用的吗？如果一个包ACK了N字节，但是ACK损坏掉了，这时可以看到rwnd指示有额外的空间，但是在发送方却没有额外的空间了（sent-acked=rwnd），这时应不应该继续发送呢？</p>
</blockquote>
<p>这种方法其实有一个问题：接收方ACK的时候，告诉发送方自己的rwnd=0，过了一会儿，APP层拿走了一些数据，这时rwnd有空间了，但是发送方却不知道有空间了，不会发送数据。这就会形成死锁。<br>有两种可能的解决方法，但是TCP要求接收方尽可能简单，于是这个任务落在了发送方。<br>发送放在被告知对方的rwnd=0之后一段过时间将开始向接收方发送只含有一个字节的<strong>探测报文</strong>，这些报文段将会被接收方确认，直到发送方接收到了一个rwnd!=0的报文段ACK。</p>
<p>UDP不提供流量控制。</p>
<h2 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h2><h3 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h3><p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-21/34029198.jpg" alt=""></p>
<p>三次握手如上：</p>
<ol>
<li>客户端发送一个<strong>不承载数据</strong>的SYN被置为1的报文段<strong>SYN报文段</strong>。client_isn是随机生成，为了消除分组重传带来的错误（取决于网络时延）。有一些在如何选取client_isn方面的有趣研究。</li>
<li>服务器端发送<strong>SYNACK</strong>报文段：一旦服务器端接收到了上一个报文，就开始准备为这条连接分配缓存与变量，并发送一个允许连接的报文段：SYN被置为1表示请求连接。（TCP连接互不干扰，实际上存在两条连接，在关闭连接时更能体现出），seq指明了自己的初始序号，ACK是对前面一个请求连接报文段的确认。此后，客户端就可以向服务器端发送信息了。</li>
<li>客户机为这条连接分配变量与缓存，并发送确认报文：是客户端确认服务器端连接的普通报文段，这个报文段可以承载数据（因为client-&gt;server的连接已经建立）。此后，服务器端就可以向客户端发送信息了。</li>
</ol>
<p>client_isn以及server_isn一般有自己对应的counter产生，从而确保相近时间创立的连接的seq不同。</p>
<blockquote>
<p>可以想象，如果在A到B的使用到了seq=N的连接刚刚关闭，新开的A到B的相同端口号的连接又使用了序号N，而由于网络时延的关系，上一个连接的N还存在于网络之中，就有可能出现上一个N被误当作这次的N被接收ACK，导致应用层获取数据错误的情况发生。</p>
</blockquote>
<p>上面的是一个标准的打开过程，实际上，打开过程可能会出现各种幺蛾子，比如：</p>
<p>Simultaneous Open ：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-21/40260134.jpg" alt=""><br>实际上，这种打开是成功的。两端都有各自的连接，实际上所起的效果是一样的。这里的第二个报文之所以没有seq，是因为seq是给对方ACK使用的，由于这里的每一条连接是单向的，就不需要给出一个新的seq。</p>
<p>半打开：<br>半打开是失败的打开，是因为一方的连接建立起来之后另一方没有再回消息，也就是第三条报文不见了。比如机器非正常关机等都可能会导致半打开。数量较大的版打开将会影响效率与空间。怎么消除半打开的连接呢？<br>可以定时检查，向对方发送报文，如果不如回应，就把己方的连接关闭。</p>
<h3 id="连接关闭"><a href="#连接关闭" class="headerlink" title="连接关闭"></a>连接关闭</h3><p>参与TCP连接的任意一方都能随时终止连接，连接结束之后，为连接维护而存储的变量与缓存都将被释放。<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-21/38371351.jpg" alt=""><br>红色部分之后，client不再发送报文段，但是还可以接收；绿色之后，server不再发送报文段，连接正式关闭。</p>
<p>半关闭：<br>半关闭是正常现象，指的就是A-&gt;B的连接关闭之后，A不会再发送但是还能接收，B到A的也关闭了之后才都消停下来。</p>
<h3 id="TCP连接状态序列"><a href="#TCP连接状态序列" class="headerlink" title="TCP连接状态序列"></a>TCP连接状态序列</h3><p>客户机的TCP状态序列：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-21/8044207.jpg" alt=""></p>
<p>为什么直到等待一个IP数据报在Internet上可能存活的最大时间长的两倍（即120秒）后，一个连接才能从TIME_WAIT状态转移到CLOSED状态？<br>当连接的本地一方已经发出一个ACK数据段响应对方的FIN数据段时，它并不知道这个ACK数据段是否成功地被传递。结果是，另一方可能有重传一个FIN数据段，而这个第2个FIN数据段可能在网中被延迟。如果允许连接直接转移到CLOSED状态那么可以会有另一对应用进程会打开同一个连接（即使用同一对端口号），而前面连接实例中被延迟的FIN数据段这时会立即使后来的连接实例终止。同时也避免了分组重传带来的错误信息。</p>
<p>服务器的TCP状态序列：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-21/25538433.jpg" alt=""></p>
<h3 id="TCP定时器总结"><a href="#TCP定时器总结" class="headerlink" title="TCP定时器总结"></a>TCP定时器总结</h3><p><strong>Connection Establishment Timer</strong>：<br>当SYN包发出时，连接建立定时器就开始计时，如果在75秒内未收到响应，则连接建立失败。<br><strong>The Retransmission Timer</strong>：<br>重发定时器是TCP发送数据时设置的，如果数据在重发定时器超时时还没有返回确认，TCP就重发数据。定时器的设置是动态的，它基于TCP对往返时间（round-trip time）的测试，重发时间设在1到64秒<br><strong>Delayed ACK Timer</strong>：<br>当TCP实体收到数据时它必须返回确认，但并不需要立即回复，它可以在500ms内发送ACK报文，如果在这段时间内它恰好有数据要发送，它就可以在数据内包含确认信息，因此需要ACK延时定时器。<br><strong>The Persistence Timer</strong>：<br>管理一种较为少见的事件，即死锁情况。为了让发送方暂停发送数据，接收方发送一个接收窗口为0的确认。后来，接收方又发送了一个更新了窗口大小的分组，但该分组丢失，于是，双方都处于等待<br>为了防止上述事情发生，发送方在收到接收方发来一个窗口为0的数据时，就启动持续定时器，等该定时器超时还没有收到对方修改窗口大小的数据的话，发送方就发一个探测数据，对该探测数据的响应应包含了窗口大小，若仍为0，则定时器清0，重复以上步骤，否则则可以发送数据。<br><strong>The Keep-Alive Timer</strong>：<br>当一个连接长时间闲置时，保持存活定时器会超时而使一方去检测另一方是否仍然存在，如果它未得到响应，便终止该连接<br><strong>The Quiet Timer</strong>：<br>当TCP连接断开后，为防止该连接上的数据还在网络上，并被后续打开的相同的连接接收，要设置闲置定时器以防止刚刚断开连接的端口号被立即重新使用</p>
<blockquote>
<p>SYN洪泛攻击<br>在上面提到了：半Open。其实这种情况大都在一分钟之后被服务器端发现并断开连接，回收资源了。但是这一分多钟的时间的资源浪费将为经典的Dos攻击即SYN洪泛攻击创造了环境。<br>在这种攻击模式中，攻击者发送大量的SYN报文段而不发送最终的ACK，导致大量的半连接占用服务器的资源。<br>现在有一种有效的解决方式：SYN cookie<br>SYN cookie的工作方式是：当server接收到一个SYN，他并不立即为这个连接分配缓存与变量，而是使用这个TCP报文段携带的源ip与源port信息，运行一个仅有server知道的一个散列函数得到一个初始序列号，这种精心制作的初始序列号被称为cookie。server仅仅是发送一个具有该序号的SYNACK。该序号也不会被保存。<br>如果一段时间之后接收到了同一个源ip与源port的ACK报文段，server发现二者并没有连接，于是再次运行散列函数，得到的序号如果加一就是本ACK携带的序号，server就认为这是一个正常的client，为之分配资源，建立连接，否则，server不会分配资源，之前的攻击没有任何影响。<br>（哎呀其实也稍稍影响了处理效率了吧）</p>
</blockquote>
<h3 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h3><p>前面考虑的都是特别理想的情况，如果client向server一个并不接受TCP连接的port发送了一条报文将会怎样？</p>
<p>server将发送一个<strong>特殊重置报文段</strong>给client，这个报文段将RST标志位置为1，告诉client自己没有那个port接收TCP，请他不要再发送了。</p>
<p>如果发送的是一个UDP报文段，如果不匹配，server发送一个ICMP数据报。这在<strong>网络层</strong>进行讨论。</p>
<blockquote>
<p>nmap工作原理：<br>nmap向某一台主机的一个port发送一个SYN，接下来有三种情况：收到一个SYNACK，则会标明那个端口上有一个已经打开的TCP应用程序，返回“打开”，如果收到RST，说明这个端口没有一个TCP应用程序，如果什么都没有收到，说很可能是被防火墙给墙了。<br><a href="http://www.nmap.org" target="_blank" rel="external">nmap下载</a></p>
</blockquote>
<h3 id="TCP-option"><a href="#TCP-option" class="headerlink" title="TCP option"></a>TCP option</h3><p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-21/50610071.jpg" alt=""></p>
<p>先只放一个图。</p>
<h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><p>在讨论TCP的拥塞控制之前，首先来讨论更加普遍的拥塞控制原理。</p>
<p>我们把<strong>分组重传</strong>作为网络拥塞的信号。实际上，分组重传不全是因为网络拥塞。</p>
<p><strong>ATM</strong>：异步传输网络<br><strong>ABR</strong>：可用比特率</p>
<h3 id="1-两个发送方与一个无限缓存的路由器"><a href="#1-两个发送方与一个无限缓存的路由器" class="headerlink" title="1. 两个发送方与一个无限缓存的路由器"></a>1. 两个发送方与一个无限缓存的路由器</h3><p>不考虑分组重传、流量控制、拥塞控制，忽略首部信息的额外开销。<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-21/15483986.jpg" alt=""></p>
<p>这种情况下，发送方完全不节制，每连接的吞吐量如下：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-21/89389045.jpg" alt=""><br>吞吐量不可能有超过R/2的稳定状态，这是因为二者共享一个吞吐量R的链路。当发送速率在[0,R/2]时，接收方的吞吐率等于发送方的发送速率，也就是<strong>发送方的所有数据经过有限时间传输之后到达接收方</strong>。</p>
<p>但是，再看速度与平均时延的关系：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-21/46450452.jpg" alt=""><br>看起来吞吐量接近R/2是件好事，但是从时延的角度来看，接近R/2的时候，平均时延就会越来越大。</p>
<p><strong>代价1</strong>：巨大的时延。</p>
<p><strong>（为什么？？？到R/2的时候不是正好利用完所有链路吗？又没有重传，时延为什么会这么大？？？</strong></p>
<h3 id="2-两个发送方以及一个具有有限缓存的路由器"><a href="#2-两个发送方以及一个具有有限缓存的路由器" class="headerlink" title="2. 两个发送方以及一个具有有限缓存的路由器"></a>2. 两个发送方以及一个具有有限缓存的路由器</h3><p>假设：路由器缓存已经满了的话，新来的数据包就会被丢弃。</p>
<p><strong>供给载荷</strong>：运输层向网络中发送报文段的速率。</p>
<p>仍然使用上面的图。</p>
<ol>
<li>如果控制得非常好，yin=yout</li>
<li>如果只对丢失的包进行重传，yin`&gt;yout</li>
<li>对迟到的包重传，yin`远大于yout</li>
</ol>
<p>以上三种情况下的吞吐量随着供给载荷变化：（所谓吞吐量，就是☞yout吧）<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-21/98233117.jpg" alt=""></p>
<p>第二图的R/3-R/2是部分重传丢失占用的带宽，第三图的R/4-R/2是部分重传丢失+延时重传带来的丢失。</p>
<p><strong>代价2</strong>：不必要的重传占用带宽</p>
<h3 id="3-四个发送方以及有有限缓存的多台路由器及多跳路径"><a href="#3-四个发送方以及有有限缓存的多台路由器及多跳路径" class="headerlink" title="3. 四个发送方以及有有限缓存的多台路由器及多跳路径"></a>3. 四个发送方以及有有限缓存的多台路由器及多跳路径</h3><p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-21/85465498.jpg" alt=""></p>
<p>从虚线开始，吞吐量就开始下降，一直到最后几乎为0.这时路由器几乎一直在丢失重传丢失重传。</p>
<h3 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h3><ol>
<li>端到端的拥塞控制：IP协议并不提供对拥塞控制的支持，如果要在运输层做拥塞控制，也只能通过行为来判断。例如3次同一数据的ACK，被认为是丢失报文段，进而以为网络有些繁忙。</li>
<li>网络辅助的拥塞控制：路由器向发送方提供显式的拥塞信息。这个信息只需要一个比特。有两种方式：一种是直接反馈，路由器直接告诉发送方拥塞；另一种是间接反馈，路由器标记数据，当接收方收到被标记的数据之后在ACK的时候告诉发送方。</li>
</ol>
<h3 id="网络辅助的拥塞控制：ATM-ABR"><a href="#网络辅助的拥塞控制：ATM-ABR" class="headerlink" title="网络辅助的拥塞控制：ATM ABR"></a>网络辅助的拥塞控制：ATM ABR</h3><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>TCP的拥塞控制的基础是认为所有数据包的丢失都是路由器因为阻塞给我丢掉了。<br>实际上，有线网络传丢的可能性很小，所以这个基础是没什么问题的。但是在无线网络中，TCP的拥塞控制则需要有一定的改进。</p>
<h3 id="TCP拥塞控制概述"><a href="#TCP拥塞控制概述" class="headerlink" title="TCP拥塞控制概述"></a>TCP拥塞控制概述</h3><p><strong>拥塞窗口cwnd</strong>：发送方维护一个变量，他对一个TCP发送方能对网络中发送数据的速率进行了限制。特别的：$$LastByteRcved-LastByteACKed&lt;=min{rwnd,cwnd}$$</p>
<p>cwnd限制了发送方每次向接收方发送的字节数量，考虑一个丢包与发送时延皆忽略不计的连接，粗略的讲，发送方发送的速率大概是（cwnd/RTT)字节/秒。因此，调整cwnd可以调整发送速率。</p>
<p>那么发送方要怎么知道有了拥塞？第一就是像前面所说的丢包或是连续三个ACK。<br>有没有可能丢包不是因为网络拥塞呢？当然是可能的！</p>
<p>对于不丢包的理想情况下，TCP的发送方将会收到对以前未确认报文的确认，它们使用这些确认来增加cwnd。到达的速率将会影响cwnd增长的速率，因为TCP使用触发（或计时）来增大它的拥塞窗口长度，TCP是<strong>自计时</strong>的。</p>
<p>TCP有一些处理方法：</p>
<ol>
<li>一个丢失的报文段意味着阻塞</li>
<li>一个确认报文段指示网络正在向接收方交付发送方的报文段，因此当对先前未确认的报文段到达时，增加发送速率</li>
<li>宽带探测。</li>
</ol>
<h3 id="TCP拥塞控制算法"><a href="#TCP拥塞控制算法" class="headerlink" title="TCP拥塞控制算法"></a>TCP拥塞控制算法</h3><p><strong>慢启动</strong>：</p>
<p>一条TCP连接开始时，首先cwnd会被设置为1个MSS。1个MSS真的很小，因此TCP此后每当一个报文段首次被确认（注意不是收到ACK哦，是被确认哦）就把MSS增加1.这样1变2，2变4，4变8…<strong>指数增长</strong>。</p>
<p>什么时候停止这种爆炸增长？</p>
<ol>
<li>存在丢包事件，将ssthresh置为cwnd/2，将cwnd重新置1，重新慢启动，。</li>
<li>存在丢包事件，将cwnd的值置为ssthresh，结束慢启动，进入拥塞避免阶段。</li>
<li>检测到3个冗余ACK，执行快速重传，进入快速恢复。</li>
</ol>
<p><strong>拥塞避免</strong>：</p>
<p>进入拥塞避免之后，离拥塞可能并不遥远。每个RTT将增加一个MSS。例如一个RTT发了10个包，那么这十个包只将cwnd增加1个MSS。</p>
<p>什么时候结束这种线性增长？</p>
<ol>
<li>丢包，将cwnd设置为1个MSS，sstresh设置为cwnd/2。</li>
<li>三个冗余ACK，将cwnd减半（三个已经收到的ACK要加上3个MSS），将ssthresh更新为cwnd/2，进入快速恢复</li>
</ol>
<p><strong>快速恢复</strong>：</p>
<p>对于引起TCP进入快速恢复的报文段，对每收到的一个冗余ACK都加一个MSS。这个阶段时说明网络其实并不是特别堵，只是传丢了一个，不用太过限制。直到最终丢失的报文段ACK到达，TCP在降低cwnd之后进入拥塞避免阶段。<br>如果出现超时事件，将将cwnd设置为1个MSS，sstresh设置为cwnd/2，进入慢启动。<br>如果出现冗余丢包事件，将cwnd设置为1个MSS，sstresh设置为cwnd/2。</p>
<h3 id="TCP-Tahoe与TCP-Reno"><a href="#TCP-Tahoe与TCP-Reno" class="headerlink" title="TCP Tahoe与TCP Reno"></a>TCP Tahoe与TCP Reno</h3><p>Tahoe不管发生什么事件，都会无条件的将cwnd变为1，然后重新慢启动。<br>Reno综合了快速恢复。</p>
<p>Tahoe的过程：在4时达到初始阈值，在8时有三个冗余ACK，在10.5时达到阈值。<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-22/38232100.jpg" alt=""><br>Tahoe不能容忍丢包，一旦丢包，就会进入慢启动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* slowstart is over        */</span> </div><div class="line"><span class="comment">/* cwnd &gt; threshold */</span></div><div class="line">Until (loss event) &#123;</div><div class="line">  every w segments ACKed:</div><div class="line">        cwnd ++;</div><div class="line">  &#125;<span class="comment">//拥塞控制阶段;</span></div><div class="line">threshold = cwnd /<span class="number">2</span>;</div><div class="line">cwnd = <span class="number">1</span>;</div><div class="line">perform slowstart<span class="comment">//重新慢启动;</span></div></pre></td></tr></table></figure>
<p>Reno过程：在4时达到初始阈值，在8时有三个冗余ACK，之后减小cwnd，进入快速恢复。<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-22/74575292.jpg" alt=""><br>Reno分超时丢包与冗余丢包，冗余丢包进入快速恢复，超时慢启动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* slowstart is over        */</span> </div><div class="line"><span class="comment">/* cwnd &gt; threshold */</span></div><div class="line">Until (loss event) &#123;</div><div class="line">  every w segments ACKed:</div><div class="line">      cwnd ++</div><div class="line">  &#125;<span class="comment">//拥塞控制;</span></div><div class="line">threshold = cwnd /<span class="number">2</span></div><div class="line">If (loss detected by timeout) &#123;<span class="comment">//进入慢启动;</span></div><div class="line">    cwnd = <span class="number">1</span></div><div class="line">    perform slowstart &#125;</div><div class="line">If (loss detected by triple duplicate ACK)<span class="comment">//进入快速恢复</span></div><div class="line">    cwnd = cwnd /<span class="number">2</span></div></pre></td></tr></table></figure>
<p>于是发现：什么对超时都是没有容忍度的，直接会慢启动。但是对于3个冗余ACK的表现个不一样，一般进入快速恢复。</p>
<h2 id="公平性：TCP与UDP"><a href="#公平性：TCP与UDP" class="headerlink" title="公平性：TCP与UDP"></a>公平性：TCP与UDP</h2><p>TCP是自律的，如果UDP不自律，可能会挤跨TCP。因此在使用UDP的APP层应该做类似的”平滑、缓慢变化“的拥塞机制，保证公平。</p>
<h1 id="端口与进程"><a href="#端口与进程" class="headerlink" title="端口与进程"></a>端口与进程</h1><p>最后，我需要补充一下端口号与进程之间的关系：</p>
<p>首先：缓冲区对应的是谁？在上一篇中就应该明确，是socket。</p>
<p><strong>端口号是什么？</strong></p>
<p>在网络技术中，端口大致有两种意思：一是物理意义上的端口，比如，ADSL Modem、集线器、交换机、路由器用 于连接其他网络设备的接口，如RJ-45端口、SC端口等等。二是逻辑意义上的端口，一般是指TCP/IP协议中的端口，端口号的范围从0到65535，比如用于浏览网页服务的80端口，用于FTP服务的21端口等等。我们这里将要介绍的就是逻辑意义上的端口。</p>
<p>服务器一般通过知名端口号来识别。例如，对于每个TCP/IP实现来说，FTP服务器的TCP端口号都是21，每个Telnet服务器的TCP端口号都是23，每个TFTP(简单文件传送协议)服务器的UDP端口号都是69。任何TCP/IP实现所提供的服务都用知名的1～1023之间的端口号。这些知名端口号由Internet号分配机构（InternetAssignedNumbersAuthority,IANA）来管理。</p>
<p>端口号的作用正是为了区分不同的网络服务。</p>
<p>上面的比较官方，下面将由我自己写的程序来——</p>
<p>TCP里面，一个端口号可以被多个socket绑定。而UDP不行，我的理解是数据不知道要给谁。</p>
<p>已经被绑定之后，再次要求绑定：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-4/88853868.jpg" alt=""></p>
<p>这是再次运行，也就是说，其实这个并不是一个进程不能绑定同一个端口号，而是两个UDP的socket不能绑定同一个端口。跟进程没有什么关系。fork子线程的时候，也可以使用其他的socket绑定其他的端口号。</p>
<p>端口这个概念就是计算机网络领域的概念，有网友直言说进程与端口号没有什么关系，其实是对的。</p>
<p>thanks for ur help!</p>
<p>[1] <a href="http://www.cnblogs.com/BoyXiao/archive/2012/02/20/2359273.html" target="_blank" rel="external">进程与端口映射</a></p>
<p>[2] <a href="https://baike.1688.com/doc/view-d2361261.html" target="_blank" rel="external">端口号是什么？</a></p>
<p>[3]<a href="https://www.ibm.com/support/knowledgecenter/zh/SSGMGV_3.2.0/com.ibm.cics.ts.internet.doc/topics/dfhtl2d.html" target="_blank" rel="external">IBM Knowledge Center</a>  这个有很多东西，不止端口号</p>
<p>[4]<a href="http://wiki.xiaohansong.com/network/tcp.html" target="_blank" rel="external">TCP</a></p>
<p>在最后的复习时刻！</p>
<p>UDP的源端口号：即使不用ACK，但是交互总要有个来源吧。服务器给client发东西得直到源端口号啊。</p>
]]></content>
      
        <categories>
            
            <category> 计算机网络 </category>
            
            <category> 大三的课 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络课 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[the One使用记录]]></title>
      <url>/2017/11/01/the%20One%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%951/</url>
      <content type="html"><![CDATA[<blockquote>
<p>一个小tip：使用linux命令行进入带空格的文件，如果直接cd filename进入的话是不行的，那应该怎么进入呢？</p>
<p><strong>cd “filename”就好啦</strong>！</p>
<p>又一个小tip：不下心关掉了eclipse的项目工程目录怎么办？</p>
<p><strong>Window-&gt;Show View-&gt;Others-&gt;General-&gt;Project Explorer</strong></p>
<p>emmm，markdown行内代码形式：``包起来就行</p>
</blockquote>
<h1 id="从github下载the-one"><a href="#从github下载the-one" class="headerlink" title="从github下载the-one"></a>从github下载the-one</h1><p>犹记我初学git的时候也是傻傻的，这里就放出来具体操作方法了！</p>
<p>首先需要一个GitBash。在gitbash里使用cd命令进入想存放the one的文件夹，然后输入命令：<code>git clone https://github.com/akeranen/the-one.wiki.git</code>，前面两个是命令，最后一个是参数，代表的是这个仓库的地址。这个下载下来的是master….应该是不行的….下载v1.6吧。</p>
<p>等到完成之后就会发现在这个文件夹下面多了好多东西呀！</p>
<p>done！</p>
<h1 id="将项目import进Eclipse并运行"><a href="#将项目import进Eclipse并运行" class="headerlink" title="将项目import进Eclipse并运行"></a>将项目import进Eclipse并运行</h1><p>eclipse，使用java的孩子应该没有不知道的吧。哦对，the one是java代码编写。</p>
<p>到了这一步就出了一点小问题…一直是使用eclipse的File-&gt;import功能向workspace导入外部的项目的，导入the one的时候竟然告诉我未找到项目文件！<br>我尝试使用File-&gt;Open Project From FileSystem来，这次可以了。the one 成功出现在了project explorer里面！但是！有错误！</p>
<p>这个应该在说明文档里面说了，1.1以后版本的java要编译theone需要添加一些liabrary到项目的build path，但是我看了我的build path，已经添加了呀？怎么还有错？</p>
<p><a href="https://stackoverflow.com/questions/1089904/access-restriction-on-class-due-to-restriction-on-required-library" target="_blank" rel="external">click here</a></p>
<p>在上述网站，第二个回答解决了这个问题。由于JUnit3.0与4.0都在，我就都删除了，然后重新添加了JUnit4.0.done！</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-5/63641143.jpg" alt=""></p>
<p>如图，现在整个项目都已经没有错误了！</p>
<p>选择整个项目，右击Run As-&gt;JUnit Test成功！</p>
<p>the one涉及到了JUnit，如果不了解JUnit，需要先了解一下~</p>
<p><a href="">click here~ JUnit之一</a></p>
<p>在我以JUnit Test来运行时，theone出现了两个fail。这表明….可能是有bug的啊….<strong>mark</strong></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-5/23371918.jpg" alt=""></p>
<p><del>好吧，我先忽略了，</del> 然后 run了下（主类是core.DNTSim），发现其实可以出来东西。由于可能需要命令行参数，我又使用cmd来编译运行，结果…<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-5/5185150.jpg" alt=""></p>
<p>但是eclipse成功了呀？我找到了一个在eclipse设置命令行参数的方法，企图先跳过jdk版本带来的（？）编译问题。</p>
<p><a href="https://www.netlab.tkk.fi/tutkimus/dtn/theone/javadoc_v11/core/DTNSim.html" target="_blank" rel="external">DTNSim的API</a></p>
<p>Run-&gt;Run Configurations-&gt;DTNSim-&gt;Argumets:加上你想要的参数。即可：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-5/68381775.jpg" alt=""></p>
<p>好了，至此，程序初步可以运行使用了。</p>
<h1 id="解决问题时间"><a href="#解决问题时间" class="headerlink" title="解决问题时间"></a>解决问题时间</h1><hr>
<p>好的，现在是解决问题时间啊。</p>
<p>询问了老师，老师说这个可能是JUnit包加载不正确。但是我重新写了一个工程，使用一样的方法，那个是没错的。</p>
<p>所以我想是不是版本问题。</p>
<p>于是我下载了v1.6。使用同样的方法import进来，这次错误更多！<br>但是我发现这次最初是没有添加README里面说要自己添加的2个jar包的，所有感觉有希望！</p>
<p>添加jar包：</p>
<blockquote>
<p>Project右键-&gt; build path -&gt; configure build path-&gt;libraries-&gt;add jars-&gt;the-one-1.6.0-&gt;lib</p>
<p>好了，把这两个jar都添进来。</p>
<p>JUnit的添加方法还与上面一样，记得要添加的是4.0</p>
</blockquote>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/51953772.jpg" alt=""></p>
<p>没错了。</p>
<p>然后来测试一下。<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/45497488.jpg" alt=""></p>
<p>还有错:-)。</p>
<p>既然是有错的，那就只能一点一点分析是怎么回事了。</p>
<ol>
<li>首先，我又运行了1.6的compile，还是不行，这次我决定把电脑里面的jdk换成8。</li>
</ol>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/36756939.jpg" alt=""></p>
<p>如图，配置好的环境变量在cmd竟然没有更换！<br>这也是导致javac不能用的一个原因。<br>如果你确认自己配的环境变量肯定是对的，关掉cmd重新打开，就可以了。</p>
<p>环境变量配置应如下：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/16489027.jpg" alt=""><br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/44100075.jpg" alt=""><br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/61239558.jpg" alt=""><br>这次compile的结果。（jdk9不支持那个选项了？<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/64651101.jpg" alt=""><br>好了，这次使用one.bat也可以运行了。（jdk9：exm？？？</p>
<p>but….eclipse测试还是没过….<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-11-6/11070078.jpg" alt=""></p>
<hr>
<p>C:\ProgramData\Oracle\Java\javapath</p>
<h1 id="了解运行方法与配置信息"><a href="#了解运行方法与配置信息" class="headerlink" title="了解运行方法与配置信息"></a>了解运行方法与配置信息</h1><p>将参数设置为：[-b times] [ur conf_files]</p>
<p>-b后必须跟一个数字，这个数字表示simulation将会在batch mode（批处理）下运行，不会出现可视化界面，而是打印信息。后面的数字代表运行次数或者是num1:num2的形式来确定一个范围。</p>
<p>conf_files是一系列你自己写的conf file的文件名，数量任意。如果没有这个参数，会使用default_setting.txt。需要注意的是，如果多个conf设计同一个属性，那么在后面的设定将会覆盖前面的设定。</p>
<h2 id="Conf文件"><a href="#Conf文件" class="headerlink" title="Conf文件"></a>Conf文件</h2><blockquote>
<p>以下译自<a href="https://github.com/akeranen/the-one/wiki/README" target="_blank" rel="external">README</a></p>
</blockquote>
<p>所有的模拟参数都是通过cond文件给出的。conf文件就是普通的txt文件，在文件里有一些ket-value对。大多数变量的语法都是：<code>Namespace.key = value</code><br>例如：key的前缀是namespace命名空间，然后加一个.点，然后是key的名字。key和value被等于号=隔开。命名空间需要以<strong>大写字母</strong>开头，而且namespace和key都以CamelCase方式命名，大小写敏感。namespace宽松地定义了设置影响的某部分模拟环境simulation environment。许多（并非所有）namespace的名字与正在读的class的名字一样。特别是动作模块(movement models)，报告模块(report modules)以及路由模块(routing modules)遵照了这个习惯。有时namespace被用户定义，eg：使用网络接口，用户可以选择任何标识符，在该名称空间中定义特定于接口的设置，并在配置每个组应使用的接口时给出名称空间的名称。</p>
<p>数字可以使用.作为小数点，可以使用kilo(k)，mega(m)，giga(G)作为后缀。bool接受”true”,”false”,”0”,”1”。</p>
<p>许多设置确定了寻找外部文件的路径。路径可以是绝对路径也可以是相对路径，但是路径的分隔符必须是”/“。Unix与Windows都是。</p>
<p>有些变量包含以逗号隔开的值，对他们来说，语法是：<code>Namespace.key = value1,value2,etc.</code></p>
<p>对于运行索引（run-indexed）值，语法是：<code>Namespace.key=[runvalue;run2value;run3value;etc]</code>。每一个runvalue可以是一个被逗号分隔的值。</p>
<p>设置文件可以有注释，以#开头。</p>
<p>一些值（scenario and report names at the moment）支持”value filling”。有这个特性做支撑，可以从设置的值动态地构造，例如，scenario name。这在使用run-indexing的时候非常有用。Just put setting key names in the value part prefixed and suffixed by two percent (%) signs. These placeholders are replaces by the current setting value from the configuration file. See the included snw_comparison_settings.txt for an example. 这个机制像是：<br>比如，完善java的环境变量的时候：<br>JAVA_HOME=C:/Program Files/Java/<br>path=%JAVA_HOME%jre/…”</p>
<p>default_settings.txt这个文件，如果它存在，在运行的时候一定会被read。此后给的文件可以在此基础上设置更多的东西，也可以覆盖掉默认设置的一些定西。</p>
<h2 id="Run-indexing"><a href="#Run-indexing" class="headerlink" title="Run indexing"></a>Run indexing</h2><p>run index可以让你只使用一个conf文件就能运行很多个不同的配置configuration，方法是，你提供一个setting的数组，为在不同的conf文件之间需要改变的变量。例如：如果想用5个不一样的随机数生成器种子来生成movment models来运行模拟器，那么你可以这样define设置文件：<br><code>MovementModel.rngSeed = [1;2;3;4;5]</code><br>现在，你使用参数-b 5 my_config.txt运行。</p>
<p>warp-around：类似于OS里面的。也就是说：used values is the value at index (runIndex%arrayLength)。这样，就可以很轻易的运行很多排列。</p>
<h1 id="模块们"><a href="#模块们" class="headerlink" title="模块们"></a>模块们</h1><h2 id="Movement-models"><a href="#Movement-models" class="headerlink" title="Movement models"></a>Movement models</h2><p>在模拟中，运动模型控制着节点的运动。运动模型提供了coordinates坐标、速度、停顿时间。基本的安装包括：random waypoint,map based movement,shorest path map based movement,map route movement,external movement。除了external的所有这些运动模型，都有可控的速度以及停顿时间分布。可以给出最大值以及最小值，运动模型使得值在给定返回之间uniformly distributed均匀分布。在external里面，速度以及停顿时间都由文件中的给定值解释执行（interpreted）。</p>
<p>如果一个节点使用了随机航点运行模型（random waypoint:RandomWaypoint），这个节点在模拟区中被给予一个随机的坐标。节点直接以恒定的速度到达给定的目的地，然后停顿一段时间，然后获得新的目的地。这个过程在整个模拟的过程中持续进行，节点在这些zig-zag（蜿蜒的）路径上走</p>
<p>基于地图的运动模型将节点的运动限制在预先定义好的路径上。可以定义不一样的路径，可以定义对全体节点都有效的路径。这样的话，比如说，汽车才不会直接开进门里或者是开到人行道上。</p>
<p>基本的基于地图的运动模型（map-based:MapBasedMovement）初始时把节点们分布在两个相邻的地图节点之间，然后节点们开始运动，从一个adjacent map node到另一个。当节点到达下一个地图节点的时候，他随机选择下一个节点。但是只有当这是唯一的选项（即，避免回到它来自的地方）时才选择它来自的地图节点。一旦节点移动了10-100个地图节点，它暂停一段时间，然后再次开始移动。 </p>
<p>更加复杂的版本的基于地图的运动(ShortestPathMapBasedMovement)使用了Dijkstra的最短路径算法来寻找他在整个地图范围内的路径。一旦一个节点到达了他的目的地，他等一段时间，选择下一个随机的地图节点，用最短路径走过去。<br>（这个算法只对valid map nodes起作用）</p>
<p>对于基于最短路径的运动模型，地图的数据信息还包括POIs（point of interests）。instead of为下一个目的地选择任意随机地图节点，移动模型可以被配置为以可配置的概率给出属于某个POI组的POI。可以有无限数量的POI组，并且所有组可以包含任何数量的POI。所有节点组对于所有POI组可能具有不同的概率。<br>POI可以用来模拟例如商店，餐馆和旅游景点。</p>
<p>基于路线的运动模型（MapRouteMovement）可以用于对遵循特定路线的节点建模。（例如，公共汽车或电车线路。）只需要定义路线上的停靠点，然后使用该路线的节点就会经由最短路径，从一个站点到另一个站点，并在每一个stop停留设置好的时间。</p>
<p>所有的运动模型都可以决定什么时候节点是活跃的（他运动，可以被连接），什么时候不活跃。所有模型，除了external，可以给出多个时间间隔（time interval），在那个组的节点只会在那些时候比较活跃。</p>
<p>所有基于地图的运动模型都通过（WKT）格式的一个子集所规范的文件中获取输入信息。映射路径数据的解析器支持WKT文件的LINESTRING和MULTILINESTRING指令。对于点数据（例如POI），也支持POINT指令。 （MULTI）LINESTRING中的相邻节点被认为形成一个路径，并且如果某些行包含一些具有完全相同坐标的顶点，<br>路径从这些地方加入（这是如何创建交叉点）。 WKT文件可以使用任何合适的地理信息系统（GIS）程序从现实世界的地图数据进行编辑和生成。包含在模拟器发行版中的地图数据使用免费的基于Java的OpenJUMP GIS程序进行转换和编辑。</p>
<p>不一样的地图可以通过在不同的文件中存储属于不同类型的路径来定义。POIs简单的用WTK POINT定义，而POI组通过将所有的属于同一个组的POIs存储在同一个文件中来定义。所有的POI也必须是地图数据的一部分，所以他们可以使用路径进行访问。用LINESTRING定义路线的停靠点，停靠点按照它们在LINESTRING中出现的顺序进行遍历。一个WKT文件可以包含多个路由，并按照它们在文件中出现的顺序将它们提供给节点。</p>
<p>使用外部移动数据（ExternalMovement）的实验移动模型从文件读取时间戳节点位置，并相应地移动模拟中的节点。有关格式的详细信息，请参阅输入包中的ExternalMovementReader类的javadocs。一个合适的实验转换器脚本（transimsParser。<br>pl）的TRANSIMS数据包含在toolkit文件夹中。</p>
<p>要使用的运动模型是使用“movementModel”设置为每个节点组定义的。设置的值必须是movement包中的有效运动模型类别名称。<br>在MovementModel类中读取所有运动模型通用的设置，并在相应的类中读取运动模型特定的设置。有关详细信息，请参阅javadoc文档和示例配置文件。</p>
<h2 id="路由模块以及消息的创建"><a href="#路由模块以及消息的创建" class="headerlink" title="路由模块以及消息的创建"></a>路由模块以及消息的创建</h2><p>路由模块定义了在模拟中消息如何被处理。6个基本主动路由模块（First Contact,Spray and Wait,Direct delivery, PRoPHET and MaxProp），一个被动路由用于外部路由的模拟。主动路由模块是用于DTN路由的众所周知的路由算法的实现。也有这些模型的变体和包含在最新版本中的几个不同的模型。有关详细信息，请参阅路由程序包中的类。</p>
<p>被动路由器专门用于与其他（DTN）路由仿真器交互或运行仿真，而不需要任何路由功能。路由器除非由外部事件命令，否则不执行任何操作。这些外部事件由实现EventQueue接口的类提供给模拟器。</p>
<p>有两个基本的类可以用作消息事件的来源：ExternalEventsQueue和MessageEventGenerator。前者可以用一个合适的脚本（例如，toolkit文件夹中的createCreates.pl脚本）或通过将例如dtnsim2的输出转换成合适的形式来从手动创建的文件中读取事件。<br>有关格式的详细信息，请参阅输入包中的StandardEventsReader类。 MessageEventGenerator是一个简单的消息生成器类，它创建具有可配置消息创建间隔，消息大小和源/目标主机范围的均匀分布的消息创建模式。<br>可以使用MessageBurstGenerator和One {From，To} EachMessageGenerator类创建更具体的消息传递场景。有关详细信息，请参阅javadocs。</p>
<p>该toolkit文件夹包含一个用于dtnsim2输出的实验解析器脚本（dtnsim2parser.pl）（曾经是一个更强大的基于Java的解析器，但是由于这个更容易扩展的脚本而被丢弃）。该脚本需要dtnsim2的代码的一些补丁，可以从toolkit / dtnsim2patches文件夹中找到。<br>要使用的路由模块是按设置“路由器”的每个节点组定义的。所有路由器都不能正常交互（例如，PRoPHET路由器只能与其他PRoPHET路由器一起工作），所以通常对所有组使用相同（或兼容）路由器是有意义的。</p>
<h1 id="报告"><a href="#报告" class="headerlink" title="报告"></a>报告</h1><p>可以使用<strong>报告</strong>创建模拟运行的摘要数据，连接和消息的详细数据，适合使用例如Graphviz进行后处理的文件（创建图表）以及与其他程序接口。有关详细信息，请参阅报告包类的javadocs。</p>
<p>对于任何模拟运行可以有任意数量的报告，并且使用“Report.nrofReports”设置来定义要加载的报告的数量。报告类别名称使用“Report.reportN”设置定义，其中N是从1开始的整数值。设置的值必须是来自报告包的有效报告类别名称。<br>所有报告的输出目录（可以使用“输出”设置对每个报告类别重写）必须使用Report.reportDir -setting进行定义。如果报告类别未提供“输出”设置，则生成的报告文件名称为“ReportClassName_ScenarioName.txt”。</p>
<p>所有报告都有许多可配置的设置，可以使用ReportClassName.settingKey -syntax来定义。有关详细信息，请参阅Report类的javadocs和特定报告类（查找“设置id”定义）。</p>
<h1 id="主机组"><a href="#主机组" class="headerlink" title="主机组"></a>主机组</h1><p>一个host group是一组分享同样的运动和路由设置的主机。不同的组的设置值不一样，这样的话，它们可以表示不同类型的节点。可以在“组”（Group）命名空间中定义基本设置，不同的节点组可以覆盖这些设置或在其特定的命名空间（组1，组2等）中定义新的设置。</p>
<h1 id="the-settings"><a href="#the-settings" class="headerlink" title="the settings"></a>the settings</h1><p>有很多设置可以被设置。非常多，这里不提了。有关详细信息，请参阅类，尤其是report，routing和movement class的javadoc。另请参阅包含设置文件的示例。也许最重要的设置如下。</p>
<h2 id="脚本设置（Scenario-setting）"><a href="#脚本设置（Scenario-setting）" class="headerlink" title="脚本设置（Scenario setting）"></a>脚本设置（Scenario setting）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Scenario.name</div><div class="line"></div><div class="line"> <span class="comment">//脚本的名字，所有报告默认以此为前缀</span></div><div class="line"></div><div class="line">Scenario.simulateConnections </div><div class="line"></div><div class="line"><span class="comment">//connection是否应该被模拟。如果只对运动模型感兴趣，这个可以被disable，以获得更快的模拟速度。通常情况下，是enable的。</span></div><div class="line"></div><div class="line">Scenario.updateInterval </div><div class="line"></div><div class="line"><span class="comment">//每次更新时需要几秒。增加数值使模拟更快，但是可能以精度损失为代价。0.1-2 are good</span></div><div class="line"></div><div class="line">Scenario.endTime </div><div class="line"></div><div class="line"><span class="comment">//How many simulated seconds to simulate.</span></div><div class="line"></div><div class="line">Scenario.nrofHostGroups </div><div class="line"></div><div class="line"><span class="comment">//现在在模拟中有几个hosts group</span></div><div class="line"></div></pre></td></tr></table></figure>
<h2 id="接口设置（用来定义node可能会使用到的接口）"><a href="#接口设置（用来定义node可能会使用到的接口）" class="headerlink" title="接口设置（用来定义node可能会使用到的接口）"></a>接口设置（用来定义node可能会使用到的接口）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">type <span class="comment">//这个接口使用了什么类（来自接口目录）</span></div><div class="line"></div><div class="line"><span class="comment">//其余设置是特定于类的。可以是例如：</span></div><div class="line"></div><div class="line">transmitRange <span class="comment">//接口范围（meters）</span></div><div class="line"></div><div class="line">transmitSpeed <span class="comment">//接口的传输速度（bytes per second）</span></div></pre></td></tr></table></figure>
<h2 id="主机组设置（在Group或GroupN的命名空间使用）"><a href="#主机组设置（在Group或GroupN的命名空间使用）" class="headerlink" title="主机组设置（在Group或GroupN的命名空间使用）"></a>主机组设置（在Group或GroupN的命名空间使用）</h2>]]></content>
      
        <categories>
            
            <category> 计算机网络 </category>
            
            <category> 实验室 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 实验室 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 模拟器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[实验室心情全记录]]></title>
      <url>/2017/11/01/CN1/</url>
      <content type="html"><![CDATA[<p>又一个小时过去了呢。</p>
<p>第一个看到的文档是：《移动P2P网络中协同缓存的研究》，这个比较浅显比较傻，不是我需要的，主要讲的是一些显而易见的理想化的缓存策略，并没有涉及到一个复杂网络。主要讲的是缓存的接入控制策略：什么东四能进缓存？缓存替换策略以及缓存的一致性。</p>
]]></content>
      
        <categories>
            
            <category> 计算机网络 </category>
            
            <category> 实验室 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 实验室 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2017/11/01/Cloud%20RAN%20for%20Mobile%20Networks%E2%80%94%E2%80%94A%20Technology%20Overview/</url>
      <content type="html"><![CDATA[<hr>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>移动数据的传输容量正在连续增加。根据Cisco的预测，在智能手机与穿戴设备的推动下，从2012到2017年容量将增长13-fold。因此，移动网络运营商需要增加网络的capacity来满足日益增长的用户需求。当LTE（long term evolution）的spectral efficiency标准正逼近Shanon极限，增加网络capacity的最好方法要么是增加基站覆盖区域，创建一个结构复杂的多元小基站网络（HetSNets）要么是使用像多用户多输入多输出（MIMO）或是Massive MIMO这样的多根天线在同一频率时段服务于多个用户的技术。然而，这将导致更大的的小基站区间干扰水平（Growing inter-cell interference levels）以及更多的花费。</p>
<p>移动网络的TCO（total cost of ownership）包括了CAPEX（CAPital Expenditure）和OPEX（OPerating EXpenditure）。capex主要指关于网络构建的花费，网络构建可能会从网络规划一直到网址需求，RF硬件，baseband硬件（基带），软件许可，leased line连接（专用网络连接），安装，civil cost（民用花费），网站支持，像供电或者是冷却（cooling）。OPEX包括需要去操纵网络的花费，比如，站点出租，专用网络，电力，运营与保持，升级。CAPEX与OPEX在更多base station被部署之后都显著增加了。更具体地说（more specifically），CAPEX增加是因为基站是无线网络infrastructure基础设施中最昂贵的组成成分，而OPEX增加是因为基站覆盖区需要相当多的电力去驱动，比如，中国移动估计有72%的电力花费在基站覆盖区域（cell sites）。移动网络运营商需要支付网络建造，运营，保持和升级的费用；同时人均收入（ARPU）随之时间的增长保持不变甚至有所下降，因为典型的用户对数据的需求越来越多却希望为移动流量付更少的费用。像图1中所示，如果补救措施，移动网络运营商将有可能面对入不敷出的局面。 因此，在移动网络领域，优化了花费和能源消耗的新型建构方式变得必需。</p>
<p>C-RAN是一种新型的移动网络结构，有着接受上述所有挑战的能力。这个概念最初在论文9中被提出并且在6中被详细描述。在C-RAN中，baseband processing（基带处理）被中心化，被被放在一个虚拟的BBU pool中被诸多site分享。这意味着它可能能够适应nonuniform traffic非均匀流量并更加有效率地利用一些资源，比如，基站。由于这个特性在C-RAN结构中将用到比传统结构更少的BBU，而且C-RAN还有降低网络运营费用的潜能，这是因为电力与能量的消耗相较于传统的RAN结构已经被减少了。新的BBU可以更轻易地被添加被升级，从而改善网络的稳定性并使得网络更容易被维护。虚拟化的BBU pool可以被多个不同的网络运营商所分享，允许他们通过云服务来租RAN。由于多个网站的BBU在同一个pool中co-located（协作），他们彼此之间可以以更小的延迟时间进行通信，这样，被介绍给LTE-Advanced来增加spectral efficiency和throughput吞吐量的机械装置，比如说增强版的ICIC与CoMP都被facilitated，在两个基站覆盖区内实行的负载平衡方法也被facilitated。而且，网络的表现也被改善，例如通过减少BBU pool内部的移交操作的延时。<br>据China MObile Research Institute的猜想，C-RAN结构被移动网络运营商设为了目标，例如IBM、Alcatel-Lucent、华为、ZYTE、诺基亚西门子网络、Intel和Texas instruments。而且，在2020年的水平上来看，C-RAN被视为是典型的在5G中支持soft and green technologies的实现。然而，C-RAN并不是唯一可以对抗上述运营商们面临的挑战的选手，其他解决方式，包括small cells、being part of HetSNets and Massive MIMO。small cells的部署是户外hot spot闹区和室内coverage scenarios平均方案 。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[序列比较]]></title>
      <url>/2017/10/31/%E5%BA%8F%E5%88%97%E6%AF%94%E8%BE%83/</url>
      <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pixel</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">int</span> a, b;</div><div class="line">    Pixel(<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</div><div class="line">		a = x; b = y;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (a &lt; b) &#123;</div><div class="line">		<span class="keyword">if</span> (c &lt; a)<span class="keyword">return</span> c;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= a)<span class="keyword">return</span> a;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">if</span> (c &lt; b)<span class="keyword">return</span> c;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">return</span> b;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">alpha</span><span class="params">(<span class="keyword">char</span> fir, <span class="keyword">char</span> sec)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (fir == sec)<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;<span class="comment">/*</span></div><div class="line"><span class="comment">int S(int m, int n, string a, string b, int beta) &#123;</span></div><div class="line"><span class="comment">	for (int i = 0; i &lt;= m; i++)</span></div><div class="line"><span class="comment">		M[i][0] = i*beta;</span></div><div class="line"><span class="comment">	for (int i = 0; i &lt;= n; i++)</span></div><div class="line"><span class="comment">		M[0][i] = i*beta;</span></div><div class="line"><span class="comment">	for (int i = 1; i &lt;= m; i++)</span></div><div class="line"><span class="comment">		for (int j = 1; j &lt;= n; j++)</span></div><div class="line"><span class="comment">			M[i][j] = min(alpha(a[i-1],b[j-1]) + M[i-1][j-1], beta + M[i-1][j], beta + M[i][j-1]);</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">	return M[m ][n];</span></div><div class="line"><span class="comment">&#125;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">void back(int m, int n, string A,string B,int*result,int beta) &#123;</span></div><div class="line"><span class="comment">	if (m&lt;A.length()&amp;&amp;n&lt;B.length()&amp;&amp;M[m][n] +alpha(A[m],B[n])== M[m+1][n+1]) &#123;</span></div><div class="line"><span class="comment">		result[m] = 0;</span></div><div class="line"><span class="comment">		back(m + 1, n + 1, A,B,result,beta);</span></div><div class="line"><span class="comment">	&#125;</span></div><div class="line"><span class="comment">	else if (m&lt;A.length()&amp;&amp;n&lt;=B.length()&amp;&amp;M[m][n]+beta ==  M[m + 1][n]) &#123;</span></div><div class="line"><span class="comment">		result[m ] = 1;</span></div><div class="line"><span class="comment">		back(m +1, n, A,B,result,beta);</span></div><div class="line"><span class="comment">	&#125;</span></div><div class="line"><span class="comment">	else if(m&lt;=A.length()&amp;&amp;n&lt;B.length()) &#123;</span></div><div class="line"><span class="comment">		result[m] = -1;</span></div><div class="line"><span class="comment">		back(m, n + 1, A,B,result,beta);</span></div><div class="line"><span class="comment">	&#125;</span></div><div class="line"><span class="comment">&#125;*/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">SL</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="built_in">string</span> a, <span class="built_in">string</span> b, <span class="keyword">int</span> beta)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span>**M = <span class="keyword">new</span> <span class="keyword">int</span>*[<span class="number">2</span>];</div><div class="line">	M[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[b.length() + <span class="number">1</span>];</div><div class="line">	M[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[b.length() + <span class="number">1</span>];</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</div><div class="line">		M[<span class="number">0</span>][i] = beta*i;</div><div class="line">	&#125;	</div><div class="line">	M[<span class="number">1</span>][<span class="number">0</span>] = beta;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</div><div class="line">		M[<span class="number">1</span>][<span class="number">0</span>] = i*beta;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</div><div class="line">			M[<span class="number">1</span>][j] = min(alpha(a[i - <span class="number">1</span>], b[j - <span class="number">1</span>]) + M[<span class="number">0</span>][j - <span class="number">1</span>], beta + M[<span class="number">1</span>][j - <span class="number">1</span>], beta + M[<span class="number">0</span>][j]);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</div><div class="line">			M[<span class="number">0</span>][j] = M[<span class="number">1</span>][j];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">int</span> re = M[<span class="number">0</span>][n];</div><div class="line">	<span class="keyword">delete</span>[]M;</div><div class="line">	<span class="keyword">return</span> re;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DACA</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> r,<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="built_in">string</span> a, <span class="built_in">string</span> b, <span class="built_in">stack</span>&lt;Pixel&gt;*P,<span class="keyword">int</span> beta)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (x-o &lt;= <span class="number">1</span> || y-r &lt;= <span class="number">2</span>) &#123;</div><div class="line">		<span class="keyword">int</span>**M = <span class="keyword">new</span> <span class="keyword">int</span>*[x+<span class="number">1</span>];</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x -o+ <span class="number">1</span>; i++) &#123;</div><div class="line">			M[i] = <span class="keyword">new</span> <span class="keyword">int</span>[y -r+ <span class="number">1</span>];</div><div class="line">			M[i][<span class="number">0</span>] = beta*i;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= y-r; i++)</div><div class="line">			M[<span class="number">0</span>][i] = i*beta;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x-o; i++)</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= y-r; j++) &#123;</div><div class="line">				M[i][j] = min(alpha(a[i - <span class="number">1</span>], b[j - <span class="number">1</span>]) + M[i - <span class="number">1</span>][j - <span class="number">1</span>], beta + M[i][j - <span class="number">1</span>], beta + M[i - <span class="number">1</span>][j]);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = x-o; i &gt;= <span class="number">0</span>; ) &#123;</div><div class="line">		<span class="keyword">int</span> j = y - r;</div><div class="line">			<span class="keyword">for</span> (j=y-r; j &gt;= <span class="number">0</span>; ) &#123;</div><div class="line">				<span class="keyword">if</span> (i&gt;=<span class="number">1</span>&amp;&amp;j&gt;=<span class="number">1</span>&amp;&amp;M[i][j] == alpha(a[i<span class="number">-1</span>], b[j<span class="number">-1</span>]) + M[i - <span class="number">1</span>][j - <span class="number">1</span>]) &#123;</div><div class="line">					Pixel*p = <span class="keyword">new</span> Pixel(i - <span class="number">1</span>+o, j - <span class="number">1</span>+r);</div><div class="line">					P-&gt;push(*p);</div><div class="line">					i = i - <span class="number">1</span>; j = j - <span class="number">1</span>; </div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (i&gt;=<span class="number">1</span>&amp;&amp;j&gt;=<span class="number">0</span>&amp;&amp;M[i][j] == beta + M[i - <span class="number">1</span>][j]) &#123;</div><div class="line">					Pixel*p = <span class="keyword">new</span> Pixel(i - <span class="number">1</span>+o, j+r);</div><div class="line">					P-&gt;push(*p);</div><div class="line">					i -= <span class="number">1</span>; </div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">1</span>&amp;&amp;M[i][j] == beta + M[i][j - <span class="number">1</span>]) &#123;</div><div class="line">					Pixel*p = <span class="keyword">new</span> Pixel(i+o, j - <span class="number">1</span>+r);</div><div class="line">					P-&gt;push(*p);</div><div class="line">					j -= <span class="number">1</span>; </div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span> <span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (j == <span class="number">0</span> &amp;&amp; i == <span class="number">0</span>)<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="built_in">string</span> a2;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"here:"</span> &lt;&lt;( y-r) / <span class="number">2</span>  &lt;&lt; <span class="string">","</span> &lt;&lt; y-r &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">string</span> b2 =b.substr((y-r) / <span class="number">2</span> , y-r);</div><div class="line">	<span class="keyword">int</span> q[<span class="number">2</span>] = &#123; <span class="number">0</span>,<span class="number">0</span> &#125;;</div><div class="line">	<span class="keyword">int</span> min;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= x-o; i++) &#123;</div><div class="line">		a2 = a.substr(i, x-o);</div><div class="line">		q[<span class="number">0</span>]=SL(i, (y-r) / <span class="number">2</span>, a, b, <span class="number">1</span>);</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"done!"</span>;</div><div class="line">		q[<span class="number">0</span>]+=SL(x-o - i, y-r - (y-r) / <span class="number">2</span>, a2, b2, <span class="number">1</span>);</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"done!"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">		<span class="keyword">if</span> (i == <span class="number">0</span>)min = q[<span class="number">0</span>];</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">if</span> (min &gt; q[<span class="number">0</span>]) &#123;</div><div class="line">				min = q[<span class="number">0</span>];</div><div class="line">				q[<span class="number">1</span>] = i;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	min = q[<span class="number">1</span>]+o;</div><div class="line">	Pixel*p = <span class="keyword">new</span> Pixel(min, (y - r) / <span class="number">2</span> + r);</div><div class="line">	P-&gt;push(*p);</div><div class="line">	</div><div class="line">	DACA(o,r,min, (y-r) / <span class="number">2</span>+r, a, b, P, beta);</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"and here:"</span> &lt;&lt; min &lt;&lt; <span class="string">","</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	a2 = a.substr(min-o , x-o);</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"???"</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"hhhh"</span> &lt;&lt; x - min &lt;&lt; <span class="string">";;;"</span> &lt;&lt; y - y / <span class="number">2</span>;</div><div class="line">	DACA(min,(y-r)/<span class="number">2</span>+r,x  , y , a2, b2, P, beta);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="built_in">string</span> A, B;</div><div class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B) &#123;</div><div class="line">		<span class="built_in">stack</span>&lt;Pixel&gt;*P = <span class="keyword">new</span> <span class="built_in">stack</span>&lt;Pixel&gt;();</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; SL(A.length(), B.length(), A, B,<span class="number">1</span>);</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">		DACA(<span class="number">0</span>,<span class="number">0</span>,A.length(), B.length(), A, B, P, <span class="number">1</span>);</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"LLLLL"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">		<span class="keyword">while</span>(!(P-&gt;empty())) &#123;</div><div class="line">				Pixel p = (P-&gt;top());</div><div class="line">				P-&gt;pop();</div><div class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; p.a &lt;&lt; <span class="string">","</span> &lt;&lt; p.b &lt;&lt; <span class="string">")"</span>;</div><div class="line">			&#125;</div><div class="line">		<span class="keyword">delete</span> P;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"what!"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux、Vim、Git常用命令——简明扼要版]]></title>
      <url>/2017/10/31/OS/linux%E3%80%81vim%E3%80%81git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>第一次操作系统实验课记录：</p>
<h2 id="一。linux下常用命令"><a href="#一。linux下常用命令" class="headerlink" title="一。linux下常用命令"></a>一。linux下常用命令</h2><h2 id="二。vim编辑器用法命令"><a href="#二。vim编辑器用法命令" class="headerlink" title="二。vim编辑器用法命令"></a>二。vim编辑器用法命令</h2><ol>
<li>首先确保linux下安装有vim。可以使用上述命令sudo apt-get install vim来确定。如果已经安装了vim，会显示没有变化，否则会帮你安装vim。</li>
<li>然后就可以开始使用vim啦！</li>
</ol>
<blockquote>
<p>你使用 vim 或vim filename.suffix 进入了vim的命令模式。</p>
</blockquote>
<p>在命令模式下，不能进行文本编辑操作，需要按下A/a/I/i进入插入模式，在这个模式下可以像notepad一样进行文本编辑。</p>
<p><strong>如果使用第二种命令进入vim，vim将会自动帮你确定文件类型</strong>。这样说吧，比如你创建了一个yayicpp.cpp文件进入编辑，vim将会使代码高亮、进行括号匹配等操作。</p>
<blockquote>
<p>好的！进入文本编辑模式之后，你迫不及待地写了一段helloworld。代码完成之后，你觉得只打印一行helloworld不太够，你想知道有没有类似于VS环境中那种Ctrl+C和Ctrl+V的操作。</p>
</blockquote>
<p>其实是有的。这个时候需要按下Esc重新进入命令模式。在命令模式下有很多功能组合，上述的复制粘贴就是其中一种，但是这里并不想以复制粘贴作为第一个被介绍的命令，让我们先从光标的移动开始。</p>
<ol>
<li>按下h键，光标左移；j光标下移；k光标上移；l光标右移。</li>
<li>按下d键进入删除模式，这时按下h可删除光标左侧的一个字符，按下j可删除光标所在行以及下面一行；按下k可删除光标所在行与其上面一行；按下l可删除光标所在的字符。双击d键删除光标所在行。</li>
<li>按下u键可以撤销前一步所做的改变。</li>
<li>按下V（Shift+v）或是v可以进入到一个选择的可视化界面，同样可以使用hjkl控制选择范围，v按照字符选择，V按照行数选择。选择完成之后按下y就可以复制选定内容。按下p就可以将复制内容粘贴到选定的位置。</li>
<li>按两下y可以复制光标所在行。</li>
</ol>
<blockquote>
<p>写到这里，你觉得可以了，可以从vim里面退出来了。</p>
</blockquote>
<ol>
<li>在命令模式下输入冒号，进入最后行模式。在最低端出现了光标。</li>
<li>在光标位置输入w，保存文件。</li>
<li>输入q，退出。</li>
<li>这些命令可以进行组合wq。wq可以用x替代。</li>
</ol>
<blockquote>
<p>你进入了最后行模式，又不想退出了，想继续编辑。</p>
</blockquote>
<ol>
<li>按下Esc或者Backspace可以回到命令模式。</li>
</ol>
<h2 id="三。git初步使用"><a href="#三。git初步使用" class="headerlink" title="三。git初步使用"></a>三。git初步使用</h2><p>git是一个强大的版本管理工具，是Linus写的。这个人emmmmm…技术天才有些狂妄。</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[背包问题初涉]]></title>
      <url>/2017/10/31/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<hr>
<p>算法上机考试，怎么说，虽然没做出来但是收获很多？好吧也只能这么安慰自己了</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="comment">//硬币。存储硬币的价值及其对应个数</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coins</span>&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="keyword">int</span> value;</div><div class="line">	<span class="keyword">int</span> num;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//更小值函数。若值为0，代表不可能，返回另一个值，否则返回更小值</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mini</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (a == <span class="number">0</span>)<span class="keyword">return</span> b;</div><div class="line">	<span class="keyword">if</span> (b == <span class="number">0</span>)<span class="keyword">return</span> a;</div><div class="line">	<span class="keyword">if</span> (a &gt; b)<span class="keyword">return</span> b;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">return</span> a;</div><div class="line">&#125;</div><div class="line"><span class="comment">//int max(int a,int b)&#123;</span></div><div class="line"><span class="comment">//	if(a&gt;b)return a;</span></div><div class="line"><span class="comment">//	else return b;</span></div><div class="line"><span class="comment">//&#125;</span></div><div class="line"><span class="comment">//int comp(const void *a,const void *b)&#123;</span></div><div class="line"><span class="comment">//	Coins* A=(Coins*)a,*B=(Coins*)b;</span></div><div class="line"><span class="comment">//	if(A-&gt;value&gt;B-&gt;value)return -1;</span></div><div class="line"><span class="comment">//	else if (A-&gt;value&lt;B-&gt;value)return 1;</span></div><div class="line"><span class="comment">//	else return 0;</span></div><div class="line"><span class="comment">//&#125;</span></div><div class="line"><span class="comment">//找零钱的函数，coins存储了各种硬币的面值与个数，n是硬币种数（coins的长度），m是找零的钱数。</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetCoin</span><span class="params">(Coins*coins, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">//新建一个二维数组用于存储在每一个要找的钱数下用i种硬币最少用几个硬币</span></div><div class="line"></div><div class="line">	<span class="keyword">int</span>**M = <span class="keyword">new</span> <span class="keyword">int</span>*[<span class="number">2</span>]; </div><div class="line">	M[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span> [m + <span class="number">1</span>];</div><div class="line">	M[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span> [m + <span class="number">1</span>];</div><div class="line"></div><div class="line">	<span class="comment">//初始时，用0个硬币找除0以外的钱数，不可能。</span></div><div class="line">	<span class="comment">//且用0作为初始值便于后续计算。</span></div><div class="line"></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</div><div class="line">		M[<span class="number">0</span>][i] = <span class="number">0</span>; M[<span class="number">1</span>][i] = <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;	<span class="comment">//对前i种硬币</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;	<span class="comment">//要找j的零钱</span></div><div class="line">			<span class="keyword">int</span> dola = M[<span class="number">0</span>][j];	<span class="comment">//保存未更新之前的值</span></div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= coins[i].num; k++) &#123;	<span class="comment">//对这种硬币的每个数量</span></div><div class="line">				<span class="keyword">if</span> ((j - k*(coins[i].value) &lt; <span class="number">0</span>)) &#123;	<span class="comment">//若k个硬币总钱数大于j，不可能。break</span></div><div class="line">					M[<span class="number">0</span>][j] = M[<span class="number">0</span>][j]; M[<span class="number">1</span>][j] = M[<span class="number">0</span>][j]; <span class="keyword">break</span>;</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				<span class="keyword">if</span> ((M[<span class="number">0</span>][j - k*(coins[i].value)] != <span class="number">0</span>))</div><div class="line"></div><div class="line">				<span class="comment">//否则。若满足条件，说明在M[0][j-k*(coins[i].value)]处有满足条件的解，与M[0][j]计算更好的值。此时这里一定有非0解</span></div><div class="line"></div><div class="line">					M[<span class="number">0</span>][j] = mini(M[<span class="number">0</span>][j], k + M[<span class="number">0</span>][j - k*(coins[i].value)]);</div><div class="line">				<span class="keyword">else</span> <span class="keyword">if</span> ((M[<span class="number">0</span>][j - k*(coins[i].value)] == <span class="number">0</span>)) &#123;<span class="comment">//否则，不一定存在非0解</span></div><div class="line">					<span class="keyword">if</span> (k*(coins[i].value) == j) &#123;<span class="comment">//若存在k个硬币正好找j元，更新解</span></div><div class="line">						M[<span class="number">0</span>][j] = mini(M[<span class="number">0</span>][j], k);</div><div class="line">						<span class="comment">//M[1][j] = M[0][j];</span></div><div class="line">						<span class="comment">//M[0][j] = dola;</span></div><div class="line">						<span class="comment">//break;不行！</span></div><div class="line">					&#125;</div><div class="line">					<span class="keyword">else</span> M[<span class="number">0</span>][j] = M[<span class="number">0</span>][j];<span class="comment">//否则，不更新解</span></div><div class="line">				&#125;</div><div class="line">				</div><div class="line">		&#125;</div><div class="line">			<span class="comment">//将M[0]转移到M[1]，M[0]恢复原值继续下一轮计算。这样可以防止对硬币i使用的数目多于现有数目的情况</span></div><div class="line"></div><div class="line">			M[<span class="number">1</span>][j] = M[<span class="number">0</span>][j];</div><div class="line">			M[<span class="number">0</span>][j] = dola;</div><div class="line"><span class="comment">//			cout &lt;&lt; M[1][j] &lt;&lt; " ,";</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++)M[<span class="number">0</span>][j] = M[<span class="number">1</span>][j];<span class="comment">//把新值给M[0]，进行对下一种硬币的分析。</span></div><div class="line">	<span class="comment">//	cout &lt;&lt; endl;</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> M[<span class="number">0</span>][m];<span class="comment">//返回最优解</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//int Getcoin(int*coins,int m,int n,int**M,int**N)&#123;</span></div><div class="line"><span class="comment">//	int*resu = new int[n], *resunum = new int[n];</span></div><div class="line"><span class="comment">//	for(int i=0;i&lt;=m;i++)&#123;N[0][i]=0;</span></div><div class="line"><span class="comment">//	M[0][i]=0;&#125;</span></div><div class="line"><span class="comment">//	for(int i=0;i&lt;2;i++)&#123;N[i][0]=0;</span></div><div class="line"><span class="comment">//	M[i][0]=0;&#125;</span></div><div class="line"><span class="comment">//	for(int i=1;i&lt;=n;i++)&#123;</span></div><div class="line"><span class="comment">//		for(int j=1;j&lt;=m;j++)&#123;</span></div><div class="line"><span class="comment">//			//cout &lt;&lt; "the j" &lt;&lt; j &lt;&lt; endl;</span></div><div class="line"><span class="comment">//			if (coins[i - 1] &gt; j) &#123; M[1][j] = M[0][j]; N[1][j] = N[0][j];  &#125;</span></div><div class="line"><span class="comment">//			else&#123;</span></div><div class="line"><span class="comment">//				M[1][j]=max(M[0][j],coins[i-1]+M[0][j-coins[i-1]]);</span></div><div class="line"><span class="comment">//				if(M[1][j]==M[0][j])N[1][j]=N[0][j];</span></div><div class="line"><span class="comment">//				else if(M[1][j]==coins[i-1]+M[0][j-coins[i-1]]) N[1][j]=1+N[0][j-coins[i-1]];</span></div><div class="line"><span class="comment">//				else N[1][j] = N[0][j] &lt; N[0][j - coins[i - 1]] ? N[0][j] : 1+N[0][j - coins[i - 1]];</span></div><div class="line"><span class="comment">//		&#125;</span></div><div class="line"><span class="comment">//	&#125;</span></div><div class="line"><span class="comment">//		for (int j = 0; j &lt;= m; j++) &#123;</span></div><div class="line"><span class="comment">//			M[0][j] = M[1][j];</span></div><div class="line"><span class="comment">//			N[0][j] = N[1][j];</span></div><div class="line"><span class="comment">//			cout &lt;&lt; "(" &lt;&lt; M[0][j] &lt;&lt; "," &lt;&lt; N[0][j] &lt;&lt; ")";</span></div><div class="line"><span class="comment">//		&#125;</span></div><div class="line"><span class="comment">//		cout &lt;&lt;i&lt;&lt;" , "&lt;&lt;coins[i-1]&lt;&lt; endl;</span></div><div class="line"><span class="comment">//		resu[i - 1] = M[0][m];</span></div><div class="line"><span class="comment">//		resunum[i - 1] = N[0][m];</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//	&#125;</span></div><div class="line"><span class="comment">//	int min=-1;</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//	for (int i = 0; i &lt; n; i++) &#123;</span></div><div class="line"><span class="comment">////		cout &lt;&lt; "(" &lt;&lt; resu[i] &lt;&lt; "," &lt;&lt; resunum[i] &lt;&lt; ")";</span></div><div class="line"><span class="comment">//		if (resu[i] == m) &#123;</span></div><div class="line"><span class="comment">//			if (min == -1)min = resunum[i];</span></div><div class="line"><span class="comment">//			if (resunum[i] &lt; min)min = resunum[i];</span></div><div class="line"><span class="comment">//		&#125;</span></div><div class="line"><span class="comment">//	&#125;</span></div><div class="line"><span class="comment">//	return min;</span></div><div class="line"><span class="comment">//	</span></div><div class="line"><span class="comment">//&#125;</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> n;</div><div class="line">		<span class="built_in">cin</span> &gt;&gt; n;</div><div class="line">		Coins*coins = <span class="keyword">new</span> Coins[n];</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">			<span class="built_in">cin</span> &gt;&gt; coins[i].value &gt;&gt; coins[i].num;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> m;</div><div class="line">		<span class="built_in">cin</span> &gt;&gt; m;</div><div class="line"></div><div class="line">		<span class="comment">//如果要找的钱数是0，最少需要0个硬币</span></div><div class="line">		<span class="keyword">if</span> (m == <span class="number">0</span>) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>; <span class="keyword">return</span> <span class="number">0</span>; &#125;</div><div class="line">		<span class="comment">//	qsort(coins,n,sizeof(coins[0]),comp);</span></div><div class="line">		<span class="comment">//	int sum=0;</span></div><div class="line">		<span class="comment">//	for(int i=0;i&lt;n;i++)</span></div><div class="line">		<span class="comment">//		sum+=coins[i].num;</span></div><div class="line">		<span class="comment">//	int*Mycoin=new int[sum];</span></div><div class="line">		<span class="comment">//	int soum=sum;</span></div><div class="line">		<span class="comment">//	sum=coins[0].num;</span></div><div class="line">		<span class="comment">///*	for(int i=0,j=0;i&lt;soum;i++)&#123;</span></div><div class="line">		<span class="comment">//		if(i==sum)&#123;sum+=coins[j+1].num;j++;&#125;</span></div><div class="line">		<span class="comment">//		Mycoin[i]=coins[j].value;</span></div><div class="line">		<span class="comment">//		cout &lt;&lt; Mycoin[i] &lt;&lt; " ";</span></div><div class="line">		<span class="comment">//	&#125;*/</span></div><div class="line">		<span class="comment">//		int k = 0;</span></div><div class="line">		<span class="comment">//		for (int i = 0; i&lt;n; i++) &#123;</span></div><div class="line">		<span class="comment">//			for (int j = 0; j &lt; coins[i].num;j++) &#123;</span></div><div class="line">		<span class="comment">//				Mycoin[k] = coins[i].value;</span></div><div class="line">		<span class="comment">//				cout &lt;&lt; Mycoin[k] &lt;&lt; " ";</span></div><div class="line">		<span class="comment">//				k++;</span></div><div class="line">		<span class="comment">//			&#125;</span></div><div class="line">		<span class="comment">//		&#125;</span></div><div class="line">		<span class="comment">//		cout &lt;&lt; "totally" &lt;&lt; soum &lt;&lt; endl;</span></div><div class="line">		<span class="comment">//		int**M=new int*[2];</span></div><div class="line">		<span class="comment">//		for(int i=0;i&lt;2;i++)M[i]=new int[m+1];</span></div><div class="line">		<span class="comment">//		int**N=new int*[2];</span></div><div class="line">		<span class="comment">//		for(int i=0;i&lt;2;i++)N[i]=new int[m+1];</span></div><div class="line">		</div><div class="line">			<span class="comment">// pp=Getcoin(Mycoin,m,soum,M,N);</span></div><div class="line">			<span class="comment">//cout &lt;&lt; pp &lt;&lt; endl;</span></div><div class="line"></div><div class="line">		<span class="keyword">int</span> pp;</div><div class="line">		pp = GetCoin(coins, n, m);</div><div class="line">		<span class="comment">//若最终返回0即为不可能，输出-1。</span></div><div class="line">		<span class="keyword">if</span> (pp != <span class="number">0</span>)<span class="built_in">cout</span> &lt;&lt; pp;</div><div class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[归并、快排、堆排序]]></title>
      <url>/2017/10/31/%E5%BD%92%E5%B9%B6%E3%80%81%E5%BF%AB%E6%8E%92%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<hr>
<p>归并排序算法是分治策略的一种体现。所谓分治策略就是把一个大问题分解成几个较小的部分，通过递归分别解决几个小问题，然后再在线性时间内将几个小问题的解合并成一个完整的解。</p>
<hr>
<h2 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h2><p>归并排序也是一种排序算法。<br>问题：将n个数由从小到大地排序。<br>归并提出的解决是：</p>
<ol>
<li>将这列数分成两半</li>
<li>递归地将每一半排序</li>
<li>将两个有序列合并成一整列</li>
</ol>
<p>归并排序在做串的切分时不考虑大小因素，只从中间切分。于是在合并时便需要对两个有序串做一定处理才能保证结果串的有序性。<br>为此，一个容易想到的方法是创建一个临时的数组存储有序列。如图：</p>
<p><img src="http://img.blog.csdn.net/20170409215800372?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXVndXN0eV8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>每次都比较1串与2串当前位置元素大小，将较小的那一个输出到TMP数组中当前位置并加一，将输出串的当前位置加一。直到两个串都输出完毕。<br>这种方式所用的额外空间是O(n)，只需要O(n)次比较。</p>
<p>实际上，归并排序一般是递归进行一直到每个串的长度是1，主要运算过程全部落在合并上面。下面由递归式分析归并排序算法的时间复杂度。</p>
<p><strong>归并时间空间复杂度分析：</strong></p>
<p>设T(n)表示该算法在规模为n的输入实例上最坏的运行时间，假设n是2的整数次幂，可以得到递推公式如下：</p>
<p><img src="http://img.blog.csdn.net/20170409221537744?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXVndXN0eV8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="公式"></p>
<p>则有递推关系：</p>
<p><img src="http://img.blog.csdn.net/20170409222307354?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXVndXN0eV8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>将这些时间都加在一起即为nlog2N。即归并的时间复杂度是O(nlogn)级别。</p>
<p>下面将严格证明这个命题：</p>
<p>——————这个过程线省略————</p>
<p><strong>归并的代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Array.prototype.mergeSort=function(s,e,b)&#123;  </div><div class="line">  <span class="comment">//start,end,temp</span></div><div class="line">   <span class="keyword">if</span>(s==<span class="keyword">null</span>)s=<span class="number">0</span>;</div><div class="line">   <span class="keyword">if</span>(e==<span class="keyword">null</span>)e=<span class="keyword">this</span>.length-<span class="number">1</span>;</div><div class="line">   <span class="keyword">if</span>(b==<span class="keyword">null</span>)b=<span class="keyword">new</span> Array(<span class="keyword">this</span>.length);</div><div class="line">   <span class="keyword">if</span>(s&gt;=e)<span class="keyword">return</span>;</div><div class="line">   var m=(s+e)&gt;&gt;<span class="number">1</span>;  </div><div class="line">   <span class="comment">//取中间值</span></div><div class="line">   <span class="keyword">this</span>.mergeSort(s,m,b);</div><div class="line">   <span class="keyword">this</span>.mergeSort(m+<span class="number">1</span>,e,b);</div><div class="line">   <span class="keyword">for</span>(var i=s,j=s,k=m+<span class="number">1</span>;i&lt;=e;++i)</div><div class="line">      b[i]=<span class="keyword">this</span>[(k&gt;e||j&lt;=m&amp;&amp;<span class="keyword">this</span>[j]&lt;<span class="keyword">this</span>[k])?j++:k++];</div><div class="line">   <span class="keyword">for</span>(var i=s;i&lt;=e;++i)</div><div class="line">      <span class="keyword">this</span>[i]=b[i];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>快排提供的解决是：</p>
<ol>
<li>选择一个枢轴，小于枢轴的到左边，大于枢轴的到右边</li>
<li>对两边分别递归地使用快排</li>
<li>合并</li>
</ol>
<p>与归并相似的一点是，二者都采用递归方法解决问题，但是归并的排序工作都留在了合并过程中完成，而快排正与之相反，排序工作都在分割的过程中完成。</p>
<p><img src="http://img.blog.csdn.net/20170409232255961?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXVndXN0eV8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="KP"></p>
<p>从图中可以明显看出，快排最终得到的串就是一个有序的串。</p>
<p><strong>快排时间空间复杂度：</strong></p>
<p>快排算法依赖于枢轴PIVOT的选择。当选择的枢轴越接近中间值，树越接近于完全树的树高，算法效率越高，最好可达到O(nlogn)。糟糕的枢轴选择将会使效率急速下降，甚至达到O(n*n)的级别。<br>于是，当一个串越是接近于无序，快排的效率越高。快排的平均时间复杂度是O(nlogn)，是所有排序算法中平均时间复杂度最好的算法。<br>快排需要栈的辅助，其空间复杂度是O(logn)。</p>
<p><strong>快排的代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Array.prototype.quikSort=function(s,e)&#123;</div><div class="line">  <span class="comment">//start,end</span></div><div class="line">   <span class="keyword">if</span>(s==<span class="keyword">null</span>)s=<span class="number">0</span>;</div><div class="line">   <span class="keyword">if</span>(e==<span class="keyword">null</span>)e=<span class="keyword">this</span>.length-<span class="number">1</span>;</div><div class="line">   <span class="keyword">if</span>(s&gt;=e)<span class="keyword">return</span>;</div><div class="line">   <span class="keyword">this</span>.swap((s+e)&gt;&gt;<span class="number">1</span>,e);</div><div class="line">   var index=s-<span class="number">1</span>;</div><div class="line">   <span class="keyword">for</span>(var i=s;i&lt;=e;++i)</div><div class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>[i]&lt;=<span class="keyword">this</span>[e])</div><div class="line">         <span class="keyword">this</span>.swap(i,++index);</div><div class="line">   <span class="keyword">this</span>.quickSort(s,index-<span class="number">1</span>);</div><div class="line">   <span class="keyword">this</span>.quickSort(index+<span class="number">1</span>,e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><hr>
<p>堆排序数据结构结课的时候还考了呢。怕是写错了吧当时。哎陈年旧事，不提也罢。</p>
<p>  p又查到说，堆的建立过程就是不断插入的过程，所以可能根本不是完全建好了一个堆才去改变，也许是边建边改变。（有道云笔记你的markdown真的问题还很大</p>
<hr>
<p>堆是一种数据结构，可以看做是一棵任一孩子结点都小于（大顶堆）或都大于（小顶堆）父亲结点的完全二叉树。这样根结点总是整个堆中最大或小的结点，每次只需将根取出来即可保证有序。但是，每添加或减少一个结点都需要对堆进行必要的维护。<br>于是，堆排序中最关键的操作就是将一个序列调整成为堆。</p>
<p>堆排序给出的解决方法：</p>
<ol>
<li>将序列建成堆</li>
<li>迭代地取根进入有序队列并调整堆直到堆为有序序列</li>
</ol>
<p>堆的产生过程其实就是一个调整过程，下面给出堆的调整过程（以大根堆为例）：</p>
<p><img src="http://img.blog.csdn.net/20170410000407454?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXVndXN0eV8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>最终取出数字的顺序即为最终顺序。</p>
<p>堆排序适合于结点数较多情况下的要求前几个结点。当记录数较少时，不推荐使用堆排序。</p>
<p>hash表+堆排序是处理海量数据的绝佳组合。</p>
<p><strong>堆排序时间空间复杂度</strong></p>
<p>完全二叉树高度log(n+1)，即对每个节点进行调整的时间复杂度是O(logn)，包括建堆的时间耗费与取值和调整，整个算法时间复杂度是O(nlogn)。额外空间只有temp用来存取出的数，O(1)。</p>
<p><strong>堆排序的代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Array.prototype.heapSort=function()&#123;</div><div class="line">   <span class="keyword">for</span>(var i=<span class="number">1</span>;i&lt;<span class="keyword">this</span>.length;++i)&#123;</div><div class="line">      <span class="keyword">for</span>(var j=i,k=(j-<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;k&gt;=<span class="number">0</span>;j=k,k=(k-<span class="number">1</span>)&gt;&gt;<span class="number">1</span>)&#123;</div><div class="line">         <span class="keyword">if</span>(<span class="keyword">this</span>[k]&gt;=<span class="keyword">this</span>[j])<span class="keyword">break</span>;</div><div class="line">         <span class="keyword">this</span>.swap(j,k);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span>(var i=<span class="keyword">this</span>.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;--i)&#123;</div><div class="line">      <span class="keyword">this</span>.swap(<span class="number">0</span>,i);</div><div class="line">      <span class="keyword">for</span>(var j=<span class="number">0</span>;k=(j+<span class="number">1</span>)&lt;&lt;<span class="number">1</span>;k&lt;=i;j=k,k=(k+<span class="number">1</span>)&lt;&lt;<span class="number">1</span>)&#123;</div><div class="line">         <span class="keyword">if</span>(k==i||<span class="keyword">this</span>[k]&lt;<span class="keyword">this</span>[k-<span class="number">1</span>])--k;</div><div class="line">         <span class="keyword">if</span>(<span class="keyword">this</span>[k]&lt;=<span class="keyword">this</span>[j])braek;</div><div class="line">         <span class="keyword">this</span>.swap(j,k);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>本篇文章中的代码部分来自于作者twobin于网址<a href="http://www.cnblogs.com/twobin的博文《排序算法性能比较》。" target="_blank" rel="external">http://www.cnblogs.com/twobin的博文《排序算法性能比较》。</a></p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在MFC中创建控制台]]></title>
      <url>/2017/10/31/%E5%9C%A8MFC%E4%B8%AD%E5%88%9B%E5%BB%BA%E6%8E%A7%E5%88%B6%E5%8F%B0/</url>
      <content type="html"><![CDATA[<hr>
<p>距离上次写已经一周了。浑浑噩噩的愚人节，浑浑噩噩的一周。<br>但是依然要加油啊~要明确自己想要的是什么！开开心心地、充实地活着才最重要！<br>加油！</p>
<hr>
<p>我用的VS是2015版，之前找了一些在MFC中同时显示窗口与命令行的方法，我可以用的只记住了一个，先记录如下：</p>
<p>在×.cpp的InitInstance()中的CWinAPPEx::InitInstance()前加上以下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></div><div class="line">   AllocConsole()</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>以后可以使用_cprintf()打印字符串，需要在使用该函数的文件添加头文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;conio.h&gt;</span></span></div></pre></td></tr></table></figure>
<p><strong>切记！这个头文件必须要在#include”stdafx.h”语句之后写，否则会报错！</strong></p>
<p>使用步骤如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CString str=<span class="string">""</span>;</div><div class="line">USES_CONVERSION;</div><div class="line">LPSTR lp=T2A(str);</div><div class="line">_cprintf(lp);</div></pre></td></tr></table></figure>
<p>这段代码完成了将CString类型的str输出的任务。</p>
]]></content>
      
        
        <tags>
            
            <tag> MFC </tag>
            
            <tag> 可视化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[树莓派解析域名失败导致apt-get update不可用]]></title>
      <url>/2017/10/31/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%A7%A3%E6%9E%90%E5%9F%9F%E5%90%8D%E5%A4%B1%E8%B4%A5%E5%AF%BC%E8%87%B4apt-get%20update%E4%B8%8D%E5%8F%AF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>捣鼓了一下午，查了n多网站。从删除文件到修改源，终于发现一直提示解析域名失败的原因是树莓派没有连上网orz…<br>没有HDMI，我是通过树莓派的WiFi和电脑连上，电脑插了网线。<br>后来把网线给了树莓派，电脑连树莓派的WiFi，电脑直接跳出了学校网络的登录界面，在电脑上面登录之后，这次开始更新软件源。</p>
<a id="more"></a>
<p>除了这个，我还按照网上各路大神的说法，改了好几个地方，这里一一记下来，以便以后查找。</p>
<ol>
<li>删除某个目录的内容，只记得是/ect/apt/…/partial什么的</li>
<li>修改/etc/apt/resolv.conf的内容，数字改成8.8.8.8</li>
<li>修改源。据说给的源是国外源，速度慢。国内有很多源可用，网址如下：<a href="http://shumeipai.nxez.com/2013/08/31/raspbian-chinese-software-source.html" target="_blank" rel="external">http://shumeipai.nxez.com/2013/08/31/raspbian-chinese-software-source.html</a></li>
</ol>
<hr>
<p>除此之外，倒是了解了一些些关于远程与vnc。<br>实现这两者需要安装东西，并不是装了系统就可以连远程的。这个百度一下很多教程。</p>
<hr>
<p>另外是在Linux命令行下的vi(vim)与nano编辑器。<br>相较而言当然是nano好用。<br>用nano编辑/etc/apt/s文件命令：sudo nano /etc/apt/s<br>用vi编辑只需将nano改为vi<br>nano内有提示，只需按照提示来就好，而vi就比较复杂。<br><a href="http://shumeipai.nxez.com/2013/12/26/linux-on-vim-editor-tutorials.html" target="_blank" rel="external">http://shumeipai.nxez.com/2013/12/26/linux-on-vim-editor-tutorials.html</a><br>该网址内容详尽。注意的是，vi命令模式不是命令行界面，按下esc并不会有界面上的变化，并不是教程错了。</p>
<hr>
<p>Linux下的文件相关命令</p>
]]></content>
      
        
        <tags>
            
            <tag> 物联网 </tag>
            
            <tag> OS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OS Lab1]]></title>
      <url>/2017/10/31/OS/OS-Lab12/</url>
      <content type="html"><![CDATA[<h1 id="OSLab1：MIT的Lab1"><a href="#OSLab1：MIT的Lab1" class="headerlink" title="OSLab1：MIT的Lab1"></a>OSLab1：MIT的Lab1</h1><p>这个作业真的非常令人心烦，现在到了检查作业的紧要关头啦！</p>
]]></content>
      
        
        <tags>
            
            <tag> OS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[first try]]></title>
      <url>/2017/10/29/first-try/</url>
      <content type="html"><![CDATA[<h1 id="yayi’s-new-blog"><a href="#yayi’s-new-blog" class="headerlink" title="yayi’s new blog"></a>yayi’s new blog</h1><p>what !你为什么这么多事啊！？</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/10/29/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Lab5_Document]]></title>
      <url>/2017/01/05/OS/Lab5_Document/</url>
      <content type="html"><![CDATA[<h1 id="Lab5-Document"><a href="#Lab5-Document" class="headerlink" title="Lab5-Document"></a>Lab5-Document</h1><h2 id="File-system-preliminaries"><a href="#File-system-preliminaries" class="headerlink" title="File system preliminaries"></a>File system preliminaries</h2><h3 id="Sectors-and-Blocks"><a href="#Sectors-and-Blocks" class="headerlink" title="Sectors and Blocks"></a>Sectors and Blocks</h3><p>大多数磁盘并不是以字节为单位进行读写，而是以512字节为单位的扇区进行。文件系统经常是以<strong>块</strong>为单位申请使用磁盘。扇区大小是磁盘的性质，块则是os使用磁盘的一个方面。文件系统的块大小必须是扇区大小的整数倍。</p>
<p>在unix的x86系统中，使用的块大小是512字节。现今由于存储介质的日益廉价以及对存储空间大粒度的操作的高效性，多数os都是用了更大的块。jos使用4k的块，正好和页大小一样。</p>
<h3 id="Superblocks"><a href="#Superblocks" class="headerlink" title="Superblocks"></a>Superblocks</h3><p>文件系统一般会把文件的meta-data保存在一个便于访问的地方，这些data包括块大小、磁盘大小等数据，保存这些meta-data的地方被称为<strong>超级块</strong>。</p>
<p>这里的文件系统只有一个超级块，他将会在block1。真正的文件系统一般会有很多个超级块，这样当某一个超级块崩溃的时候，其他的超级块还能正常使用。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-28/52660650.jpg" alt=""></p>
<p>下面来看一下超级块的数据结构<code>struct Super</code>，它在inc/fs.h中。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-28/36171430.jpg" alt=""></p>
<h3 id="File-Meta-data"><a href="#File-Meta-data" class="headerlink" title="File Meta-data"></a>File Meta-data</h3><p>一个文件的meta-data在这里是使用<code>struct File</code>进行描述的，下面是File的结构：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-28/11329249.jpg" alt=""></p>
<p>更加直观的是这样：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-28/46584041.jpg" alt=""></p>
<p>由于我们的文件系统没有inode，因此将metadat存在磁盘的目录入口处。</p>
<p>在这里的文件系统中，File结构将会被用到内存以及磁盘上。从上图中可以看到，File结构中有一个大小是10的数组f_firect以及一个32位数t_indirect。他们分别存储着文件数据的位置信息。其中文件支持direct的40kB文件，如果大小大于40KB，可以利用indirect块的一共1024个其他block来存储文件，一共是4M+4K的文件大小。实际上，文件系统为了支持大文件，可能会支持2或是3个indirect块。</p>
<h3 id="Directories-versus-Regular-Files"><a href="#Directories-versus-Regular-Files" class="headerlink" title="Directories versus Regular Files"></a>Directories versus Regular Files</h3><p>在文件系统中一共分为两种文件节点，一种是目录节点，另一种是文件节点。上述的File结构的f_type域便是用来区分这两种节点的。这里的文件系统对待文件与目录基本一样，唯一不同的是，文件系统不会对与文件关联的块进行解释，而会对目录——一堆文件结构进行解释。</p>
<p>超级块中包含根目录的File结构。</p>
<h2 id="The-File-System"><a href="#The-File-System" class="headerlink" title="The File System"></a>The File System</h2><h3 id="Disk-Access"><a href="#Disk-Access" class="headerlink" title="Disk Access"></a>Disk Access</h3><p>我们将会把IDE磁盘驱动作为用户层面文件系统进程的一部分，稍微修改内核代码来使得文件系统进程拥有独自访问磁盘的权限。</p>
<p>只要我们是依赖PIO-based磁盘，不使用磁盘的中断，完成磁盘访问是很容易的。使用中断驱动的设备驱动也很简单，但是由于kernel需要捕获并处理这些中断，就会变得很复杂。</p>
<p>x86处理器在eflags寄存器上提供了IOPL位，他决定了一个进程能不能执行一i额特殊的设备指令。由于我们需要访问的所有IDE磁盘寄存器都位于x86的IO空间中，而不是虚拟地址空间里面，所以给文件系统环境提供IO特权是我们想要的，允许文件系统访问这些寄存器。 实际上，EFLAGS寄存器中的IOPL位为内核提供了一个简单的“全有或全无”方法来控制用户模式代码是否可以访问IO空间。在这里，我们希望只有文件系统进程可以访问IO空间。</p>
<blockquote>
<p><strong>Exercise 1</strong></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-28/46809633.jpg" alt=""><br>直接给出代码：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-28/44896039.jpg" alt=""></p>
</blockquote>
<p>exe1完成之后，可以通过fs/io.c的测试：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-28/5646299.jpg" alt=""></p>
<blockquote>
<p>Question</p>
<ol>
<li>Do you have to do anything else to ensure that this I/O privilege setting is saved and restored properly when you subsequently switch from one environment to another? Why? </li>
</ol>
<p>没有。因为它是在eflags中存在的，在进程间切换时对应的寄存器状态会被保存好，随着切换一同被复位。</p>
</blockquote>
<h2 id="The-Block-Cache"><a href="#The-Block-Cache" class="headerlink" title="The Block Cache"></a>The Block Cache</h2><p>在我们的文件系统中，将会实现一个简单的cache。<br>我们的文件系统只能处理3GB以及更小的磁盘，在该文件系统进程的虚拟地址空间上留了从<strong>DISKMAP</strong>到<strong>DISKMAP+DISKMAX</strong>的3GB大小的空间，以此作为磁盘的内存空间映射。<strong>diskaddr</strong>函数可以将磁盘的块号翻译成为虚拟地址：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-28/40046107.jpg" alt=""><br>其中<strong>BLKSIZE</strong>是块大小，这里与页大小相同。看到，该函数拒绝翻译块0与块1的虚拟地址。<br>既然我们的文件系统进程已经有了自己的虚拟地址空间，接下来需要做的就只是实现文件访问。由于现代磁盘大于3GB，因此在32位机器上的真正的文件系统实现会很麻烦。 这种缓冲区高速缓存管理方法在64位地址空间的机器上仍然是合理的。（？）</p>
<p>当然，把整个硬盘读进内存是很荒唐的做法，因此我们实现了一个<strong>demand paging</strong>机制。它只是允许我们在发生缺页中断的时候把缺页对应的硬盘的内容读进内存。</p>
<p>在写exer2之前，首先读读写硬盘的代码：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-28/6929946.jpg" alt=""><br>这是读硬盘的代码。参数分别是分区号、读入地址以及分区数。</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-29/86035925.jpg" alt=""><br>这是写硬盘的代码。参数分别是分区号、源虚拟地址以及分区数。</p>
<blockquote>
<p><strong>Exercise 2</strong><br>根据提示写出代码：<br>bc_pgfault：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-29/52911484.jpg" alt=""><br>flush_block：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-29/63543357.jpg" alt=""></p>
</blockquote>
<p>完成之后，make grade：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-28/79325971.jpg" alt=""></p>
<p>这里完成之后，可以去查看<code>fs_init</code>函数，了解块缓存的使用方法：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-29/57921588.jpg" alt=""></p>
<p>init首先找一个可用的磁盘，函数<code>ide_probe_disk1</code>如下：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-29/66863600.jpg" alt=""><br>这个函数查找一个可以处于ready状态的磁盘块，优先选择磁盘块1。首先等待磁盘块0ready，随后检查等待磁盘块1ready。如果时间用尽块1仍未ready，就切回块0，否则使用块1。</p>
<p>随后初始化bc，读入超级块进cache、设置cache中的pgfault处理函数、检查bc可用。<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-29/71021418.jpg" alt=""></p>
<p>然后设置超级块的结构指针super指向超级块在内存中的位置，并检查超级块部分是否有效：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-29/35828038.jpg" alt=""></p>
<p>最后设置bitmap的结构指针指向位图在内存中的位置，并检查bitmap，保证块0，1以及bitmap部分是free的。<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-29/60207215.jpg" alt=""></p>
<h3 id="The-Block-Bitmap"><a href="#The-Block-Bitmap" class="headerlink" title="The Block Bitmap"></a>The Block Bitmap</h3><p>在<code>fs_init</code>设置了位图指针之后，我们就可以把位图当作bit的一个数组了。每一个bit代表磁盘上的一个block。</p>
<blockquote>
<p><strong>Exercise 3</strong><br>在写函数<code>alloc_block</code>之前，首先查看函数<code>free_block</code>：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-29/69666480.jpg" alt=""></p>
<p>相似的，结合<code>check_bitmap</code>中的代码，可以写出：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-29/56472823.jpg" alt=""></p>
</blockquote>
<p>完成之后：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-29/28669591.jpg" alt=""></p>
<h3 id="File-Operations"><a href="#File-Operations" class="headerlink" title="File Operations"></a>File Operations</h3><p>在向下进行之前，首先来看fs/fs.c中已经写好的exe3将会用到的但是尚未提到过的内容：</p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-29/16784140.jpg" alt=""><br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-29/52206581.jpg" alt=""></p>
<blockquote>
<p><strong>Exercise 4</strong><br><code>file_block_walk</code> and <code>file_get_block</code> in fs/fs.c<br><code>file_block_walk</code>是从一个指定的文件中找到一个指定的块，并将这个块在磁盘中的块号放在ppdiskbno中。<br>如果不成功则返回对应的错误代码。<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-29/41382565.jpg" alt=""></p>
<p><code>file_get_block</code>是从一个指定的文件中找到一个指定的块，并在必要的时候申请新的块，将对应块的被映射的虚拟地址放在blk[0]中。<br>如果不成功，则返回对应的错误代码。<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-29/20812261.jpg" alt=""></p>
</blockquote>
<p>完成后：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-29/10858808.jpg" alt=""></p>
<h3 id="The-file-system-interface"><a href="#The-file-system-interface" class="headerlink" title="The file system interface"></a>The file system interface</h3><p>现在文件系统已经有了必要的功能，下面需要允许其他进程来使用文件系统。由于其他进程不能直接调用文件系统中的函数，我们需要暴露文件系统进程的远程过程调用（RPC）。下图是调用文件系统服务的过程：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-29/57400463.jpg" alt=""></p>
<p>read读取文件，然后交给devfile_read读取磁盘上的文件。devfile一类的函数实现了文件系统操作的客户服务。在请求中绑定函数，调用fsipc发送IPC请求，并解包返回结果。fsipc函数处理向server发送请求和接受应答的常见细节。<br>文件系统服务器代码在fs/serv.c中。它在发送函数中循环，无休止地通过IPC接收请求，将该请求分派给相应的处理函数，并通过IPC发回结果。在阅读示例中，serve将调度到serve_read，它将处理特定于读取请求的IPC细节，例如解压缩请求结构，最后调用file_read来实际执行文件读取。<br>JOS的IPC机制让一个环境发送一个单一的32位数字，并可选择共享一个页面。为了从客户端向服务器发送请求，我们使用32位数的请求类型（文件系统服务器的RPC编号，就像syscalls的编号一样），并将参数存储到联合Fsipc中的请求上该页面通过IPC共享。在客户端，我们总是在fsipcbuf共享页面;在服务器端，我们将传入的请求页面映射到fsreq（0x0ffff000）。<br>服务器也通过IPC发送回应。我们使用32位数字作为函数的返回码。对于大多数RPC，这是他们所有的返回。 FSREQ_READ和FSREQ_STAT也会返回数据，他们只是写入客户端发送请求的页面。在响应IPC中不需要发送此页面，因为客户端首先将其与文件系统服务器共享。此外，FSREQ_OPEN在回复中与客户分享了一个新的“Fd页面”。我们很快会返回到文件描述符页面。</p>
<p>在写exe5之前，参考其他的serv类函数：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-30/2953715.jpg" alt=""></p>
<p>首先获得对应的OpenFile结构，随后利用OpenFile中的信息获得File信息，调用FS中的函数，完成任务。</p>
<p>OpenFile结构的定义如下：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-30/460405.jpg" alt=""></p>
<p>openfile_lookup函数从全局的数组中根据打开file的id获得对应的file，类似于env的获得。<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-30/27431119.jpg" alt=""></p>
<p>Fd结构记录了某一个打开文件的打开方式与偏移量等数据。每个打开的文件有一个Fd结构，就像是unix中的文件描述符一样。这个结构由自己的内存空间，而且与所有打开该文件的进程分享。<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-30/24773168.jpg" alt=""></p>
<p>本函数中使用file_read，这个函数：它从指定文件的指定偏移出读取count字节的数据放到给定的buf中。<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-30/31974794.jpg" alt=""></p>
<p>关于exe中的联合Fsipc，这里需要用到的一部分如下：<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-4/59890624.jpg" alt=""><br>其中对于read，req_fileid是对应文件的id，req_n是读取文件的偏移量；readRet中的buf则是在进行文件的读操作的时候，file_read放入数据的buf。<br>对于write，也是对应的字段。</p>
<blockquote>
<p><strong>Exercise 5</strong></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-30/25078071.jpg" alt=""></p>
</blockquote>
<p>完成后，可以通过serve_open/file_stat/file_close以及file_read：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-30/37810274.jpg" alt=""></p>
<p>对应的file_write是：他已经完成了必要时扩展的功能。与read类似，file_write是将buf中的内容放入对应文件的指定偏移位置。<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-30/35338392.jpg" alt=""><br>类似的，可以写出exe6中的serv_write函数。</p>
<p>在写devfile_write函数之前，首先看devfile_read函数：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-30/50945403.jpg" alt=""><br>它使用fspic发送请求，得到回答并将fsipc（serve）做的工作：读出的数据取回。<br>可以看到的是，fsipc（serve）所做的事情正是我们在前面所做的，serve_read中所做的事。</p>
<p>fsipc函数负责发送request与接受request，其函数体如下：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-30/44489755.jpg" alt=""><br>正如前面的图中所示，fsipc随后使用IPC与文件系统进程传递数据，文件系统进程在serve中接收数据并进行更上层的调用处理，为了更好地写出write函数，下面来看serve函数的处理方式：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-30/15017248.jpg" alt=""></p>
<p>其中的handlers是函数指针：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-30/23667793.jpg" alt=""><br>其中决定了各种除了open之外的处理方式。<br>对于write，可以看到，在fsipcbuf中设置的参数将会在之后用于调用serve_erite函数。</p>
<blockquote>
<p><strong>Exercise 6</strong><br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-30/86232535.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-30/88298637.jpg" alt=""></p>
</blockquote>
<p>完成之后：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-30/68942962.jpg" alt=""></p>
<h2 id="Spawning-Processes"><a href="#Spawning-Processes" class="headerlink" title="Spawning Processes"></a>Spawning Processes</h2><p>在lib/spawn.c中，已有的代码可以完成创建新进程，加载程序镜像，使子进程开始跑程序等。<br>我们使用spawn而不是用向unix一样的exec，这是因为spawn将可以更加容易地被实现。</p>
<p>在env.c中：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-30/49910736.jpg" alt=""><br>特权级设置。</p>
<blockquote>
<p><strong>Exercise 7</strong></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-30/27203900.jpg" alt=""></p>
</blockquote>
<p>完成之后：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-30/9954337.jpg" alt=""></p>
<h3 id="Sharing-library-state-across-fork-and-spawn"><a href="#Sharing-library-state-across-fork-and-spawn" class="headerlink" title="Sharing library state across fork and spawn"></a>Sharing library state across fork and spawn</h3><p>Uinx文件描述符是一个通用的概念，包括管道，控制台的IO等。每种这样的设备都包含一个对应的Dev结构，包含一个指向实现了read、write等函数的指针。lib/fd.c实现了像unix一样的文件描述符接口。每个fd结构代表他的设备类型，fd中的大部分函数都只是将任务分配到对应dev的函数。</p>
<p>lib/fd.c还在每一个应用程序环境的地址空间上维护文件描述符，从FSTABLE开始，这个区域保留了一个page的空间，允许每一个进程同时最多打开（MAXFD）32个文件。只有某一个文件被打开，对应的Fd才会被map到地址空间中去。每一个fd都有一个可选的data page，从FILEDATA开始，设备可以选择使用。</p>
<p>我们希望能够在fork与spawn之间共享file descriptor，但是文件描述符是被保存在用户空间的内存之中，在fork之中，这些内存需要被标记为cow，因此状态就会重复，而不是共享这也就是说，进程无法找到尚未打开的文件，管道也不可能工作在fork中,在spawn中，内存将会被丢到一旁。</p>
<p>我们需要更改fork，让她知道在特定的区间中内存被用于“library operating system”，并且应该总是共享的。在页表中设置一个位，让fork知道这件事，而不是再编写代码。</p>
<p>在inc/lib.h中定义了一个新的位：PTE_SHARE。它是Intel与AMD手册中标记为“可用于软件使用”的三个PTE位之一。我们将建立约定：如果某一个table entry的这一位被置位，就直接从父亲拷贝到儿子，不管是在spawn还是在fork。这与cow是完全不同的。</p>
<blockquote>
<p><strong>Exercise 8</strong><br>修改原来的duppage代码，当某一个页面被标记为SHARE的时候时，将同样的映射映射到对应的env上。<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-30/88536177.jpg" alt=""></p>
<p>copy_share_pages像是在fork函数中实现的复制映射的部分，只是这里无法调用duppage：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-30/97129281.jpg" alt=""></p>
</blockquote>
<p>完成之后：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-30/74350629.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-30/54441009.jpg" alt=""></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-30/3740941.jpg" alt=""></p>
<h2 id="The-keyboard-interface"><a href="#The-keyboard-interface" class="headerlink" title="The keyboard interface"></a>The keyboard interface</h2><p>为了使得shell可以工作，我们需要输入东西。QEMU已经可以在CGA显示器上显示我们的输入了，但是目前我们只是在内核监视器上进行输入。在qemu中，输入在图形窗口的输入显示为从键盘到JOS的输入，而输入到控制台的输入在串行端口上显示为字符。 kern / console.c已经包含了自实验1以来已被内核监视器使用的键盘和串口驱动程序，但是现在需要将这些驱动程序附加到系统的其他部分。</p>
<p>在写exe9之前，首先看将会被调用的两个函数kern/condole.c：</p>
<ol>
<li><p>kbd_intr：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-30/83206506.jpg" alt=""></p>
</li>
<li><p>serial_intr：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-30/33872725.jpg" alt=""></p>
</li>
</ol>
<p>具体操作偏向底层，这里不做讨论。</p>
<blockquote>
<p><strong>Exercise 9</strong><br>只需要按照描述调用函数：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-30/61363948.jpg" alt=""></p>
</blockquote>
<p>完成之后：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-30/39616597.jpg" alt=""></p>
<p>在lib/console.c中实现了输入输出文件类型， kbd_intr和serial_intr用最近读取的输入填充一个缓冲区，而控制台文件类型则消耗缓冲区（除非用户重定向，否则控制台文件类型默认用于stdin / stdout）。</p>
<hr>
<h2 id="The-Shell"><a href="#The-Shell" class="headerlink" title="The Shell"></a>The Shell</h2><p>运行user/icode。icode执行初始化操作，设置console为文件描述符0与1（标准输入输出），然后会spawn sh。随后可以运行一些命令。</p>
<p>注意，cprintf直接打印到控制台，而不使用文件描述符代码。这对于调试来说很好，但对于其他程序的管道来说并不好。要将输出打印到特定的文件描述符（例如，1，标准输出）需要使用fprintf（1，“…”，…）。 printf（“…”，…）是打印到FD1。</p>
<p>首先查看user/icode.c文件，在启动完成之后，初始化spawn：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-30/85970380.jpg" alt=""><br>spawnl函数在lib/spawn.c中被定义，它将会处理输入的执行程序名与命令行参数并调用spawn函数进行执行。<br>在spawn函数中，将遵循以下执行步骤：</p>
<ol>
<li>打开程序文件</li>
<li>像以前一样读ELF头，然后检查其IMAGE</li>
<li>使用sys_exofork创建一个新的进程</li>
<li>将child_tf设置为孩子的Trapframe</li>
<li>调用init_stack函数来初始化子环境的堆栈</li>
<li>映射所有程序段的p_type ELF_PROG_LOAD进入新环境的地址空间。对每个段使用Proghdr中的p_flags字段确定如何映射段。</li>
<li>调用sys_env_set_trapframe(child，＆child_tf)来设置子进程中的正确的eip和esp值。</li>
<li>用sys_env_set_status()启动子进程。</li>
</ol>
<p>这个exe可以参考write的写法：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-30/68914710.jpg" alt=""></p>
<p>其中的dup函数在fd.c中被定义，其函数体如下：<br><img src="http://oysmkdi7t.bkt.clouddn.com/18-1-4/68092874.jpg" alt=""><br>它将一个fd变成另外一个fd的duplicate，对一个操作，也会影响另外一个。</p>
<blockquote>
<p><strong>Exercise 10</strong></p>
<p><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-30/44717482.jpg" alt=""></p>
</blockquote>
<p>完成之后：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-30/31362968.jpg" alt=""></p>
<p>本实验结束。最后make grade：<br><img src="http://oysmkdi7t.bkt.clouddn.com/17-12-30/10360665.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> OS </category>
            
            <category> MIT Lab </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OS </tag>
            
        </tags>
        
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[all-archives]]></title>
      <url>/all-archives/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于]]></title>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<p>╰(￣ω￣ｏ)！</p>
<p>就不说什么能认识大家很开心之类的废话了！</p>
<p>我目前还在大学奔波忙碌，真的完全是小白啦！之前学习专业课的时候受到很多大神博主的帮助，中文文档简直是瑰宝！</p>
<p>所以~希望我的东西或多或少也能帮助到别人！</p>
<p>鞠躬~(●’◡’●)</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[all-categories]]></title>
      <url>/all-catagories/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[schedule]]></title>
      <url>/schedule/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[categories]]></title>
      <url>/categories/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[tags]]></title>
      <url>/tags/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[读书]]></title>
      <url>/reading/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[sitemap]]></title>
      <url>/sitemap/index.html</url>
      <content type="html"></content>
    </entry>
    
  
</search>
